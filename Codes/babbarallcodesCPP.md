# jafs.cpp


```cpp

fajfhfsjfsfksfs


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Namaste_Dunia.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    
    cout << "Namaste Dunia" << endl;
    
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Datatypes_And_Variables.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    
    int a = 123;
    cout << a << endl;

    char ch = 'a';
    cout << ch << endl;

    float f = 1.2;
    cout << f << endl;

    bool bl = true;
    cout << bl << endl;

    double d = 1.23;
    cout << d << endl;

    int size = sizeof(d);
    cout << "Size of d is : " << size << endl;
    
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Typecasting.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    
    int a = 'a';
    cout << a << endl;

    char ch = 98;
    cout << ch << endl;

    char ch1 = 123456;
    cout << ch1 << endl;
    
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Signed_And_Unsigned_Datatypes.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    
    unsigned int a = 112;
    cout << a << endl;

    unsigned int a1 = -112;
    cout << a1 << endl;

    signed int b = 112;
    cout << b << endl;

    signed int b1 = -112;
    cout << b1 << endl;

}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Arithmetic_Operators.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    
    int a = 2 / 5;
    cout << a << endl;

    float a1 = 2.0 / 5;
    cout << a1 << endl;
    
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Relational_Operators.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    
    int a = 2;
    int b = 3;

    bool first = (a == b);
    cout << first << endl;
    
    bool second = (a != b);
    cout << second << endl;

    bool third = (a < b);
    cout << third << endl;
    
    bool fourth = (a > b);
    cout << fourth << endl;

    bool fifth = (a <= b);
    cout << fifth << endl;

    bool sixth = (a >= b);
    cout << sixth << endl;

}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Logical_Opeartors.cpp


```cpp

#include <iostream>
using namespace std;

int main() {

    int a = 0;
    cout << !a << endl;

    int b = 5;
    cout << !b << endl;
    
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Check_Positive_Negative_Zero.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    if(n<0) {
        cout<<"n is negative !"<<endl;
    } else if(n>0) {
        cout<<"n is positive !"<<endl;
    } else {
        cout<<"n is zero !"<<endl;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Greater_Of_Two_Numbers.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int a, b;

    cout<<"Enter the value of a : ";
    cin>>a;

    cout<<"Enter the value of b : ";
    cin>>b;

    if(a>b) {
        cout<<"a is greater"<<endl;
    } else {
        cout<<"b is greater"<<endl;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Lowercase_Uppercase_Number.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    char ch;

    cout<<"Enter the character : ";
    cin>>ch;

    if(ch>='A' && ch<='Z') {
        cout<<"Uppercase Character !"<<endl;
    } else if(ch>='a' && ch<='z') {
        cout<<"Lowercase Character !"<<endl;
    } else {
        cout<<"Number !"<<endl;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Counting_Numbers.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int i = 1;

    while(i <= n) {
        cout<<i<<" ";
        i = i+1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Sum_Of_Numbers_1-to-N.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int i = 1;
    int sum = 0;

    while(i <= n) {
        sum = sum + i;
        i = i + 1;
    }

    cout<<"Sum of n numbers = "<<sum<<endl;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Sum_Of_Even_Numbers_1-to-N.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int i = 2;
    int sum = 0;

    while(i <= n) {
        sum = sum + i;
        i = i + 2;
    }

    cout<<"Sum of even numbers upto n = "<<sum<<endl;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Fahrenheit_To_Celsius.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    float f;

    cout<<"Enter the temperature in fahrenheit : ";
    cin>>f;

    float c = ((f-32) * 5) / 9;

    cout<<"Temperature in celsius : "<<c<<endl;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 8_Pattern_1.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
        * * * *
        * * * *
        * * * *
        * * * *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int i = 1;

    while(i <= n) {
        int j = 1;

        while(j<=n) {
            cout<<"* ";
            j = j + 1;
        }

        cout<<endl;
        i = i + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 9_Pattern_2.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
        1 1 1 1
        2 2 2 2
        3 3 3 3
        4 4 4 4
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int i = 1;

    while(i <= n) {
        int j = 1;

        while(j<=n) {
            cout<<i<<" ";
            j = j + 1;
        }

        cout<<endl;
        i = i + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 2 3 4
    1 2 3 4
    1 2 3 4
    1 2 3 4
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            cout<<col<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    4 3 2 1
    4 3 2 1
    4 3 2 1
    4 3 2 1
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col= n;

        while(col>= 1) {
            cout<<col<<" ";
            col= col- 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 2 3
    4 5 6
    7 8 9
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;
    int count = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            cout<<count<<" ";
            col = col + 1;
            count = count + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    *
    * *
    * * *
    * * * *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1
    2 2
    3 3 3
    4 4 4 4
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<row<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1
    2 3
    4 5 6
    7 8 9 10
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;
    int count = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<count<<" ";
            count = count + 1;
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1
    2 3
    3 4 5
    4 5 6 7
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<< row+col-1 <<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1
    2 1
    3 2 1
    4 3 2 1
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<< row-col+1 <<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 09_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A A A
    B B B
    C C C
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            char value = 'A' + row - 1;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 10_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A B C D
    A B C D
    A B C D
    A B C D
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            char value = 'A' + col - 1;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 11_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A B C
    D E F
    G H I
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;
    char value = 'A';

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            cout<<value<<" ";
            value = value + 1;
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 12_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A B C
    B C D
    C D E
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            char value = 'A' + row + col - 2;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 13_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A
    B B
    C C C
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            char value = 'A' + row - 1;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 14_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A
    B C
    D E F
    G H I J
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;
    char value = 'A';

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<value<<" ";
            value = value + 1;
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 15_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A
    B C
    C D E
    D E F G
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            char value = 'A' + row + col - 2;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 16_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    D 
    C C
    B B B
    A A A A
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            char value = 'A' + n - row;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 17_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    D
    C D
    B C D
    A B C D
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            char value = 'A' + n - row - 1 + col;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 18_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    A B C
    B C D
    C D E
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n) {
            char value = 'A' + row + col - 2;
            cout<<value<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 19_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
        *
      * *
    * * *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n-row) {
            cout<<"  ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 20_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    * * * *
    * * *
    * *
    * 
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 0;

        while(col <= n-row) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 21_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    * * * *
      * * *
        * *
          *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 0;

        while(col < row) {
            cout<<"  ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 22_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 1 1 1
      2 2 2
        3 3
          4
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 0;

        while(col < row) {
            cout<<"  ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<row<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 23_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
          1
        2 2
      3 3 3
    4 4 4 4
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 0;

        while(col < n-row) {
            cout<<"  ";
            col = col + 1;
        }

        while(col < n) {
            cout<<row<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 24_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 2 3 4
      2 3 4
        3 4
          4
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 0;

        while(col < row) {
            cout<<"  ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<col<<" ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 25_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
          1
        2 3
      4 5 6
    7 8 9 10
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;
    int count = 1;

    while(row <= n) {
        int col = 0;

        while(col < n-row) {
            cout<<"  ";
            col = col + 1;
        }

        while(col < n) {
            cout<<count<<" ";
            count = count + 1;
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 26_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
          1
        1 2 1
      1 2 3 2 1
    1 2 3 4 3 2 1
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 0;

        while(col < n-row) {
            cout<<"  ";
            col = col + 1;
        }

        int count = 1;

        while(count <= row) {
            cout<<count<<" ";
            count = count + 1;
        }

        count = count - 1;

        while(count > 1) {
            count = count - 1;
            cout<<count<<" ";
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 27_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 2 3 4 5 5 4 3 2 1
    1 2 3 4 * * 4 3 2 1
    1 2 3 * * * * 3 2 1
    1 2 * * * * * * 2 1
    1 * * * * * * * * 1
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n-row+1) {
            cout<<col<<" ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* * ";
            col = col + 1;
        }

        col = n-row+1;

        while(col > 0) {
            cout<<col<<" ";
            col = col - 1;
        }

        cout<<endl;
        row = row + 1;
    }
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 28_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
        *
       * *
      * * *
     * * * *
    * * * * *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n-row) {
            cout<<" ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 29_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    * * * * *
     * * * *
      * * *
       * *
        *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col < row) {
            cout<<" ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 30_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    *
    * *
    * * *
    * * * *
    * * * * *
    * * * *
    * * *
    * *
    * 
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    row = 1;

    while(row < n) {
        int col = 1;

        while(col <= n-row) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 31_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    * * * * *
     * * * *
      * * *
       * *
        *
        * 
       * *
      * * *
     * * * *
    * * * * *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col < row) {
            cout<<" ";
            col = col + 1;
        }

        col = 1;

        while(col <= n-row+1) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n-row) {
            cout<<" ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 32_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
        * 
       * *
      * * *
     * * * *
    * * * * *
    * * * * *
     * * * *
      * * *
       * *
        *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= n-row) {
            cout<<" ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    row = 1;

    while(row <= n) {
        int col = 1;

        while(col < row) {
            cout<<" ";
            col = col + 1;
        }

        col = 1;

        while(col <= n-row+1) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 33_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    * * * * *
      * * * * *
        * * * * *
          * * * * *
           * * * * *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col < row) {
            cout<<" ";
            col = col + 1;
        }

        col = 1;

        while(col <= n) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 34_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    *                 *
    * *             * *
    * * *         * * *
    * * * *     * * * *
    * * * * * * * * * *
    * * * *     * * * *
    * * *         * * *
    * *             * *
    *                 *
    */

    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<"* ";
            col = col + 1;
        }

        col = 1;

        while(col <= n-row) {
            cout<<"    ";
            col = col + 1;
        }

        col = 1;

        while(col <= row) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    row = 1;

    while(row < n) {
        int col = 1;

        while(col < n-row+1) {
            cout<<"* ";
            col = col + 1;
        }

        while(col <= n) {
            cout<<"    ";
            col = col + 1;
        }

        col = 1;

        while(col < n-row+1) {
            cout<<"* ";
            col = col + 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 35_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 * * * * * * * * 1
    1 2 * * * * * * 2 1
    1 2 3 * * * * 3 2 1
    1 2 3 4 * * 4 3 2 1
    1 2 3 4 5 5 4 3 2 1
    */
 
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;

    while(row <= n) {
        int col = 1;

        while(col <= row) {
            cout<<col<<" ";
            col = col + 1;
        }

        while(col < row) {
            cout<<" ";
            col = col + 1;
        }

        col = 1;

        while(col < n-row+1) {
            cout<<"* * ";
            col = col + 1;
        }

        col = row;

        while(col >= 1) {
            cout<<col<<" ";
            col = col - 1;
        }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 36_Pattern.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    /*
    1 2 3 4 5 16 17 18 19 20
    6 7 8 9 21 22 23 24
    10 11 12 25 26 27
    13 14 28 29
    15 30
    */
 
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    int row = 1;
    int count1 = 1;
    int count2 = ((n*(n+1)) / 2) + 1;

    while(row <= n) {
        int col = 0;

        while(col <= n-row) {
            cout<<count1++<<" ";
            col = col + 1;
        }
        
        col = 0;
        while(col <= n-row) {
            cout<<count2++<<" ";
            col = col + 1;
        }
        // col = 1;

        // while(col < n-row+1) {
        //     cout<<"* * ";
        //     col = col + 1;
        // }

        // col = row;

        // while(col >= 1) {
        //     cout<<col<<" ";
        //     col = col - 1;
        // }

        cout<<endl;
        row = row + 1;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Bitwise_Operator.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int a = 5;
    int b = 7;
    int value;

    value = a&b;
    cout<<"a & b = "<<value<<endl;

    value = a|b;
    cout<<"a | b = "<<value<<endl;
    
    value = ~a;
    cout<<"~a = "<<value<<endl;
    
    value = ~b;
    cout<<"~b = "<<value<<endl;
    
    value = a^b;
    cout<<"a ^ b = "<<value<<endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Left_and_Right_Shift_Operator.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int b = 20;

    a = a << 1;
    cout<<"a after left shift = "<<a<<endl;

    b = b >> 1;
    cout<<"b after right shift = "<<b<<endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Increment_and_Decrement_Operator.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int i = 10;

    cout << "Pre-Increment i = " << ++i << endl;

    cout << "Post-Increment i = " << i++ << endl;

    cout << "Pre-Decrement i = " << --i << endl;

    cout << "Post-Decrement i = " << i-- << endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Fibonacci_Series.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int a = 0;
    int b = 1;
    int sum = 1;

    int n;
    cout<<"Enter the value of n : ";
    cin>>n;

    cout<<a<<" "<<b<<" ";

    for(int i=2; i<n; i++) {
        sum = a + b;
        cout<<sum<<" ";
        a = b;
        b = sum;
    }
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Check_Prime_Number.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;

    bool isPrime = true; 

    for(int i=2; i<n; i++) {
        if(n%i == 0) {
            cout<<"Not a prime number!"<<endl;
            isPrime = false;
            break;
        }
    }

    if(isPrime) {
        cout<<"Prime number!"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Subtract_the_Product_and_Sum_of_Digits_of_an_Integer.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;

    int product = 1;
    int sum = 0;

    while(n != 0) {
        int digit = n%10;

        product *= digit;
        sum += digit;

        n /= 10;
    }

    int answer = product - sum;

    cout<<"Required answer = "<<answer<<endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Number_of_1_Bits.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;

    int count = 0;

    while(n != 0) {
        if(n&1) {
            count++;
        }

        n = n >> 1;
    }

    cout<<"Required count = "<<count<<endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Decimal_To_Binary.cpp


```cpp

#include <iostream>
using namespace std;

int pow(int n, int p) {
    return (p==0) ? 1 : n*pow(n, p-1);
}

int main() {
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;

    int answer = 0;
    int i = 0;

    while(n != 0) {
        int bit = n & 1;

        answer = answer + (bit * pow(10,i));

        i++;
        n = n >> 1;
    }

    cout<<"Converted Binary Number : "<<answer<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Negative_Decimal_To_Binary.cpp


```cpp

#include <iostream>
using namespace std;

int pow(int n, int p) {
    return (p==0) ? 1 : n*pow(n, p-1);
}

int main() {
    int n;
    cout<<"Enter a negative number : ";
    cin>>n;

    n *= (-1);      //Converting the negative number into positive to find its binary representation

    int answer = 0;
    int i = 0;

    n = (~n);       // Getting the 1's compliment of the number
    n = n + 1;      // Adding 1 in order to obtain the 2's compliment of the number

    while(n != 0 && n != -1) {
        int bit = n & 1;

        answer = answer + (bit * pow(10,i));

        i++;
        n = n >> 1;
    }

    cout<<"Converted Binary Number : "<<answer<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Binary_To_Decimal.cpp


```cpp

#include <iostream>
using namespace std;

int pow(int n, int p) {
    return (p==0) ? 1 : n*pow(n, p-1);
}

int main() {
    int n;
    cout<<"Enter the value of n : ";
    cin>>n;

    int answer = 0;
    int i = 0;

    while(n != 0) {
        int digit = n % 10;

        if(digit == 1) {
            answer = answer + pow(2,i);
        }

        i++;
        n /= 10;
    }

    cout<<"Converted Binary Number : "<<answer<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Reverese_Integer.cpp


```cpp

#include <iostream>
#include <limits.h>
using namespace std;

int reverse(int x) {
    int ans = 0;

    while(x != 0) {
        if((ans > INT_MAX/10) || (ans < INT_MIN/10)) {
            return 0;
        }

        int digit = x%10;

        ans = (ans*10) + digit;

        x /= 10;
    }

    return ans;
}

int main() {
    int n;

    cout<<"Enter the number to reverse : ";
    cin>>n;

    int rev = reverse(n);

    cout<<"Reversed number = "<<rev<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Complement_Of_Base_10_Integer.cpp


```cpp

#include <iostream>
using namespace std;

int bitwiseComplement(int n) {
    int m = n;
    int mask = 0;

    // Edge case
    if(n == 0) {
        return 1;
    }

    while(m != 0) {
        mask = (mask << 1) | 1;
        m = m >> 1;
    }

    int ans = (~n) & mask;

    return ans;
}

int main() {
    int n;

    cout<<"Enter the number : ";
    cin>>n;

    int complement = bitwiseComplement(n);

    cout<<"Required bitwise complement = "<<complement<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Power_Of_2.cpp


```cpp

#include <iostream>
#include <limits.h>
using namespace std;

bool isPowerOfTwo(int n) {
    int power = 1;

    for(int i=0; i<31; i++) {
        if(power == n) {
            return true;
        }

        if(power < INT_MAX/2) {
            power *= 2;
        }
    }

    return false;
}

int main() {
    int n;

    cout<<"Enter the number : ";
    cin>>n;

    if(isPowerOfTwo(n)) {
        cout<<n<<" is a power of two!"<<endl;
    } else {
        cout<<n<<" is not a power of two!"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_Switch_Introduction.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int num = 2;

    switch(num) {
        case 1 : cout<<"First"<<endl;
            break;
        
        case 2 :
            cout<<"Second"<<endl;
            break;
            
        default :
            cout<<"Default case"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Switch_Case_In_Infinite_Loop.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int num = 2;

    while(1) {
        switch(num) {
            case 1 : cout<<"First"<<endl;
                break;
            
            case 2 :
                cout<<"Second"<<endl;
                exit(0);
                break;
            
            default :
                cout<<"Default case"<<endl;
        }
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Calculator.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int a, b;

    cout<<"Enter the value of a : ";
    cin>>a;

    cout<<"Enter the value of b : ";
    cin>>b;

    char op;
    cout<<"Enter the operation you want to perform : ";
    cin>>op;

    switch(op) {
        case '+' : cout<<a<<" "<<op<<" "<<b<<" = "<<a+b<<endl;
            break;
        
        case '-' : cout<<a<<" "<<op<<" "<<b<<" = "<<a-b<<endl;
            break;
        
        case '*' : cout<<a<<" "<<op<<" "<<b<<" = "<<a*b<<endl;
            break;
        
        case '/' : cout<<a<<" "<<op<<" "<<b<<" = "<<a/b<<endl;
            break;
            
        default :
            cout<<"Please enter a valid operator !"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Currency_Notes_Distribution.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int amount;
    int n100=0, n50=0, n20=0, n1=0;

    cout<<"Enter the amount : ";
    cin>>amount;

    switch(amount >= 100) {
        case 1 :
            n100 = amount/100;
            amount %= 100;
    }

    switch(amount >= 50) {
        case 1 :
            n50 = amount/50;
            amount %= 50;
    }

    switch(amount >= 20) {
        case 1 :
            n20 = amount/20;
            amount %= 20;
    }

    n1 = amount;

    cout<<"100 Rupees note = "<<n100<<endl;
    cout<<"50 Rupees note = "<<n50<<endl;
    cout<<"20 Rupees note = "<<n20<<endl;
    cout<<"1 Rupees note = "<<n1<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Function_Introduction.cpp


```cpp

#include <iostream>
using namespace std;

int power(int x, int y) {
    int ans = 1;

    for(int i=1; i<=y; i++) {
        ans *= x;
    }

    return ans;
}

int main() {
    int a, b;

    cout<<"Enter the value of a : ";
    cin>>a;

    cout<<"Enter the value of b : ";
    cin>>b;

    int answer = power(a,b);

    cout<<"Answer = "<<answer<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Even_Odd.cpp


```cpp

#include <iostream>
using namespace std;

bool isEven(int x) {
    if(x&1) {
        return 0;
    } else {
        return 1;
    }
}

int main() {
    int num;

    cout<<"Enter the num : ";
    cin>>num;

    if(isEven(num)) {
        cout<<"Even Number!"<<endl;
    } else {
        cout<<"Odd Number!"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_nCr.cpp


```cpp

#include <iostream>
using namespace std;

int factorial(int num) {
    int fact = 1;

    for(int i=1; i<=num; i++) {
        fact *= i;
    }

    return fact;
}

// nCr = n!/r!(n-r)!
int nCr(int n, int r) {
    int num = factorial(n);
    int denum = factorial(r) * factorial(n-r);

    int answer = num/denum;

    return answer;
}

int main() {
    int n, r;

    cout<<"Enter the value of n : ";
    cin>>n;

    cout<<"Enter the value of r : ";
    cin>>r;

    int answer = nCr(n, r);

    cout<<"Answer = "<<answer<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Counting.cpp


```cpp

#include <iostream>
using namespace std;

void printCounting(int n) {
    for(int i=1; i<=n; i++) {
        cout<<i<<" ";
    }
}

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    printCounting(n);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 09_isPrime.cpp


```cpp

#include <iostream>
using namespace std;

bool isPrime(int num) {
    for(int i=2; i<num; i++) {
        if(num%i == 0) {
            return 0;
        }
    }

    return 1;
}

int main() {
    int n;

    cout<<"Enter the number : ";
    cin>>n;

    if(isPrime(n)) {
        cout<<"Prime number!"<<endl;
    } else {
        cout<<"Not a prime number!"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 10_Nth_Term_Of_AP.cpp


```cpp

#include <iostream>
using namespace std;

// AP : 3*n + 7
int NthTerm(int n) {
    return 3*n + 7;
}

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    cout<<"Nth term of the AP = "<<NthTerm(n)<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 11_Total_Setbits.cpp


```cpp

#include <iostream>
using namespace std;

int countSetbits(int n) {
    int count = 0;

    while(n != 0) {
        if(n&1 == 1) {
            count++;
        }
        
        n = n>>1;
    }

    return count;
}

int main() {
    int a, b;

    cout<<"Enter the value of a : ";
    cin>>a;

    cout<<"Enter the value of b : ";
    cin>>b;

    int totalSetbits = countSetbits(a) + countSetbits(b);

    cout<<"Total count of setbits = "<<totalSetbits<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 12_Nth_Fibonacci_Number.cpp


```cpp

#include <iostream>
using namespace std;

int NthFibNum(int n) {
    int a=0, b=1, c=-1;

    if(n<=2) {
        return n-1;
    }

    for(int i=2; i<n; i++) {
        c = a+b;
        a = b;
        b = c;
    }

    return c;
}

int main() {
    int n;

    cout<<"Enter the number of n : ";
    cin>>n;

    cout<<"Nth fibonacci number = "<<NthFibNum(n)<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 13_Pass_By_Value.cpp


```cpp

#include <iostream>
using namespace std;

void dummy(int n) {
    n++;
    cout<<"In dummy : n = "<<n<<endl;
}

int main() {
    int n;

    cout<<"Enter the value of n : ";
    cin>>n;

    cout<<"Before call : n = "<<n<<endl;

    dummy(n);

    cout<<"After call : n = "<<n<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Array_introduction.cpp


```cpp

#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
    cout<<"Printing array : ";

    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }

    cout<<endl;
}

int main() {
    int arr[15] = {0};

    printArray(arr, 15);

    cout<<"Size of array = "<<sizeof(arr)<<endl;
    cout<<"Length of array = "<<sizeof(arr) / sizeof(int)<<endl;


    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Max_Min_In_Array.cpp


```cpp

#include <iostream>
#include <limits.h>
using namespace std;

int getMax(int arr[], int size) {
    int max = INT_MIN;

    for(int i=0; i<size; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }

    return max;
}

int getMin(int arr[], int size) {
    int min = INT_MAX;

    for(int i=0; i<size; i++) {
        if(arr[i] < min) {
            min = arr[i];
        }
    }

    return min;
}

int main() {
    int size;
    cout<<"Enter the size of the array : ";
    cin>>size;

    int arr[100];

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Maximum element of the array = "<<getMax(arr, size)<<endl;
    cout<<"Minimum element of the array = "<<getMin(arr, size)<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Array_Scope.cpp


```cpp

#include<iostream>
using namespace std;

void update(int arr[], int n) {
    cout << endl << "Inside the function" <<endl;
    
    //updating array's first element
    arr[0] = 120;

    for(int i=0; i<3; i++) {
        cout<<arr[i]<<" ";
    }

    cout<<endl;
}


int main() {
    int arr[3] = {1,2,3};

    update(arr, 3);

    cout<<"Printing in main function"<<endl;

    for(int i=0; i<3; i++) {
        cout<<arr[i]<<" ";
    }

    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Sum_Of_Elements_In_Array.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    int size, sum=0;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the element of the array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
        sum += arr[i];
    }

    cout<<"Sum of all elements of the array = "<<sum<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Linear_Search.cpp


```cpp

#include <iostream>
using namespace std;

bool linearSearch(int arr[], int size, int key) {
    for(int i=0; i<size; i++) {
        if(arr[i] == key) {
            return true;
        }
    }

    return false;
}

int main() {
    int size, key;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the element of the array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Enter the key to search for : ";
    cin>>key;

    if(linearSearch(arr, size, key)) {
        cout<<"Element found in the array!"<<endl;
    } else {
        cout<<"Element not found in the array!"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Reverse_Array.cpp


```cpp

#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void reverseArray(int arr[], int size) {
    int start = 0;
    int end = size-1;

    while(start < end) {
        swap(arr[start], arr[end]);
        start++;
        end--;
    }
}

int main() {
    int size, key;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the element of the array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Array before reverse : ";
    printArray(arr, size);

    reverseArray(arr, size);
    
    cout<<"Array after reverse : ";
    printArray(arr, size);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_Swap_Alternate_Elements.cpp


```cpp

#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void swapAlternate(int arr[], int size) {
    for(int i=0; i<size-1; i+=2) {
        swap(arr[i], arr[i+1]);
    }
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Before swaping alternate elements : ";
    printArray(arr, size);

    swapAlternate(arr, size);
    
    cout<<"After swaping alternate elements : ";
    printArray(arr, size);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Find_Unique_Element.cpp


```cpp

#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

int findUnique(int arr[], int size) {
    int unique = 0;

    for(int i=0; i<size; i++) {
        unique = unique ^ arr[i];
    }
    
    return unique;
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Single unique element present in the array : "<<findUnique(arr, size)<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Unique_Number_Of_Occurrences.cpp


```cpp

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

bool uniqueOccurrences(int arr[], int size) {
    vector<int> count;
    
    //In-built function to sort the array
    sort(arr, arr+size);

    for(int i=0; i<size; i++) {
        int cnt = 0;
        int flag = arr[i];

        while(i<size && arr[i] == flag) {
            i++;
            cnt++;
        }
        i--;

        count.push_back (cnt);
    }

    sort(count.begin(), count.end());

    for(int i=0; i<count.size()-1; i++) {
        if(count[i] == count[i+1]) {
            return false;
        }
    }

    return true;
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    if(uniqueOccurrences(arr, size)) {
        cout<<"Number of occurrences of each value is the array is unique!"<<endl;
    } else {
        cout<<"Number of occurrences of each value is the array is not unique!"<<endl;
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Find_Duplicate_Element_In_Array.cpp


```cpp

#include <iostream>
using namespace std;

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

int findDuplicate(int arr[], int size) {
    int ans = 0;
    for(int i=0; i<size; i++) {
        ans = ans ^ arr[i];
    }

    for(int i=1; i<size; i++) {
        ans = ans ^ i;
    }

    return ans;
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Duplicate element in he array : "<<findDuplicate(arr, size)<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Find_All_Duplicates_In_Array.cpp


```cpp

#include <iostream>
#include <algorithm>
using namespace std;

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void findDuplicates(int nums[], int size) {
    sort(nums, nums+size);

    for(int i=0; i<size-1; i++) {
        if(nums[i] == nums[i+1]) {
            cout<<nums[i]<<" ";
            i++;
        }
    }
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"All duplicate elements of array : ";
    findDuplicates(arr, size);

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Intersection_Of_Two_Arrays.cpp


```cpp

#include <iostream>
using namespace std;

void inputArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }
}

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void intersectionArray(int arr1[], int arr2[], int size1, int size2) {
    int i=0, j=0;

    while(i<size1 && j<size2) {
        if(arr1[i] < arr2[j]) {
            i++;
        }

        if(arr1[i] > arr2[j]) {
            j++;
        }

        if(arr1[i] == arr2[j]) {
            cout<<arr1[i]<<" ";
            
            while(arr1[i] == arr2[j]) {
                i++;
                j++;
            }
        }
    }
}

int main() {
    int size1, size2;
    int arr1[100], arr2[100];

    cout<<"Enter the size of first array : ";
    cin>>size1;

    cout<<"Enter the elements of first array : ";
    inputArray(arr1, size1);

    cout<<"Enter the size of second array : ";
    cin>>size2;

    cout<<"Enter the elements of second array : ";
    inputArray(arr2, size2);

    cout<<"Intersection elements of these two arrays : ";
    intersectionArray(arr1, arr2, size1, size2);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_Pair_Sum.cpp


```cpp

#include <iostream>
using namespace std;

void inputArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }
}

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void pairSum(int arr[], int size, int sum) {
    for(int i=0; i<size-1; i++) {
        for(int j=i+1; j<size; j++) {
            if(arr[i] + arr[j] == sum) {
                cout<<"New pair : "<<arr[i]<<" & "<<arr[j]<<endl;
            }
        }
    }
}

int main() {
    int size, targetSum;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    inputArray(arr, size);

    cout<<"Enter the target sum : ";
    cin>>targetSum;

    pairSum(arr, size, targetSum);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Triplet_With_Given_Sum.cpp


```cpp

#include <iostream>
using namespace std;

void inputArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }
}

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void tripletSum(int arr[], int size, int sum) {
    for(int i=0; i<size-2; i++) {
        for(int j=i+1; j<size-1; j++) {

            for(int k=j+1; k<size; k++) {
                if(arr[i] + arr[j] + arr[k] == sum) {
                    cout<<"New triplet : "<<arr[i]<<", "<<arr[j]<<" & "<<arr[k]<<endl;
                }
            }

        }
    }
}

int main() {
    int size, targetSum;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    inputArray(arr, size);

    cout<<"Enter the target sum : ";
    cin>>targetSum;

    tripletSum(arr, size, targetSum);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 09_Sort_0_1.cpp


```cpp

#include <iostream>
using namespace std;

void inputArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }
}

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

void sort01(int arr[], int size) {
    int start = 0;
    int end = size-1;

    while(start <= end) {
        while(arr[start] == 0 && start <= end) {
            start++;
        }

        while(arr[end] == 1 && start <= end) {
            end--;
        }

        while(arr[start]==1 && arr[end]==0 && start <= end) {
            swap(arr[start], arr[end]);
            start++;
            end--;
        }
    }
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    inputArray(arr, size);

    cout<<"Array before sorting : ";
    printArray(arr, size);

    sort01(arr, size);

    cout<<"Array after sorting : ";
    printArray(arr, size);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 10_Sort_0_1_2.cpp


```cpp

#include <iostream>
using namespace std;

void inputArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }
}

void printArray(int arr[], int size) {
    for(int i=0; i<size; i++) {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}

// DNF (Dutch-National-Flag) Algorithm
// Red - White - Blue Ball Questions
// low - mid - high variables (3 pointers)
void sort012(int arr[], int size) {
    int low = 0;
    int mid = 0;
    int high = size-1;

    while(mid <= high) {
 
        switch(arr[mid]) {
            case 0:
                swap(arr[mid++], arr[low++]);
                break;
            case 1:
                mid++;
                break;
            case 2:
                swap(arr[mid], arr[high--]);
                break;
        }
        
    }
}

int main() {
    int size;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    inputArray(arr, size);

    cout<<"Array before sorting : ";
    printArray(arr, size);

    sort012(arr, size);

    cout<<"Array after sorting : ";
    printArray(arr, size);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Intro_To_Binary_Search.cpp


```cpp

#include <iostream>
using namespace std;

int binarySearch(int arr[], int size, int key) {
    int start = 0;
    int end = size-1;

    // int mid = (start+end)/2;

    // Formula to avoid overflowed values
    int mid = start + (end-start)/2;

    while(start <= end) {
        if(arr[mid] == key) {
            return mid;
        }

        if(key > arr[mid]) {
            // Go to right part
            start = mid + 1;
        } else {
            // Go to left part
            end = mid - 1;
        }

        mid = start + (end-start)/2;
    }

    return -1;
}

int main() {
    int evenSize[6] = {2, 4, 6, 8, 12, 18};
    int oddSize[5] = {3, 8, 11, 14, 16};

    int evenIndex = binarySearch(evenSize, 6, 12);

    cout<<"Index of 12 is "<<evenIndex<<endl;

    int oddIndex = binarySearch(oddSize, 5, 3);

    cout<<"Index of 3 is "<<oddIndex<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_First_And_Last_Position_Of_Element_In_Sorted_Array.cpp


```cpp

#include <iostream>
using namespace std;

int firstPosition(int arr[], int size, int key) {
    int start = 0;
    int end = size-1;
    int mid = start + (end-start)/2;

    int ans = -1;

    while(start <= end) {
        if(arr[mid] == key) {
            ans = mid;
            end = mid - 1;
        } else if(key > arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }

        mid = start + (end-start)/2;
    }

    return ans;
}

int lastPosition(int arr[], int size, int key) {
    int start = 0;
    int end = size-1;
    int mid = start + (end-start)/2;

    int ans = -1;

    while(start <= end) {
        if(arr[mid] == key) {
            ans = mid;
            start = mid + 1;
        } else if(key > arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }

        mid = start + (end-start)/2;
    }

    return ans;
}

int main() {
    int n, element;
    int arr[100];

    cout<<"Enter the size of the array : ";
    cin>>n;

    cout<<"Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"Enter the element to search for : ";
    cin>>element;
    
    int first = firstPosition(arr, n, element);
    int last = lastPosition(arr, n, element);

    cout<<"First position : "<<first<<endl;
    cout<<"Last position : "<<last<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Total_Number_Of_Occurrences_In_Sorted_Array.cpp


```cpp

#include <iostream>
using namespace std;

int firstPosition(int arr[], int size, int key) {
    int start = 0;
    int end = size-1;
    int mid = start + (end-start)/2;

    int ans = -1;

    while(start <= end) {
        if(arr[mid] == key) {
            ans = mid;
            end = mid - 1;
        } else if(key > arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }

        mid = start + (end-start)/2;
    }

    return ans;
}

int lastPosition(int arr[], int size, int key) {
    int start = 0;
    int end = size-1;
    int mid = start + (end-start)/2;

    int ans = -1;

    while(start <= end) {
        if(arr[mid] == key) {
            ans = mid;
            start = mid + 1;
        } else if(key > arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }

        mid = start + (end-start)/2;
    }

    return ans;
}

int main() {
    int n, element;
    int arr[100];

    cout<<"Enter the size of the array : ";
    cin>>n;

    cout<<"Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"Enter the element to search for : ";
    cin>>element;
    
    int first = firstPosition(arr, n, element);
    int last = lastPosition(arr, n, element);
    int totOcc;

    if(first == -1 || last == -1) {
        totOcc = 0;
    } else {
        totOcc = last - first + 1;
    }

    cout<<"Total number of occurrences : "<<totOcc<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Peak_Index_In_Mountain_Array.cpp


```cpp

#include <iostream>
using namespace std;

int peakIndex(int arr[], int size) {
    int start = 0;
    int end = size-1;
    int mid = start + (end-start)/2;

    while(start < end) {
        if(arr[mid] < arr[mid+1]) {
            start = mid + 1;
        } else {
            end = mid;
        }

        mid = start + (end-start)/2;
    }

    return start;
}

int main() {
    int n, element;
    int arr[100];

    cout<<"Enter the size of the array : ";
    cin>>n;

    cout<<"Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    int peak = peakIndex(arr, n);

    cout<<"Peak element of the array : "<<peak;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Pivot_Element_In_An_Array.cpp


```cpp

#include <iostream>
using namespace std;

int pivotElement(int arr[], int size) {
    int sum[100] = {0};

    for(int i=0; i<size; i++) {
        sum[i+1] = sum[i] + arr[i];
    }

    for(int i=0; i<size; i++) {
        int left = sum[i];
        int right = sum[size] - sum[i+1];

        if(left == right) {
            return arr[i];
        }
    }

    return -1;
}

int main() {
    int n, element;
    int arr[100];

    cout<<"Enter the size of the array : ";
    cin>>n;

    cout<<"Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    int pivot = pivotElement(arr, n);

    cout<<"Pivot element of the array : "<<pivot;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Pivot_Element_In_Sorted_Rotated_Array.cpp


```cpp

#include <iostream>
using namespace std;

int pivotIndex(int arr[], int size) {
    int start = 0;
    int end = size-1;

    while(start < end) {
        int mid = start + (end-start)/2;

        if(arr[mid] > arr[size-1]) {
            start = mid + 1;
        } else {
            end = mid;
        }
    }

    return start;
}

int main() {
    int n;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>n;

    cout<<"Enter the elements of the array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    int pivot = pivotIndex(arr, n);

    cout<<"Pivot element = "<<arr[pivot]<<endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Search_In_Rotated_Sorted_Array.cpp


```cpp

#include <iostream>
using namespace std;

int pivotIndex(int arr[], int size) {
    int start = 0;
    int end = size-1;

    while(start < end) {
        int mid = start + (end-start)/2;

        if(arr[mid] > arr[size-1]) {
            start = mid + 1;
        } else {
            end = mid;
        }
    }

    return start;
}

int searchElement(int arr[], int start, int end, int target) {
    while(start <= end) {
        int mid = start + (end-start)/2;

        if(arr[mid] == target) {
            return mid;
        } else if(arr[mid] > target) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }

    return -1;
}

int main() {
    int n, key;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>n;

    cout<<"Enter the elements of the array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"Enter the element to search for : ";
    cin>>key;

    int pivot = pivotIndex(arr, n);
    int index;

    if(key > arr[n-1]) {
        index = searchElement(arr, 0, pivot-1, key);
    } else {
        index = searchElement(arr, pivot, n-1, key);
    }

    if(index == -1) {
        cout<<"Element not found in the array!"<<endl;
    } else {
        cout<<"Element found in the array at index : "<<index<<endl;
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Square_Root_Using_Binary_Search.cpp


```cpp

#include <iostream>
using namespace std;

int sqrt(int n) {
    int start = 0;
    int end = n-1;
    int ans = -1;

    while(start <= end) {
        int mid = start + (end-start)/2;

        long long temp = (long long) mid * mid;

        if(temp == n) {
            return mid;
        }

        if(temp < n) {
            ans = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }
        
    }

    return ans;
}

int main() {
    int num;
    cout<<"Enter the number : ";
    cin>>num;

    int answer = sqrt(num);

    cout<<"Required square root : "<<answer<<endl;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Floating_Point_Square_Root.cpp


```cpp

#include <iostream>
using namespace std;

int sqrtInteger(int n) {
    int start = 0;
    int end = n-1;
    int ans = -1;

    while(start <= end) {
        int mid = start + (end-start)/2;

        long long temp = (long long) mid * mid;

        if(temp == n) {
            return mid;
        }

        if(temp < n) {
            ans = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }
        
    }

    return ans;
}

double sqrtPrecision(int n, int count, int prevSol) {
    double factor = 1;
    double answer = prevSol;

    for(int i=0; i<count; i++) {
        factor = factor / 10;

        double temp = answer;

        while(temp*temp < n) {
            answer = temp;
            temp += factor;
        }
    }

    return answer;
}

int main() {
    int num;
    cout<<"Enter the number : ";
    cin>>num;

    int tempAnswer = sqrtInteger(num);
    double answer = sqrtPrecision(num, 3, tempAnswer);

    cout<<"Required square root : "<<answer<<endl;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Allocate_Books.cpp


```cpp

#include <iostream>
using namespace std;

/*
bool isPossibleSolution(int arr[], int n, int m, int solution) {

    int i=0;

    while(i<n && m!=0) {
        int sum = 0;

        while(i<n && sum<solution) {
            sum += arr[i++];
        }

        if(sum > solution) {
            i--;
            sum -= arr[i];
            m--;
        }
    }

    return (m) ? true : false;

}
*/

bool isPossibleSolution(int arr[], int n, int m, int solution) {

    int studentCount = 1;
    int pageSum = 0;

    for(int i=0; i<n; i++) {
        if(pageSum + arr[i] <= solution) {
            pageSum += arr[i];
        } else {
            studentCount++;

            if(studentCount > m || arr[i] > solution) {
                return false;
            }

            pageSum = arr[i];
        }
    }

    return true;

}

int allocateBooks(int arr[], int n, int m) {
    int answer = -1;
    int start = 0;
    int end = 0;

    // Finding sum of elements of the array
    for(int i=0; i<n; i++) {
        end += arr[i];
    }

    while(start <= end) {
        int mid = start + (end-start)/2;

        if(isPossibleSolution(arr, n, m, mid)) {
            answer = mid;
            end = mid-1;
        } else {
            start = mid+1;
        }
    }

    return answer;
}

int main() {
    int size, stud;
    int arr[100];

    cout<<"Enter the total number of books : ";
    cin>>size;

    cout<<"Enter the array of pages : ";
    for(int i=0; i<size; i++) {
        cin>>arr[i];
    }

    cout<<"Enter the number of students : ";
    cin>>stud;

    int minMaxPage = allocateBooks(arr, size, stud);

    cout<<"Minimum of maximum alloted pages = "<<minMaxPage<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Painters_Partition.cpp


```cpp

#include <iostream>
using namespace std;

bool isPossibleSolution(int boards[], int n, int k, int solution) {

    int painterCount = 1;
    int boardSum = 0;

    for(int i=0; i<n; i++) {
        if(boardSum + boards[i] <= solution) {
            boardSum += boards[i];
        } else {
            painterCount++;

            if(painterCount > k || boards[i] > solution) {
                return false;
            }

            boardSum = boards[i];
        }
    }

    return true;

}

int paintersPartition(int boards[], int n, int k) {
    int answer = -1;
    int start = 0;
    int end = 0;

    for(int i=0; i<n; i++) {
        end += boards[i];
    }

    while(start <= end) {
        int mid = start + (end-start)/2;

        if(isPossibleSolution(boards, n, k, mid)) {
            answer = mid;
            end = mid-1;
        } else {
            start = mid+1;
        }
    }

    return answer;
}

int main() {
    int size, painters;
    int boards[100];

    cout<<"Enter the total number of boards : ";
    cin>>size;

    cout<<"Enter the length of boards : ";
    for(int i=0; i<size; i++) {
        cin>>boards[i];
    }

    cout<<"Enter the number of painters : ";
    cin>>painters;

    int solution = paintersPartition(boards, size, painters);

    cout<<"Minimum of maximum time taken = "<<solution<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Aggressive_Cows.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_EKO.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_PRATA.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Cooking_Ninjas.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Selection_Sort.cpp


```cpp

#include <iostream>
using namespace std;

void selectionSort(int arr[], int size) {
    for(int i=0; i<size-1; i++) {
        int minIndex = i;

        for(int j=i+1; j<size; j++) {
            if(arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        swap(arr[minIndex], arr[i]);
    }
}

int main() {
    int n;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>n;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    selectionSort(arr, n);

    cout<<"\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Bubble_Sort.cpp


```cpp

#include <iostream>
using namespace std;

void bubbleSort(int arr[], int size) {
    for(int i=1; i<size; i++) {

        for(int j=0; j<size-1; j++) {
            if(arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }

    }
}

int main() {
    int n;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>n;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    bubbleSort(arr, n);

    cout<<"\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Flag_Sort.cpp


```cpp

#include <iostream>
using namespace std;

void flagSort(int arr[], int size) {
    for(int i=1; i<size; i++) {
        bool flag = false;

        for(int j=0; j<size-1; j++) {
            if(arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
                flag = true;
            }
        }

        if(!flag) {
            return;
        }

    }
}

int main() {
    int n;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>n;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    flagSort(arr, n);

    cout<<"\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Insertion_Sort.cpp


```cpp

#include <iostream>
using namespace std;

void insertionSort(int arr[], int size) {
    for(int i=1; i<size; i++) {
        int temp = arr[i];
        int j;

        for(j=i-1; j>=0; j--) {
            if(arr[j] > temp) {
                arr[j+1] = arr[j];
            } else {
                break;
            }
        }

        arr[j+1] = temp;
    }
}

int main() {
    int n;
    int arr[100];

    cout<<"Enter the size of array : ";
    cin>>n;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin>>arr[i];
    }

    cout<<"\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    insertionSort(arr, n);

    cout<<"\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout<<arr[i]<<" ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Array.cpp


```cpp

#include <iostream>
#include <array>
using namespace std;

int main() {
    int basic[3] = {1, 2, 3};

    array<int, 4> a = {1, 2, 3, 4};

    int size = a.size();

    for(int i=0; i<size; i++) {
        cout<<a[i]<<" ";
    }
    cout<<endl;

    cout<<"Size of array = "<<a.size()<<endl;

    cout<<"Element at second index = "<<a.at(2)<<endl;

    cout<<"Empty or not = "<<a.empty()<<endl;

    cout<<"First element = "<<a.front()<<endl;
    cout<<"Last element = "<<a.back()<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Vector.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

int main() {
    int basic[3] = {1, 2, 3};

    vector<int> v;

    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    v.push_back(5);

    int size = v.size();

    for(int i=0; i<size; i++) {
        cout<<v[i]<<" ";
    }
    cout<<endl;

    cout<<"Size of vector = "<<v.size()<<endl;
    cout<<"Capacity of vector = "<<v.capacity()<<endl;

    cout<<"Element at second index = "<<v.at(2)<<endl;

    cout<<"Empty or not = "<<v.empty()<<endl;

    cout<<"First element = "<<v.front()<<endl;
    cout<<"Last element = "<<v.back()<<endl;


    cout<<"\nBefore pop operation : ";
    for(int i:v) {
        cout<<i<<" ";
    }

    v.pop_back();
    
    cout<<"\nAfter pop operation : ";
    for(int i:v) {
        cout<<i<<" ";
    }

    cout<<"\n\nBefore clear operation : Size = "<<v.size()<<endl;

    v.clear();

    cout<<"After clear operation : Size = "<<v.size()<<endl;

    vector<int> v1(5, 1);
    cout<<"\nPrinting new vector : ";
    for(int i:v1) {
        cout<<i<<" ";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Deque.cpp


```cpp

#include <iostream>
#include <deque>
using namespace std;

int main() {
    int basic[3] = {1, 2, 3};

    deque<int> d;

    d.push_back(1);
    d.push_back(2);

    d.push_front(3);
    d.push_front(4);

    for(int i:d) {
        cout<<i<<" ";
    }
    cout<<endl;

    // d.pop_back() ;

    // for(int i:d) {
    //     cout<<i<<" ";
    // }
    // cout<<endl;

    // d.pop_front();

    // for(int i:d) {
    //     cout<<i<<" ";
    // }
    // cout<<endl;

    cout<<"Size of deque = "<<d.size()<<endl;

    cout<<"Element at second index = "<<d.at(2)<<endl;

    cout<<"First element = "<<d.front()<<endl;
    cout<<"Last element = "<<d.back()<<endl;

    cout<<"Empty or not : "<<d.empty()<<endl;

    d.erase(d.begin(), d.begin()+1);
    
    for(int i:d) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_List.cpp


```cpp

#include <iostream>
#include <list>
using namespace std;

int main() {
    int basic[3] = {1, 2, 3};

    list<int> l;

    l.push_back(1);
    l.push_back(2);

    l.push_front(3);
    l.push_front(4);

    int size = l.size();

    for(int i:l) {
        cout<<i<<" ";
    }
    cout<<endl;

    l.erase(l.begin());

    cout<<"After erase operation : ";
    for(int i:l) {
        cout<<i<<" ";
    }
    cout<<endl;

    // l.pop_back() ;

    // for(int i:l) {
    //     cout<<i<<" ";
    // }
    // cout<<endl;

    // l.pop_front();

    // for(int i:l) {
    //     cout<<i<<" ";
    // }
    // cout<<endl;

    cout<<"Size of list = "<<l.size()<<endl;

    // Copying list content
    list<int> l1(l);

    cout<<"New list : ";
    for(int i:l1) {
        cout<<i<<" ";
    }
    cout<<endl;

    // Initialising new list
    list<int> l2(10, 20);

    cout<<"Newly initialised list : ";
    for(int i:l2) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Stack.cpp


```cpp

#include <iostream>
#include <stack>
using namespace std;

int main() {
    int basic[3] = {1, 2, 3};

    stack<string> s;

    s.push("Akash");
    s.push("Gautam");


    cout<<"First element : "<<s.top()<<endl;

    s.pop();

    cout<<"First element after pop : "<<s.top()<<endl;

    cout<<"Size of stack : "<<s.size()<<endl;
    cout<<"Empty or not : "<<s.empty()<<endl;

    return 0;
}




// Wo nahi mera, magar usse mohabbat hai to hai...
// Ye agar rashmo reewajo se bagawat hai to hai...
// Sach ko maine sach kha, jab keh diya to keh diya...
// Ab jamane ki najar me ye hamaqat hai to hai...

// Dost ban ke dushmano sa wo satata hai mujhe...
// Phir bhi us jaalim pe marna, apni fidrat hai to hai...

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Priority_Queue.cpp


```cpp

#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> q;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Set.cpp


```cpp

#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> q;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 8_Map.cpp


```cpp

#include <iostream>
#include <map>
using namespace std;

int main() {
    map<int, string> q;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 9_Algorithms.cpp


```cpp

#include <iostream>
#include <algorithm>
using namespace std;

int main() {    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Reverse_The_Array.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

void reverseArray(vector<int> &arr) {
    int start = 0;
    int end = arr.size()-1;

    while(start <= end) {
        swap(arr[start++], arr[end--]);
    }
}

int main() {
    int size;
    vector<int> arr;

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin>>temp;
        arr.push_back (temp);
    }

    cout<<"Before reverse operation : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    reverseArray(arr);
    
    cout<<"After reverse operation : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Reverse_Array_From_Given_Position.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

void reverseArray(vector<int> &arr, int m) {
    int start = m+1;
    int end = arr.size()-1;

    while(start <= end) {
        swap(arr[start++], arr[end--]);
    }
}

int main() {
    int size, m;
    vector<int> arr;

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin>>temp;
        arr.push_back (temp);
    }

    cout<<"Enter the target index : ";
    cin>>m;

    cout<<"Before reverse operation : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    reverseArray(arr, m);
    
    cout<<"After reverse operation : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Merge_Sorted_Array.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

vector<int> mergeSortedArrays(vector<int> arr1, vector<int> arr2) {
    vector<int> ans;

    int i=0, j=0;
    int size1 = arr1.size();
    int size2 = arr2.size();

    while(i < size1 && j < size2) {
        while(i < size1 && j < size2 && arr1[i] < arr2[j]) {
            ans.push_back (arr1[i++]);
        }

        while(i < size1 && j < size2 && arr1[i] > arr2[j]) {
            ans.push_back (arr2[j++]);
        }

        while(i < size1 && j < size2 && arr1[i] == arr2[j]) {
            ans.push_back (arr2[i++]);
            ans.push_back (arr2[j++]);
        }
    }

    while(i < size1) {
        ans.push_back (arr1[i++]);
    }

    while(j < size2) {
        ans.push_back (arr1[i++]);
    }

    return ans;
}

int main() {
    int size1, size2;
    vector<int> arr1;
    vector<int> arr2;

    cout<<"Enter the size of first array : ";
    cin>>size1;

    cout<<"Enter the elements of first array : ";
    for(int i=0; i<size1; i++) {
        int temp;
        cin>>temp;
        arr1.push_back (temp);
    }

    cout<<"Enter the size of second array : ";
    cin>>size2;

    cout<<"Enter the elements of second array : ";
    for(int i=0; i<size2; i++) {
        int temp;
        cin>>temp;
        arr2.push_back (temp);
    }

    vector<int> mergedArray = mergeSortedArrays(arr1, arr2);
    
    cout<<"Merged Array : ";
    for(int i:mergedArray) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

/*

Ek bholi bhali pyari, mastani si ladki hai...
Kuchh pagal si, kuchh deewani si ladki hai...
Jiske har ek kirdaar me dil dubna chahe...
Wo kuchh aisi ankahi kahani si ladki hai...

Bhatak gya tha anant andhere galiyon me main...
Us andhere ko roshan kiya ek parwaani se ladki hai...

Kon kehta hai dharti pe bhagwan nahi milte...
Meri najro me samai wo ek ruhani se ladki hai...

Jiske najro ki gehrai me guftgu krta hai ye dil...
Mujhe smbhalti wo pawan ganga ki pani si ladki hai...

In chand labjo me kaise btau main roop uska...
Mai usme doob gya, wo kisi sagar ke jawani si ladki hai...







*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Move_Zeroes.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

void moveZeroes(vector<int> &arr) {
    for(int i=0, zero=0; i<arr.size(); i++) {
        if(arr[i] != 0) {
            swap(arr[i], arr[zero]);
            zero++;
        }
    }
}

int main() {
    int size;
    vector<int> arr;

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin>>temp;
        arr.push_back (temp);
    }

    cout<<"Before shifting zeroes : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    moveZeroes(arr);
    
    cout<<"After shifting zeroes : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Rotate_Array.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

void rotateArray(vector<int> &arr, int k) {
    vector<int> temp(arr);

    for(int i=0; i<temp.size(); i++) {
        int target = (i+k) % arr.size();
        temp[target] = arr[i];
    }

    arr = temp;
}

int main() {
    int size, k;
    vector<int> arr;

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin>>temp;
        arr.push_back (temp);
    }

    cout<<"Enter the target index : ";
    cin>>k;

    cout<<"Before rotate : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    rotateArray(arr, k);
    
    cout<<"After rotate : ";
    for(int i:arr) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Check_Sorted_Rotated.cpp


```cpp

#include <iostream>
#include <vector>
using namespace std;

bool checkSortedRotated(vector<int> arr) {
    int count = 0;

    for(int i=0; i<arr.size()-1; i++) {
        if(arr[i] > arr[i+1]) {
            count++;
        }
    }

    if(arr[arr.size()-1] > arr[0]) {
        count++;
    }

    return (count == 1) ? true : false;
}

int main() {
    int size, k;
    vector<int> arr;

    cout<<"Enter the size of array : ";
    cin>>size;

    cout<<"Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin>>temp;
        arr.push_back (temp);
    }

    if(checkSortedRotated(arr)) {
        cout<<"Entered array is a sorted and rotated array!"<<endl;
    } else {
        cout<<"Entered array is not a sorted and rotated array!"<<endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Sum_Of_Two_Arrays.cpp


```cpp

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> sumArray(vector<int> a1, vector<int> a2) {
    vector<int> sum;
    int n = a1.size()-1;
    int m = a2.size()-1;
    int carry = 0;

    while(n>=0 && m>=0) {
        int temp = a1[n--] + a2[m--] + carry;
        sum.push_back(temp%10);
        carry = temp/10;
    }

    while(n >= 0) {
        int temp = a1[n--] + carry;
        sum.push_back(temp%10);
        carry = temp/10;
    }

    while(m >= 0) {
        int temp = a2[m--] + carry;
        sum.push_back(temp%10);
        carry = temp/10;
    }

    if(carry) {
        sum.push_back(carry);
    }

    reverse(sum.begin(), sum.end());
    return sum;    
}

int main() {
    int size1, size2;
    vector<int> arr1;
    vector<int> arr2;

    cout<<"Enter the size of first array : ";
    cin>>size1;

    cout<<"Enter the elements of first array : ";
    for(int i=0; i<size1; i++) {
        int temp;
        cin>>temp;
        arr1.push_back (temp);
    }

    cout<<"Enter the size of second array : ";
    cin>>size2;

    cout<<"Enter the elements of second array : ";
    for(int i=0; i<size2; i++) {
        int temp;
        cin>>temp;
        arr2.push_back (temp);
    }

    vector<int> sum = sumArray(arr1, arr2);
    
    cout<<"Sum of the arrays : ";
    for(int i:sum) {
        cout<<i<<" ";
    }
    cout<<endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_Character_Array_Intro.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    char name[50];
    
    cout<<"Enter string : ";
    // cin>>name;
    getline(cin, name);

    cout<<"Entered string : "<<name<<endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Length_Of_String.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Reverse_String.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Check_Palindrome_String.cpp


```cpp

#include <iostream>
using namespace std;

int main() {
    char name[50];
    
    cout<<"Enter string : ";
    cin>>name;

    int n = 10;
    int s = 0;
    int e = n-1;

    while(s<=e) {
        if(name[s] != name[e]) {
            cout<<"NO";
            break;
        }
        s++;
        e--;
    }

    cout<<"YES";

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Check_Non-Case_Sensative_Palindrome.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

bool isSymbol(char ch) {
    if((ch>='0' && ch<='9') || (ch>='A' && ch<='Z') || (ch>='a' && ch<='z')) {
        return false;
    } else {
        return true;
    }
}

bool isPalindrome(string str) {
    int start = 0;
    int end = str.length() - 1;

    while(start < end) {
        while(start < end && isSymbol(str[start])) {
            start++;
        }

        while(start < end && isSymbol(str[end])) {
            end--;
        }

        if(tolower(str[start]) != tolower(str[end])) {
            return false;
        }

        start++;
        end--;
    }

    return true;
}

int main() {
    string str;
    
    cout<<"Enter string : ";
    cin>>str;

    if(isPalindrome(str)) {
        cout<<"Palindrome String!\n";
    } else {
        cout<<"Non-palindrome string!\n";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Valid_Palindrome.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_Reverse_Word_In_A_String.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

bool isSymbol(char ch) {
    if((ch>='0' && ch<='9') || (ch>='A' && ch<='Z') || (ch>='a' && ch<='z')) {
        return false;
    } else {
        return true;
    }
}

char getMaxOccurrence(string str) {
    int count[26] = {0};
    int maxIndex = 0;

    for(int i=0; i<str.length(); i++) {
        tolower(str[i]);
        int index = str[i] - 'a';
        count[index]++;
    }

    for(int i=0; i<26; i++) {
        if(count[i] > count[maxIndex]) {
            maxIndex = i;
        }
    }

    char answer = maxIndex + 'a';
    return answer;
}

int main() {
    string str;
    
    cout<<"Enter string : ";
    cin>>str;

    cout << "Most occurred character : " << getMaxOccurrence(str);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Get_Maximum_Occurrence_Of_Character.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

bool isSymbol(char ch) {
    if((ch>='0' && ch<='9') || (ch>='A' && ch<='Z') || (ch>='a' && ch<='z')) {
        return false;
    } else {
        return true;
    }
}

char getMaxOccurrence(string str) {
    int count[26] = {0};
    int maxIndex = 0;

    for(int i=0; i<str.length(); i++) {
        tolower(str[i]);
        int index = str[i] - 'a';
        count[index]++;
    }

    for(int i=0; i<26; i++) {
        if(count[i] > count[maxIndex]) {
            maxIndex = i;
        }
    }

    char answer = maxIndex + 'a';
    return answer;
}

int main() {
    string str;
    
    cout<<"Enter string : ";
    cin>>str;

    cout << "Most occurred character : " << getMaxOccurrence(str);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 09_Replace_Spaces.cpp


```cpp

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

string replaceSpaces(string str) {
    string ans = "";

    for(int i=0; i<str.length(); i++) {
        if(str[i] == ' '){
            ans.push_back('@');
            ans.push_back('4');
            ans.push_back('0');
        } else {
            ans.push_back(str[i]);
        }
    }

    return ans;
}

int main() {
    string str;

    cout<<"Enter the string : ";
    getline(cin, str);

    cout<<"String after replacing spaces : "<<replaceSpaces(str);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 10_Remove_All_Occurrences_Of_A_Substring.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

void removeOccurrences(string &s, string part) {

    while(s.length()!=0 && s.find(part) < s.length()) {
        s.erase(s.find(part), part.length());
    }

}

int main() {
    string str, part;

    cout<<"Enter the string : ";
    cin>>str;

    cout<<"Enter the target substring : ";
    cin>>part;

    removeOccurrences(str, part);

    cout<<"string after removeing all occurrences : "<<str;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 11_Permutation_In_String.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

bool checkInclusion(string s1, string s2) {
    int count[26] = {0};

    for(int i=0; i<s1.length(); i++) {
        int index = s1[i] - 'a';
        count[index]++;
    }
}

int main() {
    string str1, str2;

    cout<<"Enter the first string : ";
    cin>>str1;

    cout<<"Enter the second string : ";
    cin>>str2;

    if(checkInclusion(str1, str2)) {
        cout<<"Permutation is present!";
    } else {
        cout<<"Permutation is not present";
    }

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 12_Remove_All_Adjacent_Duplicates_In_String.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

string removeDuplicates(string s) {
    string::iterator it = s.begin();

    for(int i=0; i<s.length()-1; i++) {
        if(s[i] == s[i+1]) {
            s.erase(it, 2);
            i -= 2;
        }
    }
}

int main() {
    string str;

    cout<<"Enter the string : ";
    cin>>str;

    str = removeDuplicates(str);

    cout<<"String after removing all duplicates : "<<str;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 13_String_Compression.cpp


```cpp

#include <iostream>
#include <string>
using namespace std;

string stringCompression(string s) {
    string ans = "";

    for(int i=0; i<s.length(); i++) {
        int count = 0;
        char temp = s[i];

        while(i<s.length() && s[i]==temp) {
            i++;
            count++;
        }
        i--;

        ans.push_back(temp);
        if(count > 1) {
            char ch = count + '0';
            ans.push_back(ch);
        }
    }

    return ans;
}

int main() {
    string str;

    cout<<"Enter the string : ";
    getline(cin, str);

    string ans = stringCompression(str);

    cout<<"Compressed string : "<<ans;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_2D_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {


    // Create 2D-Array
    int arr[3][4];

    // Taking Input row wise
    cout << "Enter the elements : ";
    for(int row=0; row<3; row++) {
        for(int col=0; col<4; col++) {
            cin >> arr[row][col];
        }
    }

    // Printing 2D-Array
    cout << "Row-wise Elements : \n";
    for(int row=0; row<3; row++) {
        for(int col=0; col<4; col++) {
            cout << arr[row][col] << " ";
        }
        cout << endl;
    }

    // Taking Input column wise
    cout << "\nEnter the elements : ";
    for(int col=0; col<4; col++) {
        for(int row=0; row<3; row++) {
            cin >> arr[row][col];
        }
    }

    // Printing 2D-Array
    cout << "Column-wise Elements : \n";
    for(int row=0; row<3; row++) {
        for(int col=0; col<4; col++) {
            cout << arr[row][col] << " ";
        }
        cout << endl;
    }

    int arr1[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    cout << "arr1 Elements : \n";
    for(int row=0; row<3; row++) {
        for(int col=0; col<4; col++) {
            cout << arr1[row][col] << " ";
        }
        cout << endl;
    }

    int arr2[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    cout << "arr2 Elements : \n";
    for(int row=0; row<3; row++) {
        for(int col=0; col<4; col++) {
            cout << arr2[row][col] << " ";
        }
        cout << endl;
    }

    int arr3[3][4] = {0};
    cout << "arr3 Elements : \n";
    for(int row=0; row<3; row++) {
        for(int col=0; col<4; col++) {
            cout << arr3[row][col] << " ";
        }
        cout << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Searching_In_2D_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;
#define MAX 100

void input2dArray(int arr[][MAX], int row, int col) {
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cin >> arr[i][j];
        }
    }
}

bool isPresent(int arr[][MAX], int row, int col, int target) {
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {

            if(arr[i][j] == target) {
                return true;
            }
        
        }
    }

    return false;
}

int main() {
    int row, col, target;
    int arr[MAX][MAX];

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : ";
    input2dArray(arr, row, col);

    cout << "Enter the target : ";
    cin >> target;

    if(isPresent(arr, row, col, target)) {
        cout << "Element is present!" << endl;
    } else {
        cout << "Element is not present!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Row_Wise_Sum.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;
#define MAX 100

void input2dArray(int arr[][MAX], int row, int col) {
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cin >> arr[i][j];
        }
    }
}

void printRowSum(int arr[][MAX], int row, int col) {
    for(int i=0; i<row; i++) {
        int sum = 0;
        for(int j=0; j<col; j++) {
            sum += arr[i][j];
        }
        cout << "Sum of row" << i+1 << " : " << sum << endl;
    }
}

int main() {
    int row, col;
    int arr[MAX][MAX];

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : ";
    input2dArray(arr, row, col);

    printRowSum(arr, row, col);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Col_Wise_Sum.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;
#define MAX 100

void input2dArray(int arr[][MAX], int row, int col) {
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cin >> arr[i][j];
        }
    }
}

void printColSum(int arr[][MAX], int row, int col) {
    for(int i=0; i<col; i++) {
        int sum = 0;
        for(int j=0; j<row; j++) {
            sum += arr[j][i];
        }
        cout << "Sum of col" << i+1 << " : " << sum << endl;
    }
}

int main() {
    int row, col;
    int arr[MAX][MAX];

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : ";
    input2dArray(arr, row, col);

    printColSum(arr, row, col);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Largest_Row_Sum.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;
#define MAX 100

void input2dArray(int arr[][MAX], int row, int col) {
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cin >> arr[i][j];
        }
    }
}

int largestRowSum(int arr[][MAX], int row, int col) {
    int maxSum = INT_MIN;

    for(int i=0; i<row; i++) {
        int sum = 0;
        for(int j=0; j<col; j++) {
            sum += arr[i][j];
        }
        
        if(sum > maxSum) {
            maxSum = sum;
        }
    }

    return maxSum;
}

int main() {
    int row, col;
    int arr[MAX][MAX];

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : ";
    input2dArray(arr, row, col);

    cout << "Largest row sum : " << largestRowSum(arr, row, col) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Wave_Print.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> wavePrint(vector<vector<int>> arr) {
    int row = arr.size();
    int col = arr[0].size();
    vector<int> wave;
    
    for(int i=0; i<col; i++) {
        if(i&1) {
            for(int j=row-1; j>=0; j--) {
                wave.push_back(arr[j][i]);
            }
        } else {
            for(int j=0; j<row; j++) {
                wave.push_back(arr[j][i]);
            }
        }
    }

    return wave;
}

int main() {
    int row, col;
    vector<vector<int>> arr;

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : \n";
    for(int i=0; i<row; i++) {
        vector<int> temp;
        for(int j=0; j<col; j++) {    
            int t;
            cin >> t;
            temp.push_back(t);
        }
        arr.push_back(temp);
    }

    vector<int> wave = wavePrint(arr);

    cout << "Wave print of array : ";
    for(int i:wave) {
        cout << i << " ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_Spiral_Print.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> spiralPrint(vector<vector<int>> arr) {
    vector<int> spiral;
    int row = arr.size();
    int col = arr[0].size();
    
    int top=0, bottom=row-1, left=0, right=col-1;
    int countElements = 0;
    int totalElements = row * col;

    while(countElements < totalElements) {
        // Printing Top Row
        for(int i=left; i<=right && countElements<totalElements; i++) {
            spiral.push_back(arr[top][i]);
            countElements++;
        }
        top++;

        // Printing Right Column
        for(int i=top; i<=bottom && countElements<totalElements; i++) {
            spiral.push_back(arr[i][right]);
            countElements++;
        }
        right--;

        // Printing Bottom Row
        for(int i=right; i>=left && countElements<totalElements; i--) {
            spiral.push_back(arr[bottom][i]);
            countElements++;
        }
        bottom--;

        // Printing Left Column
        for(int i=bottom; i>=top && countElements<totalElements; i--) {
            spiral.push_back(arr[i][left]);
            countElements++;
        }
        left++;
    }

    return spiral;
}

int main() {
    int row, col;
    vector<vector<int>> arr;

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : \n";
    for(int i=0; i<row; i++) {
        vector<int> temp;
        for(int j=0; j<col; j++) {    
            int t;
            cin >> t;
            temp.push_back(t);
        }
        arr.push_back(temp);
    }

    vector<int> spiral = spiralPrint(arr);

    cout << "Spiral print of array : ";
    for(int i:spiral) {
        cout << i << " ";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Rotate_Image.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void rotateMatrix(vector<vector<int>> &arr) {
    int row = arr.size();
    int col = arr[0].size();
    vector<vector<int>> temp(arr);

    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            temp[j][col-i-1] = arr[i][j];
        }
    }

    arr = temp;
}

int main() {
    int row, col, target;
    vector<vector<int>> arr;

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : " << endl;
    for(int i=0; i<row; i++) {
        vector<int> temp;
        for(int j=0; j<col; j++) {    
            int t;
            cin >> t;
            temp.push_back(t);
        }
        arr.push_back(temp);
    }

    cout << endl << "Before Rotate : " << endl;
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    rotateMatrix(arr);

    cout << endl << "After Rotate : " << endl;
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 09_Binary_Search_In_2D_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool binarySearch(vector<vector<int>> arr, int target) {
    int row = arr.size();
    int col = arr[0].size();
    int start = 0;
    int end = (row*col) - 1;

    while(start <= end) {
        int mid = start + (end-start)/2;
        int r = mid / col;
        int c = mid % col;

        if(arr[r][c] == target) {
            return true;
        } else if(arr[r][c] > target) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }

    return false;
}

int main() {
    int row, col, target;
    vector<vector<int>> arr;

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : ";
    for(int i=0; i<row; i++) {
        vector<int> temp;
        for(int j=0; j<col; j++) {    
            int t;
            cin >> t;
            temp.push_back(t);
        }
        arr.push_back(temp);
    }

    cout << "Enter the target : ";
    cin >> target;

    if(binarySearch(arr, target)) {
        cout << "Element is present!" << endl;
    } else {
        cout << "Element is not present!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 10_Search_In_2D_Matrix_II.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool binarySearch(vector<vector<int>> arr, int target) {
    int r = 0;
    int c = arr[0].size() - 1;

    while(r<arr.size() && c>=0) {
        if(arr[r][c] == target) {
            return true;
        } else if(arr[r][c] > target) {
            c--;
        } else {
            r++;
        }
    }

    return false;
}

int main() {
    int row, col, target;
    vector<vector<int>> arr;

    cout << "Enter the number of row & col : ";
    cin >> row >> col;
    
    cout << "Enter the elements of array : ";
    for(int i=0; i<row; i++) {
        vector<int> temp;
        for(int j=0; j<col; j++) {    
            int t;
            cin >> t;
            temp.push_back(t);
        }
        arr.push_back(temp);
    }

    cout << "Enter the target : ";
    cin >> target;

    if(binarySearch(arr, target)) {
        cout << "Element is present!" << endl;
    } else {
        cout << "Element is not present!" << endl;
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Prime_Number.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isPrime(int n) {
    if(n <= 1) {
        return false;
    }

    for(int i=2; i<=n/2; i++) {
        if(n%i == 0) {
            return false;
        }
    }

    return true;
}

int main() {
    int num;

    cout << "Enter the number : ";
    cin >> num;

    if(isPrime(num)) {
        cout << "Prime!" << endl;
    } else {
        cout << "Not Prime!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Count_Prime.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

// Sieve of Eratosthenes
int countPrime(int n) {
    int count = 0;
    vector<bool> prime(n+1, true);
    prime[0] = prime[1] = false;

    for(int i=2; i<n; i++) {
        if(prime[i]) {
            count++;

            for(int j=2*i; j<n; j+=i) {
                prime[j] = false;
            }
        }
    }

    return count;
}

int main() {
    int num;

    cout << "Enter the number : ";
    cin >> num;

    cout << "Total count of prime numbers from 1 to num : " << countPrime(num) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Segmented_Sieve.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_GCD.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

// Euclid's Algorithm
// gcd(a,b) = gcd(a-b,b)
// gcd(a,b) = gcd(a%b,b)
/*
int gcd(int n1, int n2) {
    int a=n1, b=n2;
    if(n1<n2) {
        swap(a, b);
    }

    while(a && b) {
        a %= b;
        swap(a, b);
    }

    return (a) ? a : b;
}
*/

int gcd(int n1, int n2) {
    if(n1 == 0) {
        return n2;
    }

    if(n2 == 0) {
        return n1;
    }

    while(n1 != n2) {
        if(n1 > n2) {
            n1 -= n2;
        } else {
            n2 -= n1;
        }
    }

    return n1;
}

int main() {
    int num1, num2;

    cout << "Enter the numbers : ";
    cin >> num1 >> num2;

    cout << "GCD : " << gcd(num1, num2) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Modular_Exponentiation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int modularExponentiation(int x, int n, int m) {
    
}

int main() {
    int x, n;
    int m = 1e9+7;

    cout << "Enter the value of x & n : ";
    cin >> x >> n;

    cout << "x^n = " << modularExponentiation(x, n, m) << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Pigeon_Hole_Principle.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Catalon_Number.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 8_Inclusion_Exclusion_Principle.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 9_Factorial.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Pointers.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    int num = 5;

    cout << num << endl;

    // address of Operator
    cout << "Address of num : " << &num << endl;

    int *p1 = &num;
    cout << "Address stored at p1 : " << p1 << endl;
    cout << "Value at the address stored pointed by p1 : " << *p1 << endl;
    cout << "Size of p1 : " << sizeof(p1) << endl << endl;

    char ch = 'a';
    char *p2 = &ch;
    cout << "Address stored at p2 : " << p2 << endl;
    cout << "Value at the address stored pointed by p2 : " << *p2 << endl;
    cout << "Size of p2 : " << sizeof(p2) << endl << endl;

    float f = 1.3;
    float *p3 = &f;
    cout << "Address stored at p3 : " << p3 << endl;
    cout << "Value at the address stored pointed by p3 : " << *p3 << endl;
    cout << "Size of p3 : " << sizeof(p3) << endl << endl;

    double d = 5.1254;
    double *p4 = &d;
    cout << "Address stored at p4 : " << p4 << endl;
    cout << "Value at the address stored pointed by p4 : " << *p4 << endl;
    cout << "Size of p4 : " << sizeof(p4) << endl << endl;

    bool b = true;
    bool *p5 = &b;
    cout << "Address stored at p5 : " << p5 << endl;
    cout << "Value at the address stored pointed by p5 : " << *p5 << endl;
    cout << "Size of p5 : " << sizeof(p5) << endl << endl;

    // Copying a pointer
    int *p6 = p1;
    cout << "Address stored at p6 : " << p6 << endl;
    cout << "Value at the address stored pointed by p6 : " << *p6 << endl;
    cout << "Size of p6 : " << sizeof(p6) << endl; 

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Pointers_And_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    int arr[10] = {23, 122, 41, 67};

    cout << "Address of first memory block is : " << arr << endl;
    cout << "arr[0] : " << arr[0] << endl;
    cout << "Address of first memory block is : " << &arr[0] << endl;

    cout << "Step 4th : " << *arr << endl;
    cout << "Step 5th : " << *arr + 1 << endl;
    cout << "Step 6th : " << *(arr + 1) << endl;
    cout << "Step 7th : " << *(arr) + 1 << endl;
    cout << "Step 8th : " << arr[2] << endl;
    cout << "Step 9th : " << *(arr + 2) << endl;

    int i = 3;
    cout << "i[arr] = " << i[arr] << endl;

    int temp[10] = {1, 2};
    cout << "Size of temp : " << sizeof(temp) << endl;
    cout << "Size of *temp : " << sizeof(*temp) << endl;
    cout << "Size of &temp : " << sizeof(&temp) << endl;

    int *ptr1 = &temp[0];
    cout << "Size of ptr1 : " << sizeof(ptr1) << endl;
    cout << "Size of *ptr1 : " << sizeof(*ptr1) << endl;
    cout << "Size of &ptr1 : " << sizeof(&ptr1) << endl;

    int a[20] = {1, 2, 3, 5};
    cout << "&a[0] : " << &a[0] << endl;
    cout << "&a : " << &a << endl;
    cout << "a : " << a << endl;

    int *p = &a[0];
    cout << "p : " << p << endl;
    cout << "*p : " << *p << endl;
    cout << "&p : " << &p << endl;

    // ERROR
    // arr = arr+1;

    int *ptr2 = &arr[0];
    cout << "Before - ptr2 : " << ptr2 << endl;
    ptr2 = ptr2 + 1;
    cout << "After - ptr2 : " << ptr2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Pointer_With_Character_Array.cpp


```cpp

#include<iostream>
using namespace std;

int main() {

    int arr[5] = {1,2,3,4,5};
    char ch[6] = "abcde";


    cout << "arr : " << arr << endl;
    cout << "ch : " << ch << endl;
    
    char *c = &ch[0];
    // Prints entire string
    cout << c << endl;

    char temp = 'z';
    char *p = &temp;
    cout << "p : " << p << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Pointer_With_Functions.cpp


```cpp

#include<iostream>
using namespace std;

void print(int *p) {
    cout << *p << endl; 
}

void update(int *p) {
   p = p + 1;
   cout << "Inside function : "<< *p <<endl;
//    *p = *p + 1;

}

int getSum(int *arr, int n) {
    // cout << "Size : " << sizeof(arr) << endl;

    int sum = 0;
    for(int i=0; i<n; i++) {
        sum += arr[i];
    }

    return sum;
}

int main() {
    int value = 5;
    int *p = &value;

    print(p);

    cout << "Before update : " << *p << endl;
    update(p);
    cout <<"After update : " << *p << endl;

    int arr[6] = {1,2,3,4,5,8};

    cout << "Sum is " << getSum(arr+3 ,3) << endl ;  

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Double_Pointer.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 5;
    int *p1 = &n;
    int **p2 = &p1;

    cout << "n : " << n << endl;
    cout << "&n : " << &n << endl << endl;

    cout << "p1 : " << p1 << endl;
    cout << "&p1 : " << &p1 << endl;
    cout << "*p1 : " << *p1 << endl << endl;

    cout << "p2 : " << p2 << endl;
    cout << "*p2 : " << *p2 << endl;
    cout << "&p2 : " << &p2 << endl;
    cout << "**p2 : " << **p2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Double_Pointer_With_Function.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void update(int **ptr) {
    // ptr = ptr + 1;

    // *ptr = *ptr + 1;

    **ptr = **ptr + 1;
}

int main() {
    int n = 5;
    int *p1 = &n;
    int **p2 = &p1;

    cout << "Before : \n";
    cout << "n : " << n << endl;
    cout << "p1 : " << p1 << endl;
    cout << "p2 : " << p2 << endl << endl;

    update(p2);

    cout << "After : \n";
    cout << "n : " << n << endl;
    cout << "p1 : " << p1 << endl;
    cout << "p2 : " << p2 << endl << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Reference_Variable.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void update1(int j) {
    j++;
}

void update2(int &j) {
    j++;
}

int main() {
    int i = 5;

    int &j = i;

    cout << i << endl;
    update1(i);
    cout << i << endl;
    update2(i);
    cout << i << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Dynamic_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int getSum(int arr[], int n) {
    int sum = 0;

    for(int i=0; i<n; i++) {
        sum += arr[i];
    }
    
    return sum;
}

int main() {
    int n;

    cout << "Enter the value of n : ";
    cin >> n;

    // Dynamic allocation of an array
    int *arr = new int[n];

    cout << "Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    cout << "Sum of all elements : " << getSum(arr, n) << endl;

    delete []arr;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Dynamic_2D_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    int row, col;

    cout << "Enter the values of row & col : ";
    cin >> row >> col;

    // Creating a 2D Array Dynamically
    int **arr = new int *[row];
    for(int i=0; i<row; i++) {
        arr[i] = new int[col];
    }

    // Taking input in a dynamically declared 2D Array
    cout << "Enter the elements of the array : " << endl;
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cin >> arr[i][j];
        }
    }

    // Printing a dynamically declared 2D Array
    cout << "Array elements : " << endl;
    for(int i=0; i<row; i++) {
        for(int j=0; j<col; j++) {
            cout << arr[i][j] << " ";
        }

        cout << endl;
    }

    // Releasing Memory
    for(int i=0; i<row; i++) {
        delete []arr[i];
    }

    delete []arr;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Jaggered_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    int row;

    cout << "Enter the value of row : ";
    cin >> row;

    int **arr = new int *[row];

    for(int i=0; i<row; i++) {
        int col;
        cout << "Enter col : ";
        cin >> col;

        arr[i] = new int[col+1];

        for(int j=0; j<col; j++) {
            cin >> arr[i][j];
        }

        arr[i][col] = INT_MIN;
    }

    cout << "Array elements : " << endl;
    for(int i=0; i<row; i++) {
        for(int j=0; arr[i][j] != INT_MIN; j++) {
            cout << arr[i][j] << " ";
        }

        cout << endl;
    }

    // Releasing Memory
    for(int i=0; i<row; i++) {
        delete []arr[i];
    }

    delete []arr;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Macro_Introduction.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

#define PI 3.14

int main() {
    int radius = 5;
    // double PI = 3.14;

    double area = PI * radius * radius;
    cout << "Area is : " << area << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Global_Variable.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int a = 100;

void func1() {
    cout << "In func1 - a : " << a << endl;
}

void func2() {
    cout << "In func2 - a : " << a << endl;
}

int main() {
    
    cout << "In main  - a : " << a << endl;

    func1();
    func2();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Inline_Functions.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

inline int getMax(int a, int b) {return (a>b) ? a : b;}

int main() {
    int a, b;

    cout << "Enter the value of a & b : ";
    cin >> a >> b;

    cout << "Maximum number : " << getMax(a, b) << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Default_Argument.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void printArray(int arr[], int size, int start = 0) {
    for(int i = start; i<size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int arr[5] = {4, 6, 2, 6, 9};

    cout << "Array from index 1 : ";
    printArray(arr, 5, 1);

    cout << "Whole array : ";
    printArray(arr, 5);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Factorial.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int factorial(int n) {
    // Base case
    if(n == 0) {
        return 1;
    }

    return n * factorial(n-1);
}

int main() {
    int num;

    cout << "Enter the number : ";
    cin >> num;

    cout << "Factorial of " << num << " : " << factorial(num) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Power_Of_Num.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int power(int num, int pow) {
    // Base case
    if(pow == 0) {
        return 1;
    }

    return num * power(num, pow-1);
}

int main() {
    int num, pow;

    cout << "Enter the number and its power : ";
    cin >> num >> pow;

    cout << num << "^" << pow << " : " << power(num, pow) << endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Print_Counting.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void headCounting(int num) {
    // Base case
    if(num == 0) {
        return;
    }

    // Recursive relation
    headCounting(num-1);

    // Processing
    cout << num << " ";
}

void tailCounting(int num) {
    // Base case
    if(num == 0) {
        return;
    }

    // Processing
    cout << num << " ";

    // Recursive relation
    tailCounting(num-1);
}

int fib(int num) {
    if(num <= 2) {
        return num-1;
    }

    int ans = fib(num-1) + fib(num-2);
    cout << ans << " ";

    return ans;
}

int main() {
    int num;

    cout << "Enter the number : ";
    cin >> num;

    cout << "Head Counting : ";
    headCounting(num);
    cout << endl;

    cout << "Tail Counting : ";
    tailCounting(num);
    cout << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Walking_Example.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void reachHome(int src, int dest) {
    cout << "Source : " << src << " & Destination : " << dest << endl;
    
    // Base case
    if(src == dest) {
        cout << "Reached!" << endl;
        return;
    }

    // Processing
    src++;

    // Recursive call
    reachHome(src, dest);
}

int main() {
    int dest = 10;
    int src = 1;

    reachHome(src, dest);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Nth_Fibonacci_Number.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int fib(int n) {
    if(n <= 2) {
        return n-1;
    }

    return fib(n-1) + fib(n-2);
}

int main() {
    int n;

    cout << "Enter the value of n : ";
    cin >> n;

    cout << "Nth fibonacci number : " << fib(n) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Count_Ways_To_Reach_Nth_Stairs.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int distinctWays(int stairs) {
    if(stairs < 0) {
        return 0;
    }

    if(stairs == 0) {
        return 1;
    }

    return distinctWays(stairs-1) + distinctWays(stairs-2);
}

int main() {
    int stairs;

    cout << "Enter the number of stairs : ";
    cin >> stairs;

    int ways = distinctWays(stairs);

    cout << "Total number of distinct ways : " << ways << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Say_Digits.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

string names[10] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};

string sayDigits(int num) {
    if(num < 10) {
        return names[num] + " ";
    }

    string solution = sayDigits(num/10);
    solution += names[num%10];
    solution += " ";

    return solution;
}

int main() {
    int num;

    cout << "Enter the number : ";
    cin >> num;

    cout << sayDigits(num) << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_isSorted.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isSorted(int arr[], int size) {
    if(size == 1) {
        return true;
    }

    if(arr[size-1] < arr[size-2]) {
        return false;
    } else {
        return isSorted(arr, size-1);
    }
}

/*
bool isSorted(int arr[], int size) {
    if(size == 0 || size == 1) {
        return true;
    }

    if(arr[0] > arr[1]) {
        return false;
    } else {
        return isSorted(arr+1, size-1);
    }
}
*/

int main() {
    int size;
    int arr[100];

    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    if(isSorted(arr, size)) {
        cout << "Array is sorted !" << endl;
    } else {
        cout << "Array is not sorted !" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Sum_Of_Array_Elements.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int arraySum(int arr[], int size) {
    if(size == 1) {
        return arr[0];
    }

    return arr[0] + arraySum(arr+1, size-1);
}

int main() {
    int size;
    int arr[100];

    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    cout << "Sum of all elements : " << arraySum(arr, size) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Linear_Search.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool linearSearch(int arr[], int size, int key) {
    if(size == 0) {
        return false;
    }

    if(arr[0] == key) {
        return true;
    } else {
        return linearSearch(arr+1, size-1, key);
    }
}

int main() {
    int size, key;
    int arr[100];

    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    cout << "Enter th element to search for : ";
    cin >> key;

    if(linearSearch(arr, size, key)) {
        cout << "Element is present !" << endl;
    } else {
        cout << "Element is not present !" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Binary_Search.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool binarySearch(int arr[], int start, int end, int key) {
    if(start > end) {
        return false;
    }

    int mid = start + (end-start)/2;

    if(arr[mid] == key) {
        return true;
    } else if(arr[mid] > key) {
        return binarySearch(arr, start, mid-1, key);
    } else {
        return binarySearch(arr, mid+1, end, key);
    }
}

int main() {
    int size, key;
    int arr[100];

    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter the elements of array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    cout << "Enter th element to search for : ";
    cin >> key;

    if(binarySearch(arr, 0, size-1, key)) {
        cout << "Element is present !" << endl;
    } else {
        cout << "Element is not present !" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_First_And_Last_Position_Of_Element_In_Sorted_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int firstPosition(int arr[], int start, int end, int key) {
    if(start > end) {
        return -1;
    }

    int mid = start + (end-start)/2;
    int ans = -1;

    if(arr[mid] == key) {
        ans = mid;
        int temp = firstPosition(arr, start, mid-1, key);
        return (temp != -1) ? temp : ans;
    }

    if(arr[mid] > key) {
        return firstPosition(arr, start, mid-1, key);
    } else {
        return firstPosition(arr, mid+1, end, key);
    }

    return ans;
}

int lastPosition(int arr[], int start, int end, int key) {
    if(start > end) {
        return -1;
    }

    int mid = start + (end-start)/2;
    int ans = -1;

    if(arr[mid] == key) {
        ans = mid;
        int temp = lastPosition(arr, mid+1, end, key);
        return (temp != -1) ? temp : ans;
    }
    
    if(arr[mid] > key) {
        return lastPosition(arr, start, mid-1, key);
    } else {
        return lastPosition(arr, mid+1, end, key);
    }

    return ans;
}

int main() {
    int n, element;
    int arr[100];

    cout << "Enter the size of the array : ";
    cin >> n;

    cout << "Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    cout << "Enter the element to search for : ";
    cin >> element;
    
    int first = firstPosition(arr, 0, n-1, element);
    int last = lastPosition(arr, 0, n-1, element);

    cout << "First position : " << first << endl;
    cout << "Last position  : " << last << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Total_Number_Of_Occurrences_In_Sorted_Array.cpp


```cpp

#include <iostream>
using namespace std;

int firstPosition(int arr[], int start, int end, int key) {
    if(start > end) {
        return -1;
    }

    int mid = start + (end-start)/2;
    int ans = -1;

    if(arr[mid] == key) {
        ans = mid;
        int temp = firstPosition(arr, start, mid-1, key);
        return (temp != -1) ? temp : ans;
    }

    if(arr[mid] > key) {
        return firstPosition(arr, start, mid-1, key);
    } else {
        return firstPosition(arr, mid+1, end, key);
    }

    return ans;
}

int lastPosition(int arr[], int start, int end, int key) {
    if(start > end) {
        return -1;
    }

    int mid = start + (end-start)/2;
    int ans = -1;

    if(arr[mid] == key) {
        ans = mid;
        int temp = lastPosition(arr, mid+1, end, key);
        return (temp != -1) ? temp : ans;
    }
    
    if(arr[mid] > key) {
        return lastPosition(arr, start, mid-1, key);
    } else {
        return lastPosition(arr, mid+1, end, key);
    }

    return ans;
}

int main() {
    int n, element;
    int arr[100];

    cout << "Enter the size of the array : ";
    cin >> n;

    cout << "Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    cout << "Enter the element to search for : ";
    cin >> element;
    
    int first = firstPosition(arr, 0, n-1, element);
    int last = lastPosition(arr, 0, n-1, element);
    int totOcc;

    if(first == -1 || last == -1) {
        totOcc = 0;
    } else {
        totOcc = last - first + 1;
    }

    cout << "Total number of occurrences : " << totOcc << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Peak_Index_In_Mountain_Array.cpp


```cpp

#include <iostream>
using namespace std;

int peakIndex(int arr[], int start, int end) {
    if(start >= end) {
        return -1;
    }

    int mid = start + (end-start)/2;

    if(arr[mid] >= arr[mid+1]) {
        int temp = peakIndex(arr, start, mid);
        return (temp == -1) ? mid : temp;
    } else {
        return peakIndex(arr, mid+1, end);
    }
}

int main() {
    int n, element;
    int arr[100];

    cout << "Enter the size of the array : ";
    cin >> n;

    cout << "Enter the elements of tha array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    int peak = peakIndex(arr, 0, n-1);

    cout << "Peak element of the array : " << arr[peak];

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Reverse_String.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void revString(string &s, int start, int end) {
    if(start > end) {
        return;
    }

    swap(s[start], s[end]);
    revString(s, start+1, end-1);
}

int main() {
    string str;

    cout << "Enter the string : ";
    getline(cin, str);

    revString(str, 0, str.length()-1);

    cout << "Reversed string : " << str << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Check_Palindrome.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(string s, int start) {
    if(start >= s.length()/2) {
        return true;
    }

    if(s[start] != s[s.length()-start-1]) {
        return false;
    }

    isPalindrome(s, start+1);
}

int main() {
    string str;

    cout << "Enter the string : ";
    getline(cin, str);

    if(isPalindrome(str, 0)) {
        cout << "Palindrome!" << endl;
    } else {
        cout << "Not Palindrome!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Exponent.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int exponentialPower(int num, int power) {
    if(power == 0) {
        return 1;
    }

    int temp = exponentialPower(num, power/2);

    if(power&1) {
        return num * temp * temp;
    } else {
        return temp * temp;
    }
}

int main() {
    int num, power;

    cout << "Enter the number : ";
    cin >> num;
    
    cout << "Enter the power : ";
    cin >> power;

    cout << num << " ^ " << power << "  :  " << exponentialPower(num, power) << endl;
    
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Bubble_Sort.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void bubbleSort(vector<int> &arr, int size) {
    if(size <= 1) {
        return;
    }

    for(int i=0; i<size-1; i++) {
        if(arr[i] > arr[i+1]) {
            swap(arr[i], arr[i+1]);
        }
    }

    bubbleSort(arr, size-1);
}

int main() {
    int n;

    cout << "Enter the size of array : ";
    cin >> n;
    vector<int> arr(n);

    cout << "Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    cout << "\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }

    bubbleSort(arr, n);

    cout << "\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Selection_Sort.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void selectionSort(vector<int> &arr, int start) {
    if(start >= arr.size()-1) {
        return;
    }

    int minIndex = start;
    
    for(int i=start; i<arr.size(); i++) {
        if(arr[i] < arr[minIndex]) {
            minIndex = i;
        }
    }

    swap(arr[start], arr[minIndex]);

    selectionSort(arr, start+1);
}

int main() {
    int n;

    cout << "Enter the size of array : ";
    cin >> n;
    vector<int> arr(n);

    cout << "Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    cout << "\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }

    selectionSort(arr, 0);

    cout << "\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Insertion_Sort.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void insertionSort(vector<int> &arr, int limit) {
    if(limit >= arr.size()) {
        return;
    }

    int j = limit-1;
    int temp = arr[limit];

    while(j >= 0) {
        if(arr[j] > temp) {
            arr[j+1] = arr[j];
        }
        j--;
    }

    arr[j+1] = temp;

    insertionSort(arr, limit+1);
}

int main() {
    int n;

    cout << "Enter the size of array : ";
    cin >> n;
    vector<int> arr(n);

    cout << "Enter the elements of array : ";
    for(int i=0; i<n; i++) {
        cin >> arr[i];
    }

    cout << "\nArray before sorting : ";
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }

    insertionSort(arr, 1);

    cout << "\nArray after sorting : ";
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Merge_Sort.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void mergeArrays(vector<int> &arr, int start, int end) {
    int mid = start + (end-start)/2;

    vector<int> arr1(mid-start+1);
    vector<int> arr2(end-mid);

    for(int i=start, j=0; j<arr1.size(); i++, j++) {
        arr1[j] = arr[i];
    }

    for(int i=mid+1, j=0; j<arr2.size(); i++, j++) {
        arr2[j] = arr[i];
    }

    int i=0, j=0, index=start;

    while(i<arr1.size() && j<arr2.size()) {
        if(arr1[i] < arr2[j]) {
            arr[index++] = arr1[i++];
        } else {
            arr[index++] = arr2[j++];
        }
    }

    while(i<arr1.size()) {
        arr[index++] = arr1[i++];
    }

    while(j<arr2.size()) {
        arr[index++] = arr2[j++];
    }
}

void mergeSort(vector<int> &arr, int start, int end) {
    if(start >= end) {
        return;
    }
    
    int mid = start + (end-start)/2;

    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    mergeArrays(arr, start, end);
}

int main() {
    int size;
    cout << "Enter the size of the array : ";
    cin >> size;

    vector<int> arr(size);

    cout << "Enter the elements of the array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    cout << endl << "Before sorting : ";
    for(int i=0; i<size; i++) {
        cout << arr[i] << " ";
    }

    mergeSort(arr, 0, size-1);

    cout << endl << "After sorting : ";
    for(int i=0; i<size; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Count_Inversion.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Quick_Sort.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int partition(vector<int> &arr, int start, int end) {
    int pivot = arr[start];
    int lessCount = 0;

    for(int i=start+1; i<=end; i++) {
        if(arr[i] <= pivot) {
            lessCount++;
        }
    }

    int pivotIndex = start + lessCount;
    swap(arr[start], arr[pivotIndex]);

    int i = start;
    int j = end;

    while(i<pivotIndex && j>pivotIndex) {
        while(arr[i] <= pivot) {
            i++;
        }

        while(arr[j] > pivot) {
            j--;
        }

        if(i<pivotIndex && j>pivotIndex) {
            swap(arr[i++], arr[j--]);
        }
    } 

    return pivotIndex;
}

void quickSort(vector<int> &arr, int start, int end) {
    if(start >= end) {
        return;
    }

    int p = partition(arr, start, end);

    quickSort(arr, start, p-1);
    quickSort(arr, p+1, end);
}

int main() {
    int size;
    cout << "Enter the size of the array : ";
    cin >> size;

    vector<int> arr(size);

    cout << "Enter the elements of the array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    cout << endl << "Before sorting : ";
    for(int i=0; i<size; i++) {
        cout << arr[i] << " ";
    }

    quickSort(arr, 0, size-1);

    cout << endl << "After sorting : ";
    for(int i=0; i<size; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_PowerSet.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void subsets(vector<int> arr, vector< vector<int> > &solution, vector<int> output, int index) {
    if(index == arr.size()) {
        solution.push_back (output);
        return;
    }

    subsets(arr, solution, output, index+1);

    output.push_back (arr[index]);
    subsets(arr, solution, output, index+1);
}

vector< vector<int> > powerSet(vector<int> arr) {
    vector< vector<int> > solution;
    vector<int> output;
    int index = 0;

    subsets(arr, solution, output, index);

    return solution;
}

int main() {
    int size;
    cout << "Enter the size of the array : ";
    cin >> size;

    vector<int> arr(size);

    cout << "Enter the elements of the array : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }

    vector< vector<int> > answer = powerSet(arr);

    cout << "All subsets : " << endl;
    for(int i=0; i<answer.size(); i++) {
        cout << "[ ";
        for(int j=0; j<answer[i].size(); j++) {
            cout << answer[i][j] << " ";
        }
        cout << "]" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Subsequences.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void solve(string str, vector<string> &solution, string output, int index) {
    if(index == str.length()) {
        if(output.length() > 0) {
            solution.push_back(output);
        }
        return;
    }
    solve(str, solution, output, index+1);

    output.push_back(str[index]);
    solve(str, solution, output, index+1);
}

vector<string> subsequences(string str) {
    vector<string> solution;
    string output;
    int index = 0;

    solve(str, solution, output, index);

    return solution;
}

int main() {
    string str;

    cout << "Enter the string : ";
    getline(cin, str);

    vector<string> solution = subsequences(str);

    cout << "All subsequences : " << endl;
    for(int i=0; i<solution.size(); i++) {
        cout << "{ " << solution[i] << " }" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Phone_Keypad_Problem.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void phoneKeypad(string digits, vector<string> &solution, string output, string mapping[], int index) {
    if(index == digits.length()) {
        solution.push_back (output);
        return;
    }

    int number = digits[index] - '0';
    string str = mapping[number];

    for(int i=0; i<str.length(); i++) {
        output.push_back (str[i]);
        phoneKeypad(digits, solution, output, mapping, index+1);
        output.pop_back();
    }
}

vector<string> letterCombination(string digits) {
    vector<string> solution;

    if(digits.length() == 0) {
        return solution;
    }
    
    string output;
    int index = 0;
    string mapping[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    phoneKeypad(digits, solution, output, mapping, index);

    return solution;
}

int main() {
    string digits;

    cout << "Enter the digits : ";
    getline(cin, digits);

    vector<string> solution = letterCombination(digits);

    cout << "All combinations : " << endl;
    for(int i=0; i<solution.size(); i++) {
        cout << "{ " << solution[i] << " }" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Permutations_Of_String.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void solve(string str, vector<string> &solution, int index) {
    if(index == str.length()) {
        solution.push_back(str);
        return;
    }

    for(int i=index; i<str.length(); i++) {
        swap(str[i], str[index]);
        solve(str, solution, index+1);
        swap(str[i], str[index]);
    }
}

vector<string> permutations(string str) {
    vector<string> solution;
    int index = 0;

    solve(str, solution, index);
    sort(solution.begin(), solution.end());
    return solution;
}

int main() {
    string str;

    cout << "Enter the string : ";
    getline(cin, str);

    vector<string> solution = permutations(str);

    cout << "All permutations : " << endl;
    for(int i=0; i<solution.size(); i++) {
        cout << "{ " << solution[i] << " }" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Permutations.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void solve(vector<int> arr, vector< vector<int> > &solution, int index) {
    if(index == arr.size()) {
        solution.push_back(arr);
        return;
    }

    for(int i=index; i<arr.size(); i++) {
        swap(arr[i], arr[index]);
        solve(arr, solution, index+1);
        swap(arr[i], arr[index]);
    }
}

vector< vector<int> > permutations(vector<int> arr) {
    vector< vector<int> > solution;
    int index = 0;

    solve(arr, solution, index);
    sort(solution.begin(), solution.end());
    return solution;
}

int main() {
    int size;
    cout << "Enter the size : ";
    cin >> size;

    vector<int> arr(size);
    cout << "Enter the elements : ";
    for(int i=0; i<size; i++) {
        cin >> arr[i];
    }
    
    vector< vector<int> > solution = permutations(arr);
    
    cout << "All permutations : " << endl;
    for(int i=0; i<solution.size(); i++) {
        cout << "[ ";
        for(int j=0; j<solution[i].size(); j++) {
            cout << solution[i][j] << " ";
        }
        cout << "]" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Rat_In_A_Maze.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isPossible(vector< vector<int> > maze, vector< vector<int> > visited, int newx, int newy) {
    // Valid index
    if((newx>=0 && newx<maze.size()) && (newy>=0 && newy<maze.size())) {
        // Valid path
        if(maze[newx][newy] == 1 && visited[newx][newy] == 0) {
            return true;
        }
    }

    return false;
}

void findPath(vector< vector<int> > maze, vector<string> &solution, vector< vector<int> > &visited, string output, int x, int y) {
    if(x==maze.size()-1 && y==maze.size()-1) {
        solution.push_back (output);
        return;
    }
    
    visited[x][y] = 1;
    int newx, newy;

    // Up
    newx = x-1;
    newy = y;
    if(isPossible(maze, visited, newx, newy)) {
        output.push_back ('U');
        findPath(maze, solution, visited, output, newx, newy);
        output.pop_back();
    }

    // Down
    newx = x+1;
    newy = y;
    if(isPossible(maze, visited, newx, newy)) {
        output.push_back ('D');
        findPath(maze, solution, visited, output, newx, newy);
        output.pop_back();
    }
    
    // Left
    newx = x;
    newy = y-1;
    if(isPossible(maze, visited, newx, newy)) {
        output.push_back ('L');
        findPath(maze, solution, visited, output, newx, newy);
        output.pop_back();
    }
    
    // Right
    newx = x;
    newy = y+1;
    if(isPossible(maze, visited, newx, newy)) {
        output.push_back ('R');
        findPath(maze, solution, visited, output, newx, newy);
        output.pop_back();
    }

    visited[x][y] = 0;
}

int main() {
    int size;
    cout << "Enter the row & col size : ";
    cin >> size;

    vector< vector<int> > maze;
    cout << "Enter the elements of maze : ";
    for(int i=0; i<size; i++) {
        vector<int> temp(size);
        for(int j=0; j<size; j++) {
            cin >> temp[j];
        }
        maze.push_back (temp);
    }

    vector<string> solution;
    string output;

    // Creating a visited vector to keep the track of visited points
    vector< vector<int> > visited (maze);
    for(int i=0; i<size; i++) {
        for(int j=0; j<size; j++) {
            visited[i][j] = 0;
        }
    }

    findPath(maze, solution, visited, output, 0, 0);
    sort(solution.begin(), solution.end());

    cout << "All possible paths : " << endl;
    for(int i=0; i<solution.size(); i++) {
        cout << solution[i] << endl;
    }

    return 0;
}

// 1 0 0 0 1 1 0 1 1 1 0 0 0 1 1 1


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Class_Introduction.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        string name;
        int health;
        char level;
};

int main() {
    Hero h1;
    
    h1.name = "Akash Gautam";
    h1.health = 100;
    h1.level  = 'A';

    cout << "h1.name : " << h1.name << endl;
    cout << "h1.health : " << h1.health << endl;
    cout << "h1.level : " << h1.level << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Class_Dynamic_Allocation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        string name;
        int health;
        char level;
};

int main() {
    Hero *h1 = new Hero;
    
    h1->name = "Akash Gautam";
    h1->health = 100;
    h1->level  = 'A';

    cout << "h1->name : " << h1->name << endl;
    cout << "h1->health : " << h1->health << endl;
    cout << "h1->level : " << h1->level << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Constructor.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        string name;
        int health;
        char level;

        Hero() {
        }

        Hero(int health) {
            this->health = health;
        }

        Hero(int health, char level) {
            this->health = health;
            this->level = level;
        }

        Hero(int health, char level, string name) {
            this->health = health;
            this->level = level;
            this->name = name;
        }
};

int main() {
    Hero *h1 = new Hero();
    cout << "For h1 : " << endl;
    cout << "h1->health = " << h1->health << endl;
    cout << "h1->level = " << h1->level << endl;
    cout << "h1->name = " << h1->name << endl << endl;
    
    Hero *h2 = new Hero(30);
    cout << "For h2 : " << endl;
    cout << "h2->health = " << h2->health << endl;
    cout << "h2->level = " << h2->level << endl;
    cout << "h2->name = " << h2->name << endl << endl;

    Hero *h3 = new Hero(40, 'A');
    cout << "For h3 : " << endl;
    cout << "h3->health = " << h3->health << endl;
    cout << "h3->level = " << h3->level << endl;
    cout << "h3->name = " << h3->name << endl << endl;

    Hero *h4 = new Hero(50, 'B', "Akash");
    cout << "For h4 : " << endl;
    cout << "h4->health = " << h4->health << endl;
    cout << "h4->level = " << h4->level << endl;
    cout << "h4->name = " << h4->name << endl << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Copy_Constructor.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        string name;
        int health;
        char level;

        Hero() {
        }

        Hero(int health) {
            this->health = health;
        }

        Hero(int health, char level) {
            this->health = health;
            this->level = level;
        }

        Hero(int health, char level, string name) {
            this->health = health;
            this->level = level;
            this->name = name;
        }

        Hero(Hero &temp) {
            this->health = temp.health;
            this->level = temp.level;
            this->name = temp.name;
        }

        void print() {
            cout << "[Name : " << this->name << " , Health : ";
            cout << this->health << " , Level : " << this->level << "]" << endl;
        }
};

int main() {
    Hero *h1 = new Hero(80, 'A', "Akash");
    cout << "For h1 : ";
    h1->print();
    
    Hero *h2 = new Hero(*h1);
    cout << "For h2 : ";
    h2->print();

    Hero h3(*h2);
    cout << "For h3 : ";
    h3.print();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Deep_And_Shallow_Copy.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        char *name;
        int health;
        char level;

        Hero() {
        }

        Hero(int health) {
            this->health = health;
        }

        Hero(int health, char level) {
            this->health = health;
            this->level = level;
        }

        Hero(int health, char level, char *name) {
            this->health = health;
            this->level = level;
            this->name = name;
        }

        // Hero(Hero &temp) {
        //     this->health = temp.health;
        //     this->level = temp.level;
        //     this->name = temp.name;
        // }

        void print() {
            cout << "[Name : " << this->name << " , Health : ";
            cout << this->health << " , Level : " << this->level << "]" << endl;
        }
};

int main() {
    // cout << "Hello";
    Hero h1(80, 'A');
    char temp[6] = "Akash";
    strcpy(h1.name, temp);
    cout << "h1 before update : ";
    h1.print();
    
    Hero h2(h1);
    cout << "h2 before update : ";
    h2.print();
// cout << h1.name[0]
    h1.name[0] = 'B';
    
    cout << "h1 after update : ";
    h1.print();
    cout << "h2 after update : ";
    h2.print();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Destructor.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        string name;
        int health;
        char level;

        Hero() {
            cout << "\tConstructor Called !" << endl;
        }

        Hero(int health) {
            cout << "\tConstructor Called !" << endl;
            this->health = health;
        }

        Hero(int health, char level) {
            cout << "\tConstructor Called !" << endl;
            this->health = health;
            this->level = level;
        }

        Hero(int health, char level, string name) {
            cout << "\tConstructor Called !" << endl;
            this->health = health;
            this->level = level;
            this->name = name;
        }

        ~Hero() {
            cout << "\tDestructor Called !" << endl;
        }

        void print() {
            cout << "[Name : " << this->name << " , Health : ";
            cout << this->health << " , level : " << this->level;
            cout << "]" << endl;
        }
};

int main() {

    // Dynamic Allocation
    Hero *h1 = new Hero(150, 'A', "Akash");
    h1->print();
    delete h1;      // Calling destructor manually

    cout << endl;

    // Static Allocation
    Hero h2(250, 'G', "Gautam");
    h2.print();
    // Destructor called automatically

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Static_Keyword.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Hero {
    public:
        string name;
        int health;
        char level;

        static int time;

        Hero() {
            cout << "\tConstructor Called !" << endl;
        }

        Hero(int health) {
            cout << "\tConstructor Called !" << endl;
            this->health = health;
        }

        Hero(int health, char level) {
            cout << "\tConstructor Called !" << endl;
            this->health = health;
            this->level = level;
        }

        Hero(int health, char level, string name) {
            cout << "\tConstructor Called !" << endl;
            this->health = health;
            this->level = level;
            this->name = name;
        }

        ~Hero() {
            cout << "\tDestructor Called !" << endl;
        }

        void print() {
            cout << "[Name : " << this->name << " , Health : ";
            cout << this->health << " , level : " << this->level;
            cout << "]" << endl;
        }

        static int random() {
            return time;
        }
};

int Hero::time = 10;

int main() {

    cout << "Hero::time -> " << Hero::time << endl;

    cout << "Hero::random() -> " << Hero::random() << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_Inheritance.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Human {
    public:
    int height;
    int weight;
    int age;
};

class Male : public Human {

};

class Female : protected Human {

};

int main() {
    Male m;

    cout << "m.height : " << m.height << endl;
    cout << "m.weight : " << m.weight << endl;
    cout << "m.age : " << m.age << endl;

    Female f;
    // Not possible
    // cout << "f.height : " << f.height << endl;
    // cout << "f.weight : " << f.weight << endl;
    // cout << "f.age : " << f.age << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Single_Inheritance.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int base_property1;
    int base_property2;
};

class B : public A {
    public:
    int child_property1;
    int child_property2;
};

int main() {
    B b1;
    
    b1.base_property1 = 10;
    b1.base_property2 = 15;
    b1.child_property1 = 20;
    b1.child_property2 = 25;

    cout << "b1.base_property1 : " << b1.base_property1 << endl;
    cout << "b1.base_property2 : " << b1.base_property2 << endl;
    cout << "b1.child_property1 : " << b1.child_property1 << endl;
    cout << "b1.child_property2 : " << b1.child_property2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Multilevel_Inheritance.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int base_property1;
    int base_property2;
};

class B : public A {
    public:
    int child_property1;
    int child_property2;
};

class C : public B {
    public:
    int new_child_property1;
    int new_child_property2;
};

int main() {
    C c1;
    
    c1.base_property1 = 10;
    c1.base_property2 = 15;
    c1.child_property1 = 20;
    c1.child_property2 = 25;
    c1.new_child_property1 = 30;
    c1.new_child_property2 = 35;

    cout << "c1.base_property1 : " << c1.base_property1 << endl;
    cout << "c1.base_property2 : " << c1.base_property2 << endl << endl;
    cout << "c1.child_property1 : " << c1.child_property1 << endl;
    cout << "c1.child_property2 : " << c1.child_property2 << endl << endl;
    cout << "c1.new_child_property1 : " << c1.new_child_property1 << endl;
    cout << "c1.new_child_property2 : " << c1.new_child_property2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Multiple_Inheritance.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int base1_property1;
    int base1_property2;
};

class B {
    public:
    int base2_property1;
    int base2_property2;
};

class C : public A, public B {
    public:
    int child_property1;
    int child_property2;
};

int main() {
    C c1;
    
    c1.base1_property1 = 10;
    c1.base1_property2 = 15;
    c1.base2_property1 = 20;
    c1.base2_property2 = 25;
    c1.child_property1 = 30;
    c1.child_property2 = 35;

    cout << "c1.base1_property1 : " << c1.base1_property1 << endl;
    cout << "c1.base1_property2 : " << c1.base1_property2 << endl << endl;
    cout << "c1.base2_property1 : " << c1.base2_property1 << endl;
    cout << "c1.base2_property2 : " << c1.base2_property2 << endl << endl;
    cout << "c1.child_property1 : " << c1.child_property1 << endl;
    cout << "c1.child_property2 : " << c1.child_property2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Hybrid_Inheritance.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int base_property1;
    int base_property2;
};

class B : public A {
    public:
    int child1_property1;
    int child1_property2;
};

class C : public A {
    public:
    int child2_property1;
    int child2_property2;
};

class D : public B, public C {
    public:
    int new_child_property1;
    int new_child_property2;
};

int main() {
    D d1;
    
    // d1.base_property1 = 50;
    // d1.base_property2 = 55;
    d1.child1_property1 = 60;
    d1.child1_property2 = 65;
    d1.child2_property1 = 70;
    d1.child2_property2 = 75;
    d1.new_child_property1 = 80;
    d1.new_child_property2 = 85;

    // cout << "d1.base_property1 : " << d1.base_property1 << endl;
    // cout << "d1.base_property2 : " << d1.base_property2 << endl << endl;
    cout << "d1.child1_property1 : " << d1.child1_property1 << endl;
    cout << "d1.child1_property2 : " << d1.child1_property2 << endl << endl;
    cout << "d1.child2_property1 : " << d1.child2_property1 << endl;
    cout << "d1.child2_property2 : " << d1.child2_property2 << endl << endl;
    cout << "d1.new_child_property1 : " << d1.new_child_property1 << endl;
    cout << "d1.new_child_property2 : " << d1.new_child_property2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Hierarchical_Inheritance.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int base_property1;
    int base_property2;
};

class B : public A {
    public:
    int child1_property1;
    int child1_property2;
};

class C : public A {
    public:
    int child2_property1;
    int child2_property2;
};

int main() {
    B b1;
    C c1;
    
    b1.base_property1 = 50;
    b1.base_property2 = 55;
    b1.child1_property1 = 60;
    b1.child1_property2 = 65;

    c1.base_property1 = 10;
    c1.base_property2 = 15;
    c1.child2_property1 = 20;
    c1.child2_property2 = 25;

    cout << "b1.base_property1 : " << b1.base_property1 << endl;
    cout << "b1.base_property2 : " << b1.base_property2 << endl << endl;
    cout << "b1.child1_property1 : " << b1.child1_property1 << endl;
    cout << "b1.child1_property2 : " << b1.child1_property2 << endl << endl;
    
    cout << "c1.base_property1 : " << c1.base_property1 << endl;
    cout << "c1.base_property2 : " << c1.base_property2 << endl << endl;
    cout << "c1.child2_property1 : " << c1.child2_property1 << endl;
    cout << "c1.child2_property2 : " << c1.child2_property2 << endl << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_Inheritance_Ambiguity.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int base_property1;
    int base_property2;
};

class B : public A {
    public:
    int child1_property1;
    int child1_property2;
};

class C : public A {
    public:
    int child2_property1;
    int child2_property2;
};

class D : public B, public C {
    public:
    int new_child_property1;
    int new_child_property2;
};

int main() {
    D d1;
    
    d1.B::base_property1 = 50;
    d1.B::base_property2 = 55;
    d1.C::base_property1 = 60;
    d1.C::base_property2 = 65;
    d1.child1_property1 = 70;
    d1.child1_property2 = 75;
    d1.child2_property1 = 80;
    d1.child2_property2 = 85;
    d1.new_child_property1 = 90;
    d1.new_child_property2 = 95;

    cout << "d1.B::base_property1 : " << d1.B::base_property1 << endl;
    cout << "d1.B::base_property2 : " << d1.B::base_property2 << endl << endl;
    cout << "d1.C::base_property1 : " << d1.C::base_property1 << endl;
    cout << "d1.C::base_property2 : " << d1.C::base_property2 << endl << endl;
    cout << "d1.child1_propertn y1 : " << d1.child1_property1 << endl;
    cout << "d1.child1_property2 : " << d1.child1_property2 << endl << endl;
    cout << "d1.child2_property1 : " << d1.child2_property1 << endl;
    cout << "d1.child2_property2 : " << d1.child2_property2 << endl << endl;
    cout << "d1.new_child_property1 : " << d1.new_child_property1 << endl;
    cout << "d1.new_child_property2 : " << d1.new_child_property2 << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Function_Overloading.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 09_Operator_Overloading.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    int a, b;

    int add() {
        return a+b;
    }

    void operator + (A &obj) {
        int value1 = this->a;
        int value2 = obj.a;
        cout << "Output : " << value2 - value1 << endl;
    }

    void operator () () {
        cout << "Bracket is called by " << this->a << endl;
    }
};

int main() {
    A obj1, obj2;

    obj1.a = 2;
    obj2.a = 7;

    obj1 + obj2;

    obj1();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 10_Runtime_Polymorphism.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class A {
    public:
    void func() {
        cout << "Inside Parent Class" << endl;
    }
};

class B : public A {
    public:
    void func() {
        cout << "Inside Child Class" << endl;
    }
};

int main() {
    A obj1;
    B obj2;

    obj1.func();
    obj2.func();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_LL_Intro.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

int main() {
    Node head(10);

    Node head2(20);
    head.next = &head2;

    cout << head.data << " & " << head.next->data << endl;

    Node *head3 = new Node(30);
    cout << head3->data << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Singly_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }

    printList(head);

    // deletePosition(head, 6);
    // printList(head);

    deleteValue(head, 32);
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Doubly_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;
    Node* prev;

    Node(int data) {
        this->data = data;
        this->next = NULL;
        this->prev = NULL;
    }
};

void printHead(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }

    cout << "Doubly List by Head : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void printTail(Node* tail) {
    if(tail == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Doubly List by Tail : ";
    while(tail != NULL) {
        cout << tail->data << " ";
        tail = tail->prev;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head->prev = temp;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    temp->prev = tail;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    insertNode->prev = temp;
    temp->next = insertNode;

    if(insertNode->prev == tail) {
        tail = insertNode;
    } else {
        temp->next->prev = insertNode;
    }
}

void deletePosition(Node* &head, Node* &tail, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;

        if(head != NULL) {
            head->prev = NULL;
        } else {
            tail = NULL;
        }

        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;

    if(target == tail) {
        tail = tail->prev;
    } else {
        target->next->prev = temp;
    }

    delete target;
}

void deleteValue(Node* &head, Node* &tail, int val) {
    Node* temp = head;
    
    if(head->data == val) {
        head = head->next;
        delete temp;

        if(head != NULL) {
            head->prev = NULL;
        } else {
            tail = NULL;
        }

        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        temp = temp->next;
    }

    if(temp==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    temp->prev->next = temp->next;

    if(temp == tail) {
        tail = tail->prev;
    } else {
        temp->next->prev = temp->prev;
    }

    delete temp;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;


    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
        // insertAtHead(head, pow(2,i));
    }

    printHead(head);
    printTail(tail);

    // insertAtMiddle(head, tail, 99, 6);
    //deletePosition(head, tail, 8);
    deleteValue(head, tail, 64);

    printHead(head);
    printTail(tail);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Circular_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* tail) {
    if(tail == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }

    Node* temp = tail;
    cout << "Circular List : ";

    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while(temp != tail);
    
    cout << endl;
}

void insertion(Node* &tail, int data, int target) {
    Node *insertNode = new Node(data);

    if(tail == NULL) {
        tail = insertNode;
        insertNode->next = tail;
        return;
    }

    Node* curr = tail;

    while(curr->data != target) {
        curr = curr->next;
    }

    insertNode->next = curr->next;
    curr->next = insertNode;
}

void deletion(Node* &tail, int val) {
    if(tail == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }

    Node *prev = tail;
    Node *curr = tail->next;

    while(curr->data != val) {
        prev = curr;
        curr = curr->next;

        if(curr == tail && curr->data != val) {
            cout << "Element Not Found!" << endl;
            return;
        }
    }

    prev->next = curr->next;
    curr->next = NULL;

    if(curr == tail) {
        tail = prev;
    }

    delete curr;
}

int main() {
    Node *tail = NULL;

    insertion(tail, pow(2,4), 2);
    insertion(tail, pow(2,3), 16);
    insertion(tail, pow(2,5), 8);
    insertion(tail, pow(2,2), 16);

    printList(tail);

    deletion(tail, 64);
    printList(tail);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Reverse_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

void reverseLL(Node* &head) {
    Node* prev = NULL;

    while(head != NULL) {
        Node* curr = head;
        head = head->next;
        curr->next = prev;
        prev = curr;
    }

    head = prev;
}

void rec_reverseLL(Node* &head, Node* curr, Node* prev) {
    if(curr == NULL) {
        head = prev;
        return;
    }

    rec_reverseLL(head, curr->next, curr);
    curr->next = prev;
}

Node* rec_reverseLL2(Node* head) {
    if(head == NULL || head->next == NULL) {
        return head;
    }

    Node* curr = rec_reverseLL2(head->next);
    head->next->next = head;
    head->next = NULL;
    return curr;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);

    reverseLL(head);
    printList(head);

    rec_reverseLL(head, head, NULL);
    printList(head);

    head = rec_reverseLL2(head);
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Reverse_DLL.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;
    Node* prev;

    Node(int data) {
        this->data = data;
        this->next = NULL;
        this->prev = NULL;
    }
};

void printHead(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }

    cout << "Doubly List by Head : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void printTail(Node* tail) {
    if(tail == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Doubly List by Tail : ";
    while(tail != NULL) {
        cout << tail->data << " ";
        tail = tail->prev;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head->prev = temp;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    temp->prev = tail;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    insertNode->prev = temp;
    temp->next = insertNode;

    if(insertNode->prev == tail) {
        tail = insertNode;
    } else {
        temp->next->prev = insertNode;
    }
}

void deletePosition(Node* &head, Node* &tail, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;

        if(head != NULL) {
            head->prev = NULL;
        } else {
            tail = NULL;
        }

        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;

    if(target == tail) {
        tail = tail->prev;
    } else {
        target->next->prev = temp;
    }

    delete target;
}

void deleteValue(Node* &head, Node* &tail, int val) {
    Node* temp = head;
    
    if(head->data == val) {
        head = head->next;
        delete temp;

        if(head != NULL) {
            head->prev = NULL;
        } else {
            tail = NULL;
        }

        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        temp = temp->next;
    }

    if(temp==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    temp->prev->next = temp->next;

    if(temp == tail) {
        tail = tail->prev;
    } else {
        temp->next->prev = temp->prev;
    }

    delete temp;
}

void reverseDLL(Node* &head, Node* &tail) {
    Node* curr = head;

    while(curr != NULL) {
        Node* temp = curr->prev;
        curr->prev = curr->next;
        curr = curr->next;
        if(curr == NULL) {
            tail->next = temp;
        } else {
            curr->prev->next = temp;
        }
    }

    curr = head;
    head = tail;
    tail = curr;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }

    printHead(head);
    printTail(tail);

    reverseDLL(head, tail);

    printHead(head);
    printTail(tail);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_MIddle_Of_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

Node* getMiddle(Node* head) {
    if(head==NULL || head->next==NULL) {
        return head;
    }

    Node* fast = head;
    Node* slow = head;

    while(fast!=NULL && fast->next!=NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }

    return slow;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);

    Node* mid = getMiddle(head);
    cout << "Middle Node : " << mid->data << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Reverse_LL_In_K_Groups.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

Node* reverseInGroup(Node* head, int k) {
    if(head == NULL) {
        return head;
    }
    
    // STEP 1 : Reverse K Nodes
    Node* next = NULL;
    Node* curr = head;
    Node* prev = NULL;
    int count = 0;

    while(curr!=NULL && count<k) {
        next = curr->next;
        curr->next = prev;

        prev = curr;
        curr = next;

        count++;
    }

    // STEP 2 : Recursive call
    if(next != NULL) {
        head->next = reverseInGroup(next, k);
    }

    // STEP 3 : Return prev
    return prev;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);

    head = reverseInGroup(head, 2);
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Check_Circular_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

bool isCircular(Node* head) {
    if(head == NULL) {
        return true;
    }

    Node* temp = head->next;

    while(temp != head) {
        if(temp == NULL) {
            return false;
        }
        temp = temp->next;
    }

    return true;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);
    // tail->next = head;

    if(isCircular(head)) {
        cout << "Circular List!" << endl;
    } else {
        cout << "Not a Circular List!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Detect_Loop.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

bool isCyclic(Node* head) {
    if(head == NULL) {
        return false;
    }

    map<Node*, bool> visited;
    Node* temp = head;

    while(temp != NULL) {
        if(visited[temp] == true) {
            return true;
        }

        visited[temp] = true;
        temp = temp->next;
    }

    return false;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);
    // tail->next = head->next->next->next;

    if(isCyclic(head)) {
        cout << "Cycle is present!" << endl;
    } else {
        cout << "Cycle is not present!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Floyd_Cycle_Detection.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

bool floydDetectLoop(Node* head) {
    if(head == NULL) {
        return false;
    }

    Node* slow = head;
    Node* fast = head;

    while(slow != NULL && fast != NULL) {
        fast = fast->next;
        slow = slow->next;

        if(fast != NULL) {
            fast = fast->next;
        }

        if(slow == fast) {
            return true;
        }
    }

    return false;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=5; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);
    // tail->next = head->next->next->next;

    if(floydDetectLoop(head)) {
        cout << "Cycle is present!" << endl;
    } else {
        cout << "Cycle is not present!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Beginning_Of_The_Loop.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

// It is assumed that the list contains a loop
Node* beginningPoint(Node* head) {
    if(head == NULL) {
        return head;
    }

    Node* slow = head;
    Node* fast = head;

    // STEP 1 : Finding Intersection Node
    while(slow != NULL && fast != NULL) {
        fast = fast->next;
        slow = slow->next;

        if(fast != NULL) {
            fast = fast->next;
        }

        if(slow == fast) {
            break;
        }
    }

    // STEP 2 : Appointing slow to head
    slow = head;

    // STEP 3 : Again Start Traversing Pointers
    while(slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    // STEP 4 : Got the Beginning Point
    return slow;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=7; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);
    tail->next = head->next->next->next;

    Node* temp = beginningPoint(head);

    cout << "Beginning point of the loop : " << temp->data << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Remove_Loop.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

bool floydDetectLoop(Node* head) {
    if(head == NULL) {
        return false;
    }

    Node* slow = head;
    Node* fast = head;

    while(slow != NULL && fast != NULL) {
        fast = fast->next;
        slow = slow->next;

        if(fast != NULL) {
            fast = fast->next;
        }

        if(slow == fast) {
            return true;
        }
    }

    return false;
}

Node* beginningPoint(Node* head) {
    if(head == NULL) {
        return head;
    }

    Node* slow = head;
    Node* fast = head;

    while(slow != NULL && fast != NULL) {
        fast = fast->next;
        slow = slow->next;

        if(fast != NULL) {
            fast = fast->next;
        }

        if(slow == fast) {
            break;
        }
    }

    slow = head;
    while(slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    return slow;
}

void removeLoop(Node* head) {
    if(head == NULL) {
        return;
    }
    
    Node* start = beginningPoint(head);
    Node* temp = head;

    while(temp->next != start) {
        temp = temp->next;
    }

    temp->next = NULL;
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=1; i<=7; i++) {
        insertAtTail(tail, pow(2,i));
    }
    printList(head);
    tail->next = head->next->next->next;

    if(floydDetectLoop(head)) {
        cout << "Cycle is present!" << endl;
    } else {
        cout << "Cycle is not present!" << endl;
    }

    removeLoop(head);

    if(floydDetectLoop(head)) {
        cout << "Cycle is present!" << endl;
    } else {
        cout << "Cycle is not present!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Remove_Duplicates_In_Sorted_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

void removeNodes(Node* &head) {
    if(head == NULL) {
        return;
    }

    Node* temp = head;
    while(temp->next != NULL) {
        if(temp->data == temp->next->data) {
            Node* target = temp->next;
            temp->next = target->next;
            delete target;
        } else {
            temp = temp->next;
        }
    }
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    for(int i=0; i<=5; i++) {
        insertAtTail(tail, pow(2,i));

        if(i==0) {
            insertAtTail(tail, pow(2,i));
        }

        if(i==5) {
            insertAtTail(tail, pow(2,i));
            insertAtTail(tail, pow(2,i));
            insertAtTail(tail, pow(2,i));
        }
    }
    printList(head);

    removeNodes(head);
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Remove_Duplicates_In_Unsorted_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void insertAtMiddle(Node* &head, Node* &tail, int data, int pos) {
    if(pos == 1) {
        insertAtHead(head, data);
        return;
    }

    Node *temp = head;
    while(temp != NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node *insertNode = new Node(data);
    insertNode->next = temp->next;
    temp->next = insertNode;

    if(insertNode->next == NULL) {
        tail = insertNode;
    }
}

void deletePosition(Node* &head, int pos) {
    Node *temp = head;
    if(pos == 1) {
        head = head->next;
        delete temp;
        return;
    }

    while(temp!=NULL && pos>2) {
        temp = temp->next;
        pos--;
    }

    if(temp==NULL || temp->next==NULL || pos<=0) {
        cout << "Invalid Position!" << endl;
        return;
    }

    Node* target = temp->next;
    temp->next = target->next;
    delete target;
}

void deleteValue(Node* &head, int val) {
    Node* temp = head->next;
    Node* prev = head;
    
    if(head->data == val) {
        head = head->next;
        delete prev;
        return;
    }

    while(temp!=NULL) {
        if(temp->data == val) {
            val = INT_MIN;
            break;
        }

        prev = temp;
        temp = temp->next;
    }

    if(prev->next==NULL || val!=INT_MIN) {
        cout << "Value Not Found!" << endl;
        return;
    }
    
    prev->next = temp->next;
    delete temp;
}

void removeNodes1(Node* &head) {
    if(head == NULL) {
        return;
    }

    Node* curr = head;
    while(curr->next != NULL) {
        Node* prev = curr;
        Node* temp = curr->next;

        while(temp != NULL) {
            if(curr->data == temp->data) {
                Node* target = temp;
                temp = temp->next;
                prev->next = temp;
                delete target;
            } else {
                prev = temp;
                temp = temp->next;
            }
        }
        
        curr = curr->next;
    }
}


void removeNodes2(Node* &head) {
    if(head == NULL) {
        return;
    }

    map<int, bool> visited;
    Node* temp = head;
    visited[temp->data] = true;

    while(temp->next != NULL) {
        if(visited[temp->next->data] == true) {
            Node* target = temp->next;
            temp->next = target->next;
            delete target;
        } else {
            visited[temp->next->data] = true;
            temp = temp->next;
        }
    }
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    insertAtTail(tail, pow(2,2));
    insertAtTail(tail, pow(2,1));
    insertAtTail(tail, pow(2,9));
    insertAtTail(tail, pow(2,4));
    insertAtTail(tail, pow(2,7));
    insertAtTail(tail, pow(2,9));
    insertAtTail(tail, pow(2,2));
    insertAtTail(tail, pow(2,4));
    insertAtTail(tail, pow(2,0));
    insertAtTail(tail, pow(2,2));
    insertAtTail(tail, pow(2,9));
    insertAtTail(tail, pow(2,9));

    printList(head);

    removeNodes1(head);
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Split_Circular_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* tail) {
    if(tail == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }

    Node* temp = tail;
    cout << "Circular List : ";

    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while(temp != tail);
    
    cout << endl;
}

void insertion(Node* &tail, int data, int target) {
    Node *insertNode = new Node(data);

    if(tail == NULL) {
        tail = insertNode;
        insertNode->next = tail;
        return;
    }

    Node* curr = tail;

    while(curr->data != target) {
        curr = curr->next;
    }

    insertNode->next = curr->next;
    curr->next = insertNode;
}

void deletion(Node* &tail, int val) {
    if(tail == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }

    Node *prev = tail;
    Node *curr = tail->next;

    while(curr->data != val) {
        prev = curr;
        curr = curr->next;

        if(curr == tail && curr->data != val) {
            cout << "Element Not Found!" << endl;
            return;
        }
    }

    prev->next = curr->next;
    curr->next = NULL;

    if(curr == tail) {
        tail = prev;
    }

    delete curr;
}

int getLength(Node* tail) {
    if(tail == NULL) {
        return 0;
    }

    int count = 1;
    Node* temp = tail->next;

    while(temp != tail) {
        count++;
        temp = temp->next;
    }

    return count;
}

pair<Node*, Node*> splitList(Node* tail) {
    Node* tail1 = tail;
    Node* tail2 = NULL;
    int len = (getLength(tail) + 1) / 2;

    Node* temp = tail;
    while(len > 1) {
        temp = temp->next;
        len--;
    }

    tail2 = temp->next;
    temp->next = tail;
    temp = tail2;

    while(temp->next != tail) {
        temp = temp->next;
    }

    temp->next = tail2;

    return {tail1, tail2};
}

int main() {
    Node *tail = NULL;

    insertion(tail, pow(2,4), 2);
    insertion(tail, pow(2,3), 16);
    insertion(tail, pow(2,5), 8);
    insertion(tail, pow(2,2), 16);
    insertion(tail, pow(2,0), 8);

    printList(tail);

    pair<Node*, Node*> solution;
    solution = splitList(tail);

    printList(solution.first);
    printList(solution.second);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Sort012_In_LL.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void Sort012(Node* &head) {
    Node* temp = head;
    int zero=0, one=0, two=0;

    while(temp != NULL) {
        switch(temp->data) {
            case 0:
                zero++;
                break;
            case 1:
                one++;
                break;
            default:
                two++;
        }

        temp = temp->next;
    }

    temp = head;

    while(zero--) {
        temp->data = 0;
        temp = temp->next;
    }

    while(one--) {
        temp->data = 1;
        temp = temp->next;
    }

    while(two--) {
        temp->data = 2;
        temp = temp->next;
    }
}

int main() {
    Node *head = new Node(1);
    Node *tail = head;

    insertAtTail(tail, 0);
    insertAtTail(tail, 2);
    insertAtTail(tail, 1);
    insertAtTail(tail, 0);
    insertAtTail(tail, 2);
    insertAtTail(tail, 2);
    insertAtTail(tail, 0);
    insertAtTail(tail, 1);
    insertAtTail(tail, 1);
    insertAtTail(tail, 1);
    insertAtTail(tail, 2);
    insertAtTail(tail, 0);

    printList(head);

    Sort012(head);
    cout << "After sorting : ";
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Sort012_In_LL_2.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

void Sort012(Node* &head) {
    Node* zeroHead = new Node(-1);
    Node* zeroTail = zeroHead;
    Node* oneHead = new Node(-1);
    Node* oneTail = oneHead;
    Node* twoHead = new Node(-1);
    Node* twoTail = twoHead;

    while(head != NULL) {
        Node* target = new Node(head->data);

        if(target->data == 0) {
            zeroTail = zeroTail->next = target;
        } else if(target->data == 1) {
            oneTail = oneTail->next = target;
        } else {
            twoTail = twoTail->next = target;
        }

        head = head->next;
    }

    if(oneHead->next == NULL) {
        zeroTail->next = twoHead->next;
    } else {
        zeroTail->next = oneHead->next;
    }
    
    oneTail->next = twoHead->next;
    head = zeroHead->next;
}

int main() {
    Node *head = new Node(0);
    Node *tail = head;

    insertAtTail(tail, 2);
    insertAtTail(tail, 0);
    insertAtTail(tail, 1);
    insertAtTail(tail, 2);
    insertAtTail(tail, 0);
    insertAtTail(tail, 0);
    insertAtTail(tail, 0);
    insertAtTail(tail, 1);
    insertAtTail(tail, 1);
    insertAtTail(tail, 2);
    insertAtTail(tail, 0);
    insertAtTail(tail, 2);

    printList(head);

    Sort012(head);
    cout << "After sorting : ";
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Merge_2_Sorted_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &tail, int data) {
    Node *temp = new Node(data);
    tail->next = temp;
    tail = temp;
}

Node* mergeList(Node* list1, Node* list2) {
    if(list1==NULL || list2==NULL) {
        return (list1 == NULL) ? list2 : list1;
    }

    Node* prev = list1;
    Node* curr = list1->next;

    while(curr!=NULL && list2!=NULL) {
        if(prev->data <= list2->data && curr->data >= list2->data) {
            prev->next = list2;
            list2 = list2->next;
            prev->next->next = curr;
            prev = prev->next;
        } else {
            prev = curr;
            curr = curr->next;
        }
    }

    if(list2 != NULL) {
        prev->next = list2;
    }

    return list1;
}

int main() {
    Node *head1 = new Node(1);
    Node *tail1 = head1;
    
    Node *head2 = new Node(0);
    Node *tail2 = head2;

    for(int i=1; i<5; i++) {
        insertAtTail(tail1, pow(2,i));
    }

    for(int i=1; i<7; i++) {
        insertAtTail(tail2, pow(3,i));
    }
    
    cout << "First List : ";
    printList(head1);

    cout << "Second List : ";
    printList(head2);

    Node* answer = NULL;

    if(head1->data < head2->data) {
        answer = mergeList(head1, head2);
    } else {
        answer = mergeList(head2, head1);
    }

    cout << "Sorted List : ";
    printList(answer);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Check_Palindrome_In_LL_App1.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

bool isPalindrome(Node* head) {
    Node* temp = head;
    vector<int> newList;

    while(temp != NULL) {
        newList.push_back (temp->data);
        temp = temp->next;
    }

    int start = 0;
    int end = newList.size() - 1;

    while(start < end) {
        if(newList[start] != newList[end]) {
            return false;
        }

        start++;
        end--;
    }

    return true;
}

int main() {
    Node *head = NULL;

    insertAtHead(head, 54);
    insertAtHead(head, 67);
    insertAtHead(head, 34);
    insertAtHead(head, 99);
    insertAtHead(head, 34);
    insertAtHead(head, 67);
    insertAtHead(head, 54);

    printList(head);

    if(isPalindrome(head)) {
        cout << "List is palindrome!" << endl;
    } else {
        cout << "List is not palindrome!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Check_Palindrome_In_LL_App2.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

bool isPalindrome(Node* head) {
    Node* copy = NULL;
    Node* temp = head;
   
    while(temp != NULL) {
        insertAtHead(copy, temp->data);
        temp = temp->next;
    }
    // No need to reverse as inserting at head position has already reversed the list.

    bool flag = true;
    temp = copy;

    while(head != NULL) {
        if(head->data != temp->data) {
            flag = false;
            break;
        }

        head = head->next;
        temp = temp->next;
    }

    while(copy != NULL) {
        Node* target = copy;
        copy = copy->next;
        delete target;
    }

    return flag;
}

int main() {
    Node *head = NULL;

    insertAtHead(head, 54);
    insertAtHead(head, 67);
    insertAtHead(head, 34);
    insertAtHead(head, 99);
    insertAtHead(head, 34);
    insertAtHead(head, 67);
    insertAtHead(head, 54);

    printList(head);

    if(isPalindrome(head)) {
        cout << "List is palindrome!" << endl;
    } else {
        cout << "List is not palindrome!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Check_Palindrome_In_LL_App3.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    cout << "Singly List : ";
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

Node* reverse(Node* head) {
    Node* curr = head;
    Node* prev = NULL;
    Node* next = NULL;

    while(curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

Node* getMiddle(Node* head) {
    Node* slow = head;
    Node* fast = head;

    while(fast!=NULL && fast->next!=NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }

    return slow;
}

bool isPalindrome(Node* head) {
    Node* middle = getMiddle(head);
    middle = middle->next;
    middle = reverse(middle);

    Node* head1 = head;
    Node* head2 = middle;

    while(head2 != NULL) {
        if(head1->data != head2->data) {
            return false;
        }

        head1 = head1->next;
        head2 = head2 ->next;
    }

    middle = reverse(middle);
    return true;
}

int main() {
    Node *head = NULL;

    insertAtHead(head, 54);
    insertAtHead(head, 67);
    insertAtHead(head, 34);
    insertAtHead(head, 99);
    insertAtHead(head, 34);
    insertAtHead(head, 67);
    insertAtHead(head, 54);

    printList(head);

    if(isPalindrome(head)) {
        cout << "List is palindrome!" << endl;
    } else {
        cout << "List is not palindrome!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Add_2_Numbers_Represented_By_LL.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

Node* reverse(Node* head) {
    Node* curr = head;
    Node* prev = NULL;
    Node* next = NULL;

    while(curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

Node* addLL(Node *head1, Node *head2) {
    head1 = reverse(head1);
    head2 = reverse(head2);

    Node* temp1 = head1;
    Node* temp2 = head2;
    Node* answer = NULL;
    int carry = 0;

    while(temp1!=NULL || temp2!=NULL || carry!=0) {
        int val1 = 0;
        if(temp1 != NULL) {
            val1 = temp1->data;
        }

        int val2 = 0;
        if(temp2 != NULL) {
            val2 = temp2->data;
        }

        int sum = val1 + val2 + carry;
        insertAtHead(answer, sum%10);
        carry = sum / 10;

        if(temp1 != NULL) {
            temp1 = temp1->next;
        }

        if(temp2 != NULL) {
            temp2 = temp2->next;
        }
    }
    
    head1 = reverse(head1);
    head2 = reverse(head2);

    return answer;
}

int main() {
    Node *head1 = NULL;
    Node *head2 = NULL;

    insertAtHead(head1, 5);
    insertAtHead(head1, 4);

    insertAtHead(head2, 5);
    insertAtHead(head2, 9);
    insertAtHead(head2, 9);

    Node *sum = addLL(head1, head2);

    cout << "List 1 : ";
    printList(head1);
    cout << "List 2 : ";
    printList(head2);
    cout << "Sum : ";
    printList(sum);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Add_1_To_A_Number_Represented_By_LL.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

Node* reverse(Node* head) {
    Node* curr = head;
    Node* prev = NULL;
    Node* next = NULL;

    while(curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

Node* addOne(Node *head) {
    head = reverse(head);
    Node* temp = head;
    Node* answer = NULL;
    int carry = 1;

    while(temp!=NULL || carry!=0) {
        int val = 0;
        if(temp != NULL) {
            val = temp->data;
        }

        int sum = val + carry;
        insertAtHead(answer, sum%10);
        carry = sum / 10;

        if(temp != NULL) {
            temp = temp->next;
        }
    }
    
    head = reverse(head);
    return answer;
}

int main() {
    Node *head = NULL;

    insertAtHead(head, 9);
    insertAtHead(head, 9);
    insertAtHead(head, 9);

    Node *sum = addOne(head);

    cout << "List : ";
    printList(head);
    cout << "Sum : ";
    printList(sum);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Clone_A_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node *next, *random;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << "[" << head->data << "," << head->random->data << "] ";
        // cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

void insertAtTail(Node* &head, Node* &tail, int data) {
    Node* temp = new Node(data);    
    
    if(tail == NULL) {
        head = tail = temp;
    } else {
        tail = tail->next = temp;
    }
}

Node* cloneList(Node* head) {
    Node* cloneHead = NULL;
    Node* cloneTail = NULL;
    Node* temp = head;
    map<Node*, Node*> mapping;

    while(temp != NULL) {
        insertAtTail(cloneHead, cloneTail, temp->data);
        mapping[temp] = cloneTail;
        temp = temp->next;
    }

    temp = head;
    Node* clone = cloneHead;

    while(clone != NULL) {
        clone->random = mapping[temp->random];
        temp = temp->next;
        clone = clone->next;
    }

    return cloneHead;
}

int main() {
    Node *head = new Node(5);;

    insertAtHead(head, 4);
    insertAtHead(head, 3);
    insertAtHead(head, 2);
    insertAtHead(head, 1);

    head->random = head->next->next;
    head->next->random = head;
    head->next->next->random = head->next->next->next->next;
    head->next->next->next->random = head->next->next;
    head->next->next->next->next->random = head->next;

    cout << "Original List : ";
    printList(head);

    Node *clone = cloneList(head);

    cout << "Clone List : ";
    printList(clone);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Clone_A_Linked_List_App2.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node *next, *random;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << "[" << head->data << "," << head->random->data << "] ";
        // cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

Node* cloneList(Node* head) {
    Node* temp = head;
    while(temp != NULL) {
        Node* next = temp->next;
        Node* cloneNode = new Node(temp->data);
        temp->next = cloneNode;
        temp = cloneNode->next = next;
    }

    Node *cloneHead = head->next;
    Node* clone = cloneHead;

    temp = head;    
    while(temp != NULL) {
        temp->next->random = temp->random->next;
        temp = temp->next->next;
    }

    temp = head;
    while(clone->next != NULL) {
        temp = temp->next = temp->next->next;
        clone = clone->next = clone->next->next;
    }
    
    temp->next = clone->next = NULL;
    return cloneHead;
}

int main() {
    Node *head = new Node(5);;

    insertAtHead(head, 4);
    insertAtHead(head, 3);
    insertAtHead(head, 2);
    insertAtHead(head, 1);

    head->random = head->next->next;
    head->next->random = head;
    head->next->next->random = head->next->next->next->next;
    head->next->next->next->random = head->next->next;
    head->next->next->next->next->random = head->next;

    cout << "Original List : ";
    printList(head);

    Node *clone = cloneList(head);

    cout << "Clone List : ";
    printList(clone);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Merge_Sort_In_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node *next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

Node* findMiddle(Node* head) {
    Node* fast = head->next;
    Node* slow = head;

    while(fast!=NULL && fast->next!=NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }

    return slow;
}

Node* mergeLL(Node* head1, Node* head2) {
    if(head1==NULL || head2==NULL) {
        return (head1==NULL) ? head2 : head1;
    }

    Node* answer = new Node(-1);
    Node* temp = answer;

    while(head1!=NULL && head2!=NULL) {
        if(head1->data < head2->data) {
            temp->next = head1;
            temp = head1;
            head1 = head1->next;
        } else {
            temp->next = head2;
            temp = head2;
            head2 = head2->next;
        }
    }

    if(head1 != NULL) {
        temp->next = head1;
    }

    if(head2 != NULL) {
        temp->next = head2;
    }

    return answer->next;
}

Node* mergeSort(Node* head) {
    if(head==NULL || head->next==NULL) {
        return head;
    }

    Node* mid = findMiddle(head);
    Node* left = head;
    Node* right = mid->next;
    mid->next = NULL;

    left = mergeSort(left);
    right = mergeSort(right);

    return mergeLL(left, right);
}

int main() {
    Node *head = new Node(5);

    insertAtHead(head, 44);
    insertAtHead(head, 32);
    insertAtHead(head, 19);
    insertAtHead(head, 76);
    insertAtHead(head, -3);
    insertAtHead(head, 0);
    insertAtHead(head, 62);

    cout << "Before sorting : ";
    printList(head);

    head = mergeSort(head);

    cout << "After sorting : ";
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Flatten_A_Linked_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node *next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

void printList(Node* head) {
    if(head == NULL) {
        cout << "List is Empty!" << endl;
        return;
    }
    
    while(head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

void insertAtHead(Node* &head, int data) {
    Node *temp = new Node(data);
    temp->next = head;
    head = temp;
}

Node* findMiddle(Node* head) {
    Node* fast = head->next;
    Node* slow = head;

    while(fast!=NULL && fast->next!=NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }

    return slow;
}

Node* mergeLL(Node* head1, Node* head2) {
    if(head1==NULL || head2==NULL) {
        return (head1==NULL) ? head2 : head1;
    }

    Node* answer = new Node(-1);
    Node* temp = answer;

    while(head1!=NULL && head2!=NULL) {
        if(head1->data < head2->data) {
            temp->next = head1;
            temp = head1;
            head1 = head1->next;
        } else {
            temp->next = head2;
            temp = head2;
            head2 = head2->next;
        }
    }

    if(head1 != NULL) {
        temp->next = head1;
    }

    if(head2 != NULL) {
        temp->next = head2;
    }

    return answer->next;
}

Node* mergeSort(Node* head) {
    if(head==NULL || head->next==NULL) {
        return head;
    }

    Node* mid = findMiddle(head);
    Node* left = head;
    Node* right = mid->next;
    mid->next = NULL;

    left = mergeSort(left);
    right = mergeSort(right);

    return mergeLL(left, right);
}

// Node* flattenList(Node* head) {
//     Node* down = head;
//     down->next = NULL;
    // Node* right = flattenList(head->right);
    // Node* ans = mergeLL(down, right);
    // return ans;
// }

int main() {
    Node *head = new Node(5);

    insertAtHead(head, 44);
    insertAtHead(head, 32);
    insertAtHead(head, 19);
    insertAtHead(head, 76);
    insertAtHead(head, -3);
    insertAtHead(head, 0);
    insertAtHead(head, 62);

    cout << "Before sorting : ";
    printList(head);

    head = mergeSort(head);

    cout << "After sorting : ";
    printList(head);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Stack_STL_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    // Creation of stack
    stack<int> s;

    // Push operation
    s.push(10);
    s.push(61);

    // Size operation
    cout << "Current size of stack : " << s.size() << endl;

    // Peek operation
    cout << "Top element : " << s.top() << endl;

    // Pop operation
    s.pop();

    cout << "Current size of stack : " << s.size() << endl;
    cout << "Top element : " << s.top() << endl;

    if(s.empty()) {
        cout << "Stack is empty!" << endl;
    } else {
        cout << "Stack is not empty!" << endl;
    }

    s.pop();
    
    if(s.empty()) {
        cout << "Stack is empty!" << endl;
    } else {
        cout << "Stack is not empty!" << endl;
    }

    cout << "Current size of stack : " << s.size() << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Stack_Array_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Stack {
    public:
    int *arr;
    int limit, maxSize;

    Stack(int maxSize) {
        this->maxSize = maxSize;
        arr = new int[maxSize];
        limit = -1;
    }

    void push(int data) {
        if(limit == maxSize-1) {
            cout << "Stack overflow!" << endl;
            return;
        }

        limit++;
        arr[limit] = data;
    }

    void pop() {
        if(limit == -1) {
            cout << "Stack underflow!" << endl;
        } else {
            limit--;
        }
    }

    bool isEmpty() {
        return (limit < 0) ? true : false;
    }

    int size() {
        return limit+1;
    }

    int top() {
        return (limit < 0) ? -1 : arr[limit];
    }
};

int main() {
    // Creation of stack
    Stack s(10);

    // Push operation
    s.push(10);
    s.push(61);

    // Size operation
    cout << "Current size of stack : " << s.size() << endl;

    // Peek operation
    cout << "Top element : " << s.top() << endl;

    // Pop operation
    s.pop();

    cout << "Current size of stack : " << s.size() << endl;
    cout << "Top element : " << s.top() << endl;

    if(s.isEmpty()) {
        cout << "Stack is empty!" << endl;
    } else {
        cout << "Stack is not empty!" << endl;
    }

    s.pop();
    
    if(s.isEmpty()) {
        cout << "Stack is empty!" << endl;
    } else {
        cout << "Stack is not empty!" << endl;
    }

    cout << "Current size of stack : " << s.size() << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Stack_Linked_List_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
    int data;
    Node *next;

    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

class Stack {
    public:
    Node* head;
    int count;

    Stack() {
        head = NULL;
        count = 0;
    }

    void push(int data) {
        Node* temp = new Node(data);
        temp->next = head;
        head = temp;
        count++;
    }

    void pop() {
        if(head == NULL) {
            cout << "Stack underflow!" << endl;
        } else {
            Node* temp = head;
            head = head->next;
            delete temp;
            count--;
        }
    }

    bool isEmpty() {
        return (head == NULL) ? true : false;
    }

    int size() {
        return count;
    }

    int top() {
        return (head == NULL) ? -1 : head->data;
    }
};

int main() {
    // Creation of stack
    Stack s;

    // Push operation
    s.push(10);
    s.push(61);

    // Size operation
    cout << "Current size of stack : " << s.size() << endl;

    // Peek operation
    cout << "Top element : " << s.top() << endl;

    // Pop operation
    s.pop();

    cout << "Current size of stack : " << s.size() << endl;
    cout << "Top element : " << s.top() << endl;

    if(s.isEmpty()) {
        cout << "Stack is empty!" << endl;
    } else {
        cout << "Stack is not empty!" << endl;
    }

    s.pop();
    
    if(s.isEmpty()) {
        cout << "Stack is empty!" << endl;
    } else {
        cout << "Stack is not empty!" << endl;
    }

    cout << "Current size of stack : " << s.size() << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Two_Stack_In_An_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class TwoStack {
    public:
    int *arr;
    int limit1, limit2, maxSize;

    TwoStack(int size) {
        maxSize = size;
        arr = new int[size];
        limit1 = -1;
        limit2 = size;
    }

    // Insertion for Stack1 : Left to Right
    void push1(int data) {
        if(limit2-limit1 > 1) {
            limit1++;
            arr[limit1] = data;
        } else {
            cout << "Stack overflow!" << endl;
        }
    }
    
    // Insertion for Stack2 : Right to Left
    void push2(int data) {
        if(limit2-limit1 > 1) {
            limit2--;
            arr[limit2] = data;
        } else {
            cout << "Stack overflow!" << endl;
        }
    }

    void pop1() {
        if(limit1 == -1) {
            cout << "Stack underflow!" << endl;
        } else {
            limit1--;
        }
    }

    void pop2() {
        if(limit2 == maxSize) {
            cout << "Stack underflow!" << endl;
        } else {
            limit2++;
        }
    }
};

int main() {
    // Creation of stack
    TwoStack s(5);

    s.push1(23);
    s.push2(65);

    s.push1(94);
    s.push1(11);
    s.push1(32);

    s.pop2();
    s.pop1();
    s.pop1();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 01_Reverse_String_Using_Stack.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    string str, answer;
    stack<char> s;

    cout << "Enter the string : ";
    getline(cin, str);

    for(int i=0; i<str.length(); i++) {
        char ch = str[i];
        s.push(ch);
    }

    while(! s.empty()) {
        char ch = s.top();
        answer.push_back(ch);
        s.pop();
    }

    cout << "Original string : ";
    cout << str;
    cout << "\nReversed string : ";
    cout << answer;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 02_Delete_Middle_Of_Stack.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void deleteMiddle(stack<int> &st, int count, int size) {
    if(count == size/2) {
        st.pop();
        return;
    }

    int top = st.top();
    st.pop();

    deleteMiddle(st, count+1, size);

    st.push(top);
}

int main() {
    stack<int> st;
    st.push(5);
    st.push(5);
    st.push(5);
    st.push(5);
    st.push(5);
    st.push(5);

    int count = 0;
    int n = st.size();

    cout << "Size of stack : " << st.size() << endl;

    deleteMiddle(st, count, n);

    cout << "Size of stack : " << st.size() << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 03_Valid_Parantheses.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool matches(char a, char b) {
    switch(a) {
        case ')':
            return (b == '(') ? true : false;
        case '}':
            return (b == '{') ? true : false;
        case ']':
            return (b == '[') ? true : false;
    }
}

bool isValid(string str) {
    stack<char> st;

    for(int i=0; i<str.length(); i++) {
        char ch = str[i];

        if(ch=='(' || ch=='{' || ch=='[') {
            st.push(ch);
        } else {
            if(!st.empty() && matches(ch, st.top())) {
                st.pop();
            } else {
                return false;
            }
        }
    }

    return (st.empty()) ? true : false;
}

int main() {
    string str;

    cout << "Enter the expression : ";
    getline(cin, str);

    if(isValid(str)) {
        cout << "Balanced" << endl;
    } else {
        cout << "Not Balanced" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 04_Insert_An_Element_At_Bottom_Of_Stack.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void inputStack(stack<int> &st) {
    int size;
    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter stack elements : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin >> temp;
        st.push(temp);
    }
}

void printStack(stack<int> st) {
    cout << "Stack : ";
    while(!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }
    cout << endl;
}

void insertBottom(stack<int> &st, int data) {
    if(st.empty()) {
        st.push(data);
        return;
    }

    int top = st.top();
    st.pop();
    insertBottom(st, data);
    st.push(top);
}

int main() {
    stack<int> st;
    inputStack(st);

    printStack(st);

    insertBottom(st, 10);

    printStack(st);
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 05_Reverse_Stack_Using_Recursion.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void inputStack(stack<int> &st) {
    int size;
    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter stack elements : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin >> temp;
        st.push(temp);
    }
}

void printStack(stack<int> st) {
    cout << "Stack : ";
    while(!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }
    cout << endl;
}

void insertBottom(stack<int> &st, int data) {
    if(st.empty()) {
        st.push(data);
        return;
    }

    int top = st.top();
    st.pop();
    insertBottom(st, data);
    st.push(top);
}

void reverseStack(stack<int> &st) {
    if(st.empty()) {
        return;
    }

    int top = st.top();
    st.pop();

    reverseStack(st);
    insertBottom(st, top);
}

int main() {
    stack<int> st;
    inputStack(st);

    cout << "Before Reverse : ";
    printStack(st);

    reverseStack(st);

    cout << "After Reverse : ";
    printStack(st);
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 06_Sort_Stack.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void inputStack(stack<int> &st) {
    int size;
    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter stack elements : ";
    for(int i=0; i<size; i++) {
        int temp;
        cin >> temp;
        st.push(temp);
    }
}

void printStack(stack<int> st) {
    cout << "Stack : ";
    while(!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }
    cout << endl;
}

void insertSorted(stack<int> &st, int data) {
    if(st.empty() || (!st.empty() && st.top() <= data)) {
        st.push(data);
        return;
    }

    int top = st.top();
    st.pop();

    insertSorted(st, data);
    st.push(top);
}

void sortStack(stack<int> &st) {
    if(st.empty()) {
        return;
    }

    int top = st.top();
    st.pop();

    sortStack(st);
    insertSorted(st, top);
}

int main() {
    stack<int> st;
    inputStack(st);

    cout << "Before Sorting : ";
    printStack(st);

    sortStack(st);

    cout << "After Sorting : ";
    printStack(st);
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 07_Redundant_Brackets.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool redundantBracket(string str) {
    stack<char> st;

    for(int i=0; i<str.length(); i++) {
        bool redundancy = true;
        char ch = str[i];

        if(ch=='(' || ch=='+' || ch=='-' || ch=='-' || ch=='/') {
            st.push(ch);
        } else {

            if(ch == ')') {

                while(st.top() != '(') {
                    char top = st.top();
                    if(top=='+' || top=='-' || top=='-' || top=='/') {
                        redundancy = false;
                    }
                    st.pop();
                }
                
                if(redundancy == true) {
                    return false;
                }

                st.pop();
            }

        } 
    }

    return true;
}

int main() {
    string str;
    stack<char> st;
    
    cout << "Enter the expression : ";
    getline(cin, str);

    if(redundantBracket(str)) {
        cout << "TRUE" << endl;
    } else {
        cout << "FALSE" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 08_Minimum_Cost_To_Make_String_Valid.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int minimumCost(string str) {
    
}

int main() {
    string str;
    cout << "Enter the string : ";
    getline(cin, str);

    cout << "Required mimnimum cost : " << minimumCost(str) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Next_Smaller_Element.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> smallerElements(vector<int> arr, int n) {
    stack<int> st;
    st.push(-1);
    vector<int> answer(arr);

    for(int i=n-1; i>=0; i--) {
        while(st.top() >= arr[i]) {
            st.pop();
        }

        answer[i] = st.top();
        st.push(arr[i]);
    }

    return answer;
}

int main() {
    vector<int> arr = {2,3,1};
    vector<int> ans = smallerElements(arr, arr.size());

    cout << "Original array : ";
    for(int i=0; i<arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    cout << "Smaller array : ";
    for(int i=0; i<arr.size(); i++) {
        cout << ans[i] << " ";
    }
    cout << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Previous_Smaller_Element.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> smallerElements(vector<int> arr, int n) {
    stack<int> st;
    st.push(-1);
    vector<int> answer(arr);

    for(int i=n-1; i>=0; i--) {
        while(st.top() >= arr[i]) {
            st.pop();
        }

        answer[i] = st.top();
        st.push(arr[i]);
    }

    return answer;
}

int main() {
    vector<int> arr = {2,3,1};
    vector<int> ans = smallerElements(arr, arr.size());

    cout << "Original array : ";
    for(int i=0; i<arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    cout << "Smaller array : ";
    for(int i=0; i<arr.size(); i++) {
        cout << ans[i] << " ";
    }
    cout << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Largest_Rectangle_In_Histogram.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> nextSmallerElement(vector<int> arr) {
    vector<int> solution(arr);
    stack<int> st;
    st.push(-1);

    for(int i=arr.size()-1; i>=0; i--) {
        int curr = arr[i];
        while(st.top() != -1 && arr[st.top()] >= curr) {
            st.pop();
        }

        solution[i] = st.top();
        st.push(i);
    }

    return solution;
}

vector<int> previousSmallerElement(vector<int> arr) {
    vector<int> solution(arr);
    stack<int> st;
    st.push(-1);

    for(int i=0; i<arr.size(); i++) {
        int curr = arr[i];
        while(st.top() != -1 && arr[st.top()] >= curr) {
            st.pop();
        }

        solution[i] = st.top();
        st.push(i);
    }

    return solution;
}

int largestRectangularArea(vector<int> height) {
    int n = height.size();
    int maxArea = 0;
    vector<int> next = nextSmallerElement(height);
    vector<int> prev = previousSmallerElement(height);

    for(int i=0; i<n; i++) {
        if(next[i] == -1) {
            next[i] = n;
        }

        int length = height[i];
        int breadth = next[i] - prev[i] - 1; 

        int newArea = length * breadth;
        maxArea = max(newArea, maxArea);
    }

    return maxArea;
}

int main() {
    vector<int> height = {2, 1, 5, 6, 2, 3};

    cout << "Required area : " << largestRectangularArea(height) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Celebrity_Problem.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int findCelebrity(vector<vector<int>> matrix) {
    stack<int> st;
    int size = matrix.size();

    // Step 1 :
    for(int i=0; i<size; i++) {
        st.push(i);
    }

    // Step 2 :
    while(st.size() != 1) {
        int first = st.top();
        st.pop();
        int second = st.top();
        st.pop();
        
        // Step 3 :
        if(matrix[first][second] == 1) {
            st.push(second);
        } else {
            st.push(first);
        }
    }

    // Step 5 : Verifing potential celebrity
    int candidate = st.top();

    for(int i=0; i<size; i++) {
        if(matrix[candidate][i] != 0) {
            return -1;
        }

        if(matrix[i][candidate] != 1 && candidate != i) {
            return -1;
        }
    }

    return candidate;
}

int main() {
    vector<vector<int>> matrix;
    int size;

    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter the matrix : ";
    for(int i=0; i<size; i++) {
        vector<int> temp(size);
        for(int i=0; i<size; i++) {
            cin >> temp[i];
        }
        matrix.push_back(temp);
    }

    int celeb = findCelebrity(matrix);
    cout << "Celebrity element : " << celeb << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Max_Rectangle_In_Binary_Matrix_With_All_1s.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> nextSmallerElement(vector<int> arr) {
    vector<int> solution(arr);
    stack<int> st;
    st.push(-1);

    for(int i=arr.size()-1; i>=0; i--) {
        int curr = arr[i];
        while(st.top() != -1 && arr[st.top()] >= curr) {
            st.pop();
        }

        solution[i] = st.top();
        st.push(i);
    }

    return solution;
}

vector<int> previousSmallerElement(vector<int> arr) {
    vector<int> solution(arr);
    stack<int> st;
    st.push(-1);

    for(int i=0; i<arr.size(); i++) {
        int curr = arr[i];
        while(st.top() != -1 && arr[st.top()] >= curr) {
            st.pop();
        }

        solution[i] = st.top();
        st.push(i);
    }

    return solution;
}

int largestRectangularArea(vector<int> height) {
    int n = height.size();
    int maxArea = 0;
    vector<int> next = nextSmallerElement(height);
    vector<int> prev = previousSmallerElement(height);

    for(int i=0; i<n; i++) {
        if(next[i] == -1) {
            next[i] = n;
        }

        int length = height[i];
        int breadth = next[i] - prev[i] - 1; 

        int newArea = length * breadth;
        maxArea = max(newArea, maxArea);
    }

    return maxArea;
}

int maxArea(vector<vector<int>> matrix) {
    int area = largestRectangularArea(matrix[0]);
    int n = matrix.size();
    int m = matrix[0].size();

    for(int i=1; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(matrix[i][j] != 0) {
                matrix[i][j] += matrix[i-1][j];
            } else {
                matrix[i][j] = 0;
            }
        }

        int currArea = largestRectangularArea(matrix[i]);
        area = max(area, currArea);
    }

    return area;
}

int main() {
    vector<vector<int>> matrix;
    int size;

    cout << "Enter the size : ";
    cin >> size;

    cout << "Enter the matrix : ";
    // 0 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0
    for(int i=0; i<size; i++) {
        vector<int> temp(size);
        for(int j=0; j<size; j++) {
            cin >> temp[j];
        }
        matrix.push_back(temp);
    }

    cout << "Maximum area : " << maxArea(matrix) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_N_Stacks_In_An_Array.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;
// N - No of stack
// S - Size of array
// Q - No of queries
class NStack {
    int *arr, *top, *next;
    int freeSpot;

    public:
    NStack(int N, int S) {
        arr = new int[S];
        top = new int[N];
        next = new int[S];

        // Initialising top
        for(int i=0; i<N; i++) {
            top[i] = -1;
        }

        // Initialising next
        for(int i=0; i<S-1; i++) {
            next[i] = i+1;
        }
        next[S-1] = -1;     // Last index of next

        // Initialising freeSpot
        freeSpot = 0;
    }

    bool push(int X, int M) {
        // Check Overflow
        if(freeSpot == -1) {
            return false;
        }

        // Step 1 : Find Index
        int index = freeSpot;

        // Step 2 : Update Freespot
        freeSpot = next[index];

        // Step 3 : Insert in Array
        arr[index] = X;
   
        // Step 4 : Update Next
        next[index] = top[M-1];

        // Step 5 : Update Top
        top[M-1] = index;

        return true;
    }

    int pop(int M)  {
        // Check Overflow
        if(top[M-1] == -1) {
            return -1;
        }

        // Step 1 : Find Index
        int index = top[M-1];

        // Step 2 : Update Top
        top[M-1] = next[index];

        // Step 3 : Update Next
        next[index] = freeSpot;

        // Step 4 : Update Freespot
        freeSpot = index;

        return arr[index];
    }
};

int main() {
    NStack nst(3, 6);

    if(nst.push(10, 1)) cout << "TRUE\n"; else cout << "FALSE\n";
    if(nst.push(20, 1)) cout << "TRUE\n"; else cout << "FALSE\n";
    if(nst.push(30, 2)) cout << "TRUE\n"; else cout << "FALSE\n";
    
    cout << "Popped : " << nst.pop(1) << endl;
    cout << "Popped : " << nst.pop(2) << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_getMin_In_O(1)_TC.cpp


```cpp

// Design a special stack with getMin() method which works in O(1) time 
    // and O(1) pace complexity!

#include <bits/stdc++.h>
using namespace std;

class SpecialStack {
    stack<int> st;
    int minE;

    public:
    void push(int data) {
        if(st.empty()) {
            st.push(data);
            minE = data;
        } else {

            if(data < minE) {
                st.push(2*data - minE);
                minE = data;
            } else {
                st.push(data);
            }

        }
    }

    int pop() {
        if(st.empty()) {
            return -1;
        } else {
            int curr = st.top();
            st.pop();

            if(curr > minE) {
                return curr;
            } else {
                int prevMin = minE;
                minE = 2*minE - curr;
                return prevMin;
            }

        }
    }

    int top() {
        if(st.empty()) {
            return -1;
        } else {
            return (st.top() > minE) ? st.top() : minE;
        }
    }

    bool isEmpty() {
        return st.empty();
    }

    int getMin() {
        return (st.empty()) ? -1 : minE;
    }
};

int main() {
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Queue_STL_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {

    queue<int> q;
    q.push(11);

    cout << "Front element of q : " << q.front() << endl;
    cout << "Back element of q : " << q.back() << endl;
    q.push(15);
    cout << "Front element of q : " << q.front() << endl;
    cout << "Back element of q : " << q.back() << endl;

    q.push(23);
    q.push(30);

    cout << "Size of queue : " << q.size() << endl;

    cout << endl << "Front before pop : " << q.front() << endl;
    cout << "Back before pop : " << q.back() << endl;
    q.pop();    
    cout << "Front after pop : " << q.front() << endl;
    cout << "Back after pop : " << q.back() << endl << endl;

    q.pop();
    q.pop();

    cout << "Size of queue : " << q.size() << endl;

    q.pop();

    if(q.empty()) {
        cout << "Queue is empty!" << endl;
    } else {
        cout << "Queue is not empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Queue_Array_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Queue {
    int *arr;
    int size, front, rear;

    public:
    Queue(int S) {
        size = S;
        arr = new int[size];
        front = rear = 0;
    }

    void push(int val) {
        if(rear == size-1) {
            cout << "Queue overflow!" << endl;
        } else {
            arr[rear++] = val;
        }
    }

    void pop() {
        if(front == rear) {
            cout << "Queue underflow!" << endl;
        } else {
            front++;

            if(front == rear) {
                front = rear = 0;
            }
        }
    }

    int frontElement() {
        return (front==rear) ? -1 : arr[front];
    }

    int backElement() {
        return (front==rear) ? -1 : arr[rear-1];
    }

    int queueSize() {
        return (front==rear) ? 0 : (rear-front);
    }

    bool empty() {
        return (front==rear) ? true : false;
    }
};

int main() {
    Queue q(10);
    q.push(11);

    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;
    q.push(15);
    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;

    q.push(23);
    q.push(30);

    cout << "Size of queue : " << q.queueSize() << endl;

    cout << endl << "Front before pop : " << q.frontElement() << endl;
    cout << "Back before pop : " << q.backElement() << endl;
    q.pop();    
    cout << "Front after pop : " << q.frontElement() << endl;
    cout << "Back after pop : " << q.backElement() << endl << endl;

    q.pop();
    q.pop();

    cout << "Size of queue : " << q.queueSize() << endl;

    q.pop();

    if(q.empty()) {
        cout << "Queue is empty!" << endl;
    } else {
        cout << "Queue is not empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Queue_Linked_List_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    int data;
    Node* next;

    public:
    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

class Queue {
    int *arr;
    int size, front, rear;

    public:
    Queue(int S) {
        size = S;
        arr = new int[size];
        front = rear = 0;
    }

    void push(int val) {
        if(rear == size-1) {
            cout << "Queue overflow!" << endl;
        } else {
            arr[rear++] = val;
        }
    }

    void pop() {
        if(front == rear) {
            cout << "Queue underflow!" << endl;
        } else {
            front++;

            if(front == rear) {
                front = rear = 0;
            }
        }
    }

    int frontElement() {
        return (front==rear) ? -1 : arr[front];
    }

    int backElement() {
        return (front==rear) ? -1 : arr[rear-1];
    }

    int queueSize() {
        return (front==rear) ? 0 : (rear-front);
    }

    bool empty() {
        return (front==rear) ? true : false;
    }
};

int main() {
    Queue q(10);
    q.push(11);

    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;
    q.push(15);
    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;

    q.push(23);
    q.push(30);

    cout << "Size of queue : " << q.queueSize() << endl;

    cout << endl << "Front before pop : " << q.frontElement() << endl;
    cout << "Back before pop : " << q.backElement() << endl;
    q.pop();    
    cout << "Front after pop : " << q.frontElement() << endl;
    cout << "Back after pop : " << q.backElement() << endl << endl;

    q.pop();
    q.pop();

    cout << "Size of queue : " << q.queueSize() << endl;

    q.pop();

    if(q.empty()) {
        cout << "Queue is empty!" << endl;
    } else {
        cout << "Queue is not empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Circular_Queue.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class CQueue {
    int *arr;
    int size, front, rear;

    public:
    CQueue(int S) {
        size = S;
        arr = new int[size];
        front = rear = 0;
    }

    void push(int val) {
        // Overflow condition
        if((front == 0 && rear == size-1) || (rear == (front-1)%(size-1))) {
            cout << "CQueue overflow!" << endl;
            return;
        } else if(front == -1) {
            // For first element
            front = rear = 0;
        } else if(rear == size-1 && front != 0) {
            // If front is in middle of the queue and rear is at the end
            rear = 0;
        } else {
            rear++;
        }

        arr[rear] = val;
    }

    void pop() {
        if(front == rear+1 || front == -1) {
            cout << "CQueue underflow!" << endl;
        } else if(front == rear) {
            front = rear = -1;
        } else if(front == size-1) {
            front = 0;
        } else {
            front++;
        }
    }

    int frontElement() {
        return (front==rear) ? -1 : arr[front];
    }

    int backElement() {
        return (front==rear) ? -1 : arr[rear-1];
    }

    int queueSize() {
        return (front==rear) ? 0 : (rear-front);
    }

    bool empty() {
        return (front==rear) ? true : false;
    }
};

int main() {
    CQueue q(10);
    q.push(11);

    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;
    q.push(15);
    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;

    q.push(23);
    q.push(30);

    cout << "Size of queue : " << q.queueSize() << endl;

    cout << endl << "Front before pop : " << q.frontElement() << endl;
    cout << "Back before pop : " << q.backElement() << endl;
    q.pop();    
    cout << "Front after pop : " << q.frontElement() << endl;
    cout << "Back after pop : " << q.backElement() << endl << endl;

    q.pop();
    q.pop();

    cout << "Size of queue : " << q.queueSize() << endl;

    q.pop();

    if(q.empty()) {
        cout << "Queue is empty!" << endl;
    } else {
        cout << "Queue is not empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Input_Restricted_Queue.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Output_Restricted_Queue.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Doubly_Ended_Queue_STL.cpp


```cpp

#include <iostream>
#include <queue>
using namespace std;

int main() {

    deque<int> q;
    q.push_front(11);
    q.push_back(14);


    cout << "Front element of q : " << q.front() << endl;
    cout << "Back element of q : " << q.back() << endl;
    // q.push(15);
    // cout << "Front element of q : " << q.front() << endl;
    // cout << "Back element of q : " << q.back() << endl;

    // q.push(23);
    // q.push(30);

    // cout << "Size of queue : " << q.size() << endl;

    // cout << endl << "Front before pop : " << q.front() << endl;
    // cout << "Back before pop : " << q.back() << endl;
    // q.pop();    
    // cout << "Front after pop : " << q.front() << endl;
    // cout << "Back after pop : " << q.back() << endl << endl;

    // q.pop();
    // q.pop();

    // cout << "Size of queue : " << q.size() << endl;

    // q.pop();

    // if(q.empty()) {
    //     cout << "Queue is empty!" << endl;
    // } else {
    //     cout << "Queue is not empty!" << endl;
    // }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 8_Doubly_Ended_Queue_Implementation.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Deque {
    int *arr;
    int size, front, rear;

    public:
    Deque(int S) {
        size = S;
        arr = new int[size];
        front = rear = -1;
    }

    void push_front(int val) {
        // Overflow Condition
        if((front==0 && rear==size-1) || (front != 0 && rear == (front-1)%(size-1))) {
            cout << "Deque Overflow!" << endl;
            return;
        }

        // For empty Deque
        if(front == -1) {
            front = rear = 0;
            arr[front] = val;
        } else if(front == 0 && rear != size-1) {     // To maintain cyclic nature
            front = size-1;
            arr[front] = val;
        } else {        // Normal flow
            front--;
        }

        arr[front] = val;
    }

    void push_back(int val) {
        // Overflow condition
        if((front == 0 && rear == size-1) || (front != 0 && rear == (front-1)%(size-1))) {
            cout << "Deque overflow!" << endl;
            return;
        } else if(front == -1) {        // For first element
            front = rear = 0;
        } else if(rear == size-1 && front != 0) {
            // If front is in middle of the queue and rear is at the end
            rear = 0;
        } else {
            rear++;
        }

        arr[rear] = val;
    }

    void pop_front() {
        if(front == -1) {
            cout << "Deque underflow!" << endl;
        } else if(front == rear) {
            front = rear = -1;
        } else if(front == size-1) {
            front = 0;
        } else {
            front++;
        }
    }

    void pop_back() {
        if(front == -1) {
            cout << "Deque underflow!" << endl;
        } else if(front == rear) {
            front = rear = -1;
        } else if(rear == 0) {
            rear = size-1;
        } else {
            rear--;
        }
    }

    bool empty() {
        return (front==-1) ? true : false;
    }

    int frontElement() {
        return (this->empty()) ? -1 : arr[front];
    }

    int backElement() {
        return (this->empty()) ? -1 : arr[rear-1];
    }

    int queueSize() {
        return (front==rear) ? 0 : (rear-front);
    }
};

int main() {
    Deque q(10);
    q.push_front(11);

    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;
    q.push_back(15);
    cout << "Front element of q : " << q.frontElement() << endl;
    cout << "Back element of q : " << q.backElement() << endl;

    q.push_back(23);
    q.push_front(30);

    cout << "Size of queue : " << q.queueSize() << endl;

    cout << endl << "Front before pop : " << q.frontElement() << endl;
    cout << "Back before pop : " << q.backElement() << endl;
    q.pop_front();    
    cout << "Front after pop : " << q.frontElement() << endl;
    cout << "Back after pop : " << q.backElement() << endl << endl;

    q.pop_back();
    q.pop_back();

    cout << "Size of queue : " << q.queueSize() << endl;

    q.pop_front();

    if(q.empty()) {
        cout << "Queue is empty!" << endl;
    } else {
        cout << "Queue is not empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Queue_Rervsal.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void Rev_Queue_App1(queue<int> &Q) {
    stack<int> temp;

    while(!Q.empty()) {
        temp.push(Q.front());
        Q.pop();
    }

    while(!temp.empty()) {
        Q.push(temp.top());
        temp.pop();
    }
}

void print(queue<int> Q) {
    while(!Q.empty()) {
        cout << Q.front() << " ";
        Q.pop();
    }

    cout << endl;
}

int main() {
    queue<int> Q;

    Q.push(77);
    Q.push(65);
    Q.push(98);
    Q.push(46);
    Q.push(32);

    cout << "Before reverse : ";
    print(Q);

    Rev_Queue_App1(Q);

    cout << "Before reverse : ";
    print(Q);
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Binary_Tree_Introduction.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
        int data;
        Node* left;
        Node* right;

        Node(int d) {
            this->data = d;
            this->left = NULL;
            this->right = NULL;
        }
};

Node* buildTree(Node* root) {
    int data;
    cout << "Enter the data : ";
    cin >> data;
    root = new Node(data);

    if(data == -1) {
        return NULL;
    }

    cout << "LEFT of " << data << " : ";
    root->left = buildTree(root->left);
    
    cout << "RIGHT of " << data << " : ";
    root->right = buildTree(root->right);

    return root;
}

void levelOrderTraversal(Node* root) {
    queue<Node*> Q;
    Q.push(root);
    Q.push(NULL);

    while(!Q.empty()) {
        Node* temp = Q.front();
        Q.pop();

        if(temp == NULL) {
            cout << endl;

            if(!Q.empty()) {
                Q.push(NULL);
            }
        } else {
            cout << temp->data << " ";

            if(temp->left) {
                Q.push(temp->left);
            }

            if(temp->right) {
                Q.push(temp->right);
            }
        }
    }
}

void inOrderTraversal(Node* root) {
    if(root == NULL) {
        return;
    }

    inOrderTraversal(root->left);
    cout << root->data << " ";
    inOrderTraversal(root->right);
}

void preOrderTraversal(Node* root) {
    if(root == NULL) {
        return;
    }

    cout << root->data << " ";
    preOrderTraversal(root->left);
    preOrderTraversal(root->right);
}

void postOrderTraversal(Node* root) {
    if(root == NULL) {
        return;
    }

    postOrderTraversal(root->left);
    postOrderTraversal(root->right);
    cout << root->data << " ";
}

Node* BuildLevelOrder(Node* root) {
    queue<Node*> Q;
    int data;
    cout << "Enter data : ";
    cin >> data;
    root = new Node(data);
    Q.push(root);

    while(!Q.empty()) {
        Node* temp = Q.front();
        Q.pop();

        cout << "Enter leftnode of " << temp->data << " : ";
        int leftData;
        cin >> leftData;

        if(leftData != -1) {
            temp->left = new Node(leftData);
            Q.push(temp->left);
        }

        cout << "Enter rightnode of " << temp->data << " : ";
        int rightData;
        cin >> rightData;

        if(rightData != -1) {
            temp->right = new Node(rightData);
            Q.push(temp->right);
        }
    }

    return root;
}

int main() {
    Node* root = NULL;

    // Creating a tree
    root = BuildLevelOrder(root);

    cout << "\nLevel Order Traversal : " << endl;
    levelOrderTraversal(root);

    // cout << "\nIn Order Traversal : " << endl;
    // inOrderTraversal(root);
    
    // cout << "\nPre Order Traversal : " << endl;
    // preOrderTraversal(root);
    
    // cout << "\nPost Order Traversal : " << endl;
    // postOrderTraversal(root);

    return 0;
}

// 1 3 7 -1 -1 11 -1 -1 5 17 -1 -1 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_PreOrder_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void preOrderRecursive(Node* root) {
    if(root == NULL) {
        return;
    }

    cout << root->data << " ";
    preOrderRecursive(root->left);
    preOrderRecursive(root->right);
}

int main() {
    Node* root = NULL;

    // Creating a tree
    root = buildTree(root);

    cout << "\nPre Order Traversal : " << endl;
    preOrderRecursive(root);

    return 0;
}

// INPUT : 1 3 7 -1 -1 11 -1 -1 5 17 -1 -1 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_InOrder_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void inOrderRecursive(Node* root) {
    if(root == NULL) {
        return;
    }

    inOrderRecursive(root->left);
    cout << root->data << " ";
    inOrderRecursive(root->right);
}

int main() {
    Node* root = NULL;

    // Creating a tree
    root = buildTree(root);

    cout << "\nIn Order Traversal : " << endl;
    inOrderRecursive(root);

    return 0;
}

// INPUT : 1 3 7 -1 -1 11 -1 -1 5 17 -1 -1 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_PostOrder_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void postOrderRecursive(Node* root) {
    if(root == NULL) {
        return;
    }

    postOrderRecursive(root->left);
    postOrderRecursive(root->right);
    cout << root->data << " ";
}

int main() {
    Node* root = NULL;

    // Creating a tree
    root = buildTree(root);

    cout << "\nPost Order Traversal : " << endl;
    postOrderRecursive(root);

    return 0;
}

// INPUT : 1 3 7 -1 -1 11 -1 -1 5 17 -1 -1 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Reverse_Level_Order.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

int main() {
    
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Height_Of_Binary_Tree.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

int getHeight(Node* root) {
    if(root == NULL) {
        return 0;
    }

    int left = getHeight(root->left);
    int right = getHeight(root->right);

    int answer = max(left, right) + 1;
    return answer;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);

    int height = getHeight(root);
    cout << endl << "Height / Depth of the tree is : " << height << endl;

    return 0;
}

/*
    INPUT:
        3 4 -1 -1 6 -1 -1
        5 4 2 -1 6 -1 -1 7 -1 8 -1 9 -1 -1 10 -1 -1
        8 2 4 -1 -1 6 2 -1 -1 5 -1 -1 5 -1 9 -1 6 4 2 -1 -1 3 -1 -1 7 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Diameter_Of_Binary_Tree.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

int getHeight(Node* root) {
    if(root == NULL) {
        return 0;
    }

    int h1 = getHeight(root->left);
    int h2 = getHeight(root->right);

    return max(h1, h2) + 1;
}

int getDiameter(Node* root) {
    if(root == NULL) {
        return 0;
    }

    int d1 = getDiameter(root->left);
    int d2 = getDiameter(root->right);
    int d3 = getHeight(root->left) + getHeight(root->right) + 1;

    return max(d1, max(d2, d3));
}

pair<int, int> getDiameterOptimised(Node* root) {
    if(root == NULL) {
        return {0,0};
    }

    pair<int, int> d1 = getDiameterOptimised(root->left);
    pair<int, int> d2 = getDiameterOptimised(root->right);
    pair<int, int> ans;

    ans.second = max(d1.second, d2.second) + 1;

    int opt1 = d1.first;
    int opt2 = d2.first;
    int opt3 = d1.second + d2.second + 1;

    ans.first = max(opt1, max(opt2, opt3));

    return ans;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);

    // int Diameter = getDiameter(root);
    pair<int, int> Diameter = getDiameterOptimised(root);

    cout << endl << "Diameter of the tree is : " << Diameter.first << endl;

    return 0;
}

/*
    INPUT:
        3 4 -1 -1 6 -1 -1
        5 4 2 -1 6 -1 -1 7 -1 8 -1 9 -1 -1 10 -1 -1
        8 2 4 -1 -1 6 2 -1 -1 5 -1 -1 5 -1 9 -1 6 4 2 -1 -1 3 -1 -1 7 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Check_Balanced_Tree.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

int getHeight(Node* root) {
    if(root == NULL) {
        return 0;
    }

    int h1 = getHeight(root->left);
    int h2 = getHeight(root->right);

    return max(h1, h2) + 1;
}

bool isBalanced(Node* root) {
    if(root == NULL) {
        return true;
    }

    bool isLeft = isBalanced(root->left);
    bool isRight = isBalanced(root->right);

    bool diff = abs(getHeight(root->left) - getHeight(root->right)) <= 1;

    return isLeft && isRight && diff;
}

pair<bool, int> isBalancedOptimised(Node* root) {
    if(root == NULL) {
        return {true, 0};
    }

    pair<bool, int> left = isBalancedOptimised(root->left);
    pair<bool, int> right = isBalancedOptimised(root->right);

    bool isLeft = left.first;
    bool isRight = right.first;

    bool diff = abs(left.second - right.second) <= 1;

    pair<bool, int> ans;
    ans.first = isLeft && isRight && diff;
    ans.second = max(left.second, right.second) + 1;

    return ans;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);

    // bool check = isBalanced(root);
    bool check = isBalancedOptimised(root).first;

    if(check) {
        cout << endl << "Balanced Tree!" << endl;
    } else {
        cout << endl << "Not a balanced tree!" << endl;
    }

    return 0;
}

/*
    INPUT:
        1 10 5 -1 -1 -1 39 -1 -1
        1 10 5 -1 -1 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Check_Identical_Trees.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

bool isIdentical(Node* root1, Node* root2) {
    if(root1 == NULL && root2 == NULL) {
        return true;
    }

    if(root1==NULL || root2==NULL) {
        return false;
    }

    bool isLeft = isIdentical(root1->left, root2->left);
    bool isRight = isIdentical(root1->right, root2->right);
    bool value = (root1->data == root2->data);
    
    return isLeft && isRight & value;
}

int main() {
    Node* root1 = NULL;
    Node* root2 = NULL;

    root1 = buildTree(root1);
    root2 = buildTree(root2);

    bool check = isIdentical(root1, root2);

    if(check) {
        cout << endl << "Identical Trees!" << endl;
    } else {
        cout << endl << "Non-Identical Trees!" << endl;
    }

    return 0;
}

/*
    INPUT:
        1 2 -1 -1 3 -1 -1
        1 2 -1 -1 3 -1 -1

        1 3 -1 -1 3 -1 -1
        1 2 -1 -1 3 -1 -1

        1 2 -1 7 -1 -1 3 -1 -1
        1 2 -1 -1 3 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Sum_Tree.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

pair<bool, int> isSumTree(Node* root) {
    if(root == NULL) {
        return {true, 0};
    }
    
    if(root->left == NULL && root->right == NULL) {
        return {true, root->data};
    }

    pair<bool, int> Left = isSumTree(root->left);
    pair<bool, int> Right = isSumTree(root->right);

    bool sum = root->data == (Left.second + Right.second);

    pair<bool, int> ans;
    ans.first = (Left.first && Right.first && sum);
    ans.second = 2 * root->data;

    return ans;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);

    bool check = isSumTree(root).first;

    if(check) {
        cout << endl << "Sum Tree!" << endl;
    } else {
        cout << endl << "Not a sum Tree!" << endl;
    }

    return 0;
}

/*
    INPUT:
        3 1 -1 -1 2 -1 -1
        28 8 4 -1 4 -1 -1 -1 6 -1 3 2 -1 -1 1 -1 -1
        14 18 4 -1 4 -1 -1 -1 6 -1 3 2 -1 -1 1 -1 -1
        14 8 4 -1 4 -1 -1 -1 6 -1 3 2 -1 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_ZigZag_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

vector<int> ZigZag(Node* root) {
    if(root == NULL) {
        return {};
    }

    queue<Node*> Q;
    vector<int> answer;

    Q.push(root);
    bool L2R = true;

    while(!Q.empty()) {
        int size = Q.size();
        vector<int> result(size);

        // Level Process
        for(int i=0; i<size; i++) {
            Node* FrontNode = Q.front();
            Q.pop();

            int index = L2R ? i : size-i-1;
            result[index] = FrontNode->data;

            if(FrontNode->left) {
                Q.push(FrontNode->left);
            }

            if(FrontNode->right) {
                Q.push(FrontNode->right);
            }
        }
        
        // Change Direction
        L2R = !L2R;

        for(auto i : result) {
            answer.push_back(i);
        }
    }

    return answer;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer = ZigZag(root);

    cout << endl << "Zigzag Traversal : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 3 -1 -1 5 -1 -1 4 -1 6 7 -1 -1 8 -1 -1
        7 9 8 10 -1 -1 9 -1 -1 8 -1 -1 7 6 -1 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Boundary_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void traverseLeft(Node* root, vector<int> &answer) {
    if(root == NULL) {
        return;
    }
    
    // For Leaf Node
    if(root->left == NULL && root->right == NULL) {
        return;
    }

    answer.push_back(root->data);

    if(root->left) {
        traverseLeft(root->left, answer);
    } else {
        traverseLeft(root->right, answer);
    }
}

void traverseLeaf(Node* root, vector<int> &answer) {
    if(root == NULL) {
        return;
    }
    
    // For Leaf Node
    if(root->left == NULL && root->right == NULL) {
        answer.push_back(root->data);
        return;
    }

    traverseLeaf(root->left, answer);
    traverseLeaf(root->right, answer);
}

void traverseRight(Node* root, vector<int> &answer) {
    if(root == NULL) {
        return;
    }
    
    // For Leaf Node
    if(root->left == NULL && root->right == NULL) {
        return;
    }

    if(root->right) {
        traverseRight(root->right, answer);
    } else {
        traverseRight(root->left, answer);
    }

    answer.push_back(root->data);

}

vector<int> Boundary(Node* root) {
    if(root == NULL) {
        return {};
    }

    vector<int> answer;
    answer.push_back(root->data);

    // Printing Left Part
    traverseLeft(root->left, answer);

    // Printing Leaf Nodes from left subtree
    traverseLeaf(root->left, answer);
    
    // Printing Leaf Nodes from right subtree
    traverseLeaf(root->right, answer);

    // Printing Right Part
    traverseRight(root->right, answer);
    
    return answer;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer = Boundary(root);

    cout << endl << "Boundary Traversal : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 3 -1 -1 5 6 -1 -1 8 -1 -1 4 -1 7 -1 9 10 -1 -1 11 -1 -1
        7 9 8 10 -1 -1 9 -1 -1 8 -1 -1 7 6 -1 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Vertical_Order_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

vector<int> VerticalOrder(Node* root) {
    if(root == NULL) {
        return {};
    }

    vector<int> answer;
    map<int, map<int, vector<int> > > NodeMap;
    queue<pair<Node*, pair<int, int> > > Q;

    Q.push(make_pair(root, make_pair(0,0)));

    while(!Q.empty()) {
        pair<Node*, pair<int, int> > temp = Q.front();
        Q.pop();

        Node* FrontNode = temp.first;
        int HorizDist = temp.second.first;
        int Lvl = temp.second.second;

        NodeMap[HorizDist][Lvl].push_back(FrontNode->data);

        if(FrontNode->left) {
            Q.push(make_pair(FrontNode->left, make_pair(HorizDist-1, Lvl+1)));
        }

        if(FrontNode->right) {
            Q.push(make_pair(FrontNode->right, make_pair(HorizDist+1, Lvl+1)));
        }
    }

    for(auto i : NodeMap) {
        for(auto j : i.second) {
            for(auto k : j.second) {
                
                answer.push_back(k);

            }
        }
    }

    return answer;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer = VerticalOrder(root);

    cout << endl << "Vertical Order Traversal : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 3 -1 -1 5 6 -1 -1 8 -1 -1 4 -1 7 -1 9 10 -1 -1 11 -1 -1
        1 2 4 -1 -1 5 -1 -1 3 6 -1 8 -1 -1 7 -1 9 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Top_View.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void TraverseLeft(Node* root, vector<int>& answer) {
    if(root == NULL) {
        return;
    }

    TraverseLeft(root->left, answer);
    answer.push_back(root->data);
}

void TraverseRight(Node* root, vector<int>& answer) {
    if(root == NULL) {
        return;
    } 

    answer.push_back(root->data);
    TraverseRight(root->right, answer);
}

vector<int> TopView(Node* root) {
    if(root == NULL) {
        return {};
    }

    vector<int> answer;

    // Left Part
    TraverseLeft(root->left, answer);

    // Root Node
    answer.push_back(root->data);

    // Right Part
    TraverseRight(root->right, answer);

    return answer;
}

vector<int> TopView2(Node* root) {
    if(root == NULL) {
        return {};
    }

    vector<int> answer;
    map<int, int> TopNode;
    queue<pair<Node*, int> > Q;

    Q.push(make_pair(root, 0));

    while(!Q.empty()) {
        pair<Node*, int> temp = Q.front();
        Q.pop();

        Node* FrontNode = temp.first;
        int HorizDist = temp.second;

        // If one value is present for a HD, then do nothing
        if(TopNode.find(HorizDist) == TopNode.end()) {
            TopNode[HorizDist] = FrontNode->data;
        }

        if(FrontNode->left) {
            Q.push(make_pair(FrontNode->left, HorizDist-1));
        }

        if(FrontNode->right) {
            Q.push(make_pair(FrontNode->right, HorizDist+1));
        }
    }

    for(auto i : TopNode) {
        answer.push_back(i.second);
    }

    return answer;
}


int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer = TopView2(root);

    cout << endl << "Top View : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1
        1 2 3 -1 -1 5 6 -1 -1 8 -1 -1 4 -1 7 -1 9 10 -1 -1 11 -1 -1
        1 2 4 -1 -1 5 -1 -1 3 6 -1 8 -1 -1 7 -1 9 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Bottom_View.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

vector<int> BottomView(Node* root) {
    if(root == NULL) {
        return {};
    }

    vector<int> answer;

    map<int, int> BottomNode;
    queue<pair<Node*, int> > Q;
    Q.push(make_pair(root, 0));

    while(!Q.empty()) {
        pair<Node*, int> temp = Q.front();
        Q.pop();

        Node* FrontNode = temp.first;
        int HorizDist = temp.second;

        BottomNode[HorizDist] = FrontNode->data;

        if(FrontNode->left) {
            Q.push(make_pair(FrontNode->left, HorizDist-1));
        }

        if(FrontNode->right) {
            Q.push(make_pair(FrontNode->right, HorizDist+1));
        }
    }

    for(auto i : BottomNode) {
        answer.push_back(i.second);
    }

    return answer;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer = BottomView(root);

    cout << endl << "Bottom View : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1
        1 2 -1 4 5 -1 -1 -1 3 -1 -1
        1 2 4 -1 -1 5 -1 -1 3 6 -1 8 -1 -1 7 -1 9 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_Left_View.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void LeftView(Node* root, vector<int>& answer, int lvl) {
    if(root == NULL) {
        return;
    }

    if(lvl == answer.size()) {
        answer.push_back(root->data);
    }

    LeftView(root->left, answer, lvl+1);
    LeftView(root->right, answer, lvl+1);
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer;
    LeftView(root, answer, 0);

    cout << endl << "Left View : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1
        1 2 -1 4 5 -1 -1 -1 3 -1 -1
        1 2 3 -1 -1 4 -1 7 -1 -1 5 -1 6 -1 8 -1 9 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 7_Right_View.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

void RightView(Node* root, vector<int>& answer, int lvl) {
    if(root == NULL) {
        return;
    }

    if(lvl == answer.size()) {
        answer.push_back(root->data);
    }

    RightView(root->right, answer, lvl+1);
    RightView(root->left, answer, lvl+1);
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer;
    RightView(root, answer, 0);

    cout << endl << "Right View : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        1 2 -1 4 6 7 -1 -1 8 -1 -1 -1 3 -1 5 -1 -1
        1 2 -1 4 5 -1 -1 -1 3 -1 -1
        1 2 3 -1 -1 4 -1 7 -1 -1 5 -1 6 -1 8 -1 9 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 8_Diagonal_Traversal.cpp


```cpp

#include <bits/stdc++.h>
#include "BinaryTree.h"

using namespace std;

vector<int> Diagonal(Node* root) {
    if(root == NULL) {
        return {};
    }

    vector<int> answer;
    queue<Node*> Q;
    Q.push(root);

    while(!Q.empty()) {
        Node* FrontNode = Q.front();
        Q.pop();
        
        if(FrontNode->left) {
            Q.push(FrontNode->left);
        }
        
        while(FrontNode->right) {
            answer.push_back(FrontNode->data);
            FrontNode = FrontNode->right;

            if(FrontNode->left) {
                Q.push(FrontNode->left);
            } 
        }
        
        answer.push_back(FrontNode->data);
    }
    
    return answer;
}

int main() {
    Node* root = NULL;

    root = buildTree(root);
    vector<int> answer = Diagonal(root);

    cout << endl << "Diagonal Traversal : ";
    for(auto i : answer) {
        cout << i << " ";
    }

    return 0;
}

/*
    INPUT:
        2 3 5 -1 -1 -1 4 6 -1 -1 7 -1 -1
        2 3 8 -1 -1 7 -1 -1 4 -1 5 6 -1 -1 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Binary_Search_Tree_Implementation.cpp


```cpp

#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node* left;
        Node* right;

        Node(int data) {
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
};

Node* insertIntoBST(Node* root, int data) {
    if(root == NULL) {
        root = new Node(data);
        return root;
    }

    if(data > root->data) {
        root->right = insertIntoBST(root->right, data);
    } else {
        root->left = insertIntoBST(root->left, data);
    }

    return root;
}

void takeinput(Node* &root) {
    int data;
    cin >> data;

    while(data != -1) {
        root = insertIntoBST(root, data);
        cin >> data;
    }
}

void levelOrderTraversal(Node* root) {
    if(root == NULL) {
        return;
    }

    queue<Node*> Q;
    Q.push(root);
    Q.push(NULL);

    while(!Q.empty()) {
        Node* FrontNode = Q.front();
        Q.pop();

        if(FrontNode == NULL) {
            cout << endl;
            
            if(!Q.empty()) {
                Q.push(NULL);
            }
        } else {
            cout << FrontNode->data << " ";

            if(FrontNode->left) {
                Q.push(FrontNode->left);
            }

            if(FrontNode->right) {
                Q.push(FrontNode->right);
            }
        }
    }
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << endl << "Level Order Traversal : ";
    levelOrderTraversal(root);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_BST_Traversals.cpp


```cpp

#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node* left;
        Node* right;

        Node(int data) {
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
};

Node* insertIntoBST(Node* root, int data) {
    if(root == NULL) {
        root = new Node(data);
        return root;
    }

    if(data > root->data) {
        root->right = insertIntoBST(root->right, data);
    } else {
        root->left = insertIntoBST(root->left, data);
    }

    return root;
}

void takeinput(Node* &root) {
    int data;
    cin >> data;

    while(data != -1) {
        root = insertIntoBST(root, data);
        cin >> data;
    }
}

void preOrderRecursive(Node* root) {
    if(root == NULL) {
        return;
    }

    cout << root->data << " ";
    preOrderRecursive(root->left);
    preOrderRecursive(root->right);
}

void inOrderRecursive(Node* root) {
    if(root == NULL) {
        return;
    }

    inOrderRecursive(root->left);
    cout << root->data << " ";
    inOrderRecursive(root->right);
}

void postOrderRecursive(Node* root) {
    if(root == NULL) {
        return;
    }

    postOrderRecursive(root->left);
    postOrderRecursive(root->right);
    cout << root->data << " ";
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << endl << "InOrder Traversal : ";
    inOrderRecursive(root);

    cout << endl << "PreOrder Traversal : ";
    preOrderRecursive(root);

    cout << endl << "PostOrder Traversal : ";
    postOrderRecursive(root);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Search_In_BST.cpp


```cpp

#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node* left;
        Node* right;

        Node(int data) {
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
};

Node* insertIntoBST(Node* root, int data) {
    if(root == NULL) {
        root = new Node(data);
        return root;
    }

    if(data > root->data) {
        root->right = insertIntoBST(root->right, data);
    } else {
        root->left = insertIntoBST(root->left, data);
    }

    return root;
}

void takeinput(Node* &root) {
    int data;
    cin >> data;

    while(data != -1) {
        root = insertIntoBST(root, data);
        cin >> data;
    }
}

bool SearchBST(Node* root, int key) {
    if(root == NULL) {
        return false;
    }

    if(root->data == key) {
        return true;
    }

    if(key > root->data) {
        return SearchBST(root->right, key);
    } else {
        return SearchBST(root->left, key);
    }
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    int key;
    cout << "Enter the key to search : ";
    cin >> key;

    bool found = SearchBST(root, key);
    
    if(found) {
        cout << "Key present in BST!" << endl;
    } else {
        cout << "Key absent in BST!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Min_Max_Of_BST.cpp


```cpp

#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node* left;
        Node* right;

        Node(int data) {
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
};

Node* insertIntoBST(Node* root, int data) {
    if(root == NULL) {
        root = new Node(data);
        return root;
    }

    if(data > root->data) {
        root->right = insertIntoBST(root->right, data);
    } else {
        root->left = insertIntoBST(root->left, data);
    }

    return root;
}

void takeinput(Node* &root) {
    int data;
    cin >> data;

    while(data != -1) {
        root = insertIntoBST(root, data);
        cin >> data;
    }
}

int minVal(Node* root) {
    if(root == NULL) {
        return -1;
    }

    Node* temp = root;
    while(temp->left) {
        temp = temp->left;
    }

    return temp->data;
}

int maxVal(Node* root) {
    if(root == NULL) {
        return -1;
    }
    
    Node* temp = root;
    while(temp->right) {
        temp = temp->right;
    }

    return temp->data;
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << endl << "Minimum Value : " << minVal(root);
    cout << endl << "Maximum Value : " << maxVal(root);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Deletion_In_BST.cpp


```cpp

#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node* left;
        Node* right;

        Node(int data) {
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
};

Node* insertIntoBST(Node* root, int data) {
    if(root == NULL) {
        root = new Node(data);
        return root;
    }

    if(data > root->data) {
        root->right = insertIntoBST(root->right, data);
    } else {
        root->left = insertIntoBST(root->left, data);
    }

    return root;
}

void takeinput(Node* &root) {
    int data;
    cin >> data;

    while(data != -1) {
        root = insertIntoBST(root, data);
        cin >> data;
    }
}

void levelOrderTraversal(Node* root) {
    if(root == NULL) {
        return;
    }

    queue<Node*> Q;
    Q.push(root);
    Q.push(NULL);

    while(!Q.empty()) {
        Node* FrontNode = Q.front();
        Q.pop();

        if(FrontNode == NULL) {
            cout << endl;
            
            if(!Q.empty()) {
                Q.push(NULL);
            }
        } else {
            cout << FrontNode->data << " ";

            if(FrontNode->left) {
                Q.push(FrontNode->left);
            }

            if(FrontNode->right) {
                Q.push(FrontNode->right);
            }
        }
    }
}

int minVal(Node* root) {
    if(root == NULL) {
        return -1;
    }

    Node* temp = root;
    while(temp->left) {
        temp = temp->left;
    }

    return temp->data;
}

Node* DeletionInBST(Node* root, int data) {
    if(root == NULL) {
        return root;
    }

    if(root->data == data) {
        
        // 0 Child
        if(root->left==NULL && root->right==NULL) {
            delete root;
            return NULL;
        }

        // 1 Child
        // Left Child
        if(root->left!=NULL && root->right==NULL) {
            Node* temp = root->left;
            delete root;
            return temp;
        }
        // Right Child
        if(root->left==NULL && root->right!=NULL) {
            Node* temp = root->right;
            delete root;
            return temp;
        }

        // 2 Child
        if(root->left!=NULL && root->right!=NULL) {
            int mini = minVal(root->right);
            root->data = mini;
            root->right = DeletionInBST(root->right, mini);
            return root;
        }

    } else if(data > root->data) {
        root->right = DeletionInBST(root->right, data);
        return root;
    } else {
        root->left = DeletionInBST(root->left, data);
        return root;
    }
}

int main() {
    Node* root = NULL;
    int key;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << "Enter the key to delete : ";
    cin >> key;

    cout << endl << "Before Deletion : " << endl;
    levelOrderTraversal(root);
    
    root = DeletionInBST(root, key);

    cout << endl << "After Deletion : " << endl;
    levelOrderTraversal(root);

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Validate_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

bool ValidateBST(Node* root, int min, int max) {
    if(root == NULL) {
        return true;
    }

    if(root->data >= min && root->data <= max) {
        bool left = ValidateBST(root->left, min, root->data);
        bool right = ValidateBST(root->right, root->data, max);

        return (left && right);
    }

    return false;
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    if(ValidateBST(root, INT_MIN, INT_MAX)) {
        cout << "YES ! It is a Binary Search Tree.";
    } else {
        cout << "NO ! It is not a Binary Search Tree.";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Kth_Smallest_In_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

int kthSmallest(Node* root, int &index, int K) {
    if(root == NULL) {
        return -1;
    }

    int left = kthSmallest(root->left, index, K);

    if(left != -1) {
        return left;
    }

    index++;
    if(index == K) {
        return root->data;
    }

    return kthSmallest(root->right, index, K);
}

int main() {
    Node* root = NULL;
    int K, ans;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << "Enter the value of K : ";
    cin >> K;

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    int index = 0;
    ans = kthSmallest(root, index, K);

    cout << "Required answer = " << ans << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_KthSmallest_By_Morris_Traversal.cpp


```cpp



```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Kth_Largest_In_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

int kthLargest(Node* root, int &index, int K) {
    
}

int main() {
    Node* root = NULL;
    int K, ans;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << "Enter the value of K : ";
    cin >> K;

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    int index = 0;
    ans = kthLargest(root, index, K);

    cout << "Required answer = " << ans << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Inorder_Predecessor_Successor.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

pair<int, int> predecessorSuccessor(Node* root, int key) {
    Node* KeyNode = root;
    int pred = -1;
    int succ = -1;
    
    while(KeyNode->data != key) {
        if(KeyNode->data > key) {
            succ = KeyNode->data;
            KeyNode = KeyNode->left;
        } else {
            pred = KeyNode->data;
            KeyNode = KeyNode->right;
        }
    }

    // Prdecessor
    Node* leftTree = KeyNode->left;
    while(leftTree != NULL) {
        pred = leftTree->data;
        leftTree = leftTree->right;
    }

    // Successor
    Node* rightTree = KeyNode->right;
    while(rightTree != NULL){
        succ = rightTree->data;
        rightTree = rightTree->left;
    }

    return {pred, succ};
}

int main() {
    Node* root = NULL;
    int key;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << "Enter the value of key element : ";
    cin >> key;

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    int index = 0;
    pair<int, int> ans = predecessorSuccessor(root, key);

    cout << "Predecessor : " << ans.first << endl;
    cout << "Successor   : " << ans.second << endl;
    return 0;
}

// 9 6 2 8 11 19 7 12 25 -1


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_LCA_In_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

// Recursive Way
// Node* LCAinBST(Node* root, Node* P, Node* Q) {
//     if(root == NULL) {
//         return NULL;
//     }

//     if(root->data < P->data && root->data < Q->data) {
//         return LCAinBST(root->right, P, Q);
//     }

//     if(root->data > P->data && root->data > Q->data) {
//         return LCAinBST(root->left, P, Q);
//     }

//     return root;
// }

// Iterative Way
Node* LCAinBST(Node* root, Node* P, Node* Q) {
    while(root != NULL) {
        if(root->data < P->data && root->data < Q->data) {
            root = root->right;
        } else if (root->data > P->data && root->data > Q->data) {
            root = root->left;
        } else {
            return root;
        }
    }
}

int main() {
    Node* root = NULL;
    int d1, d2;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << "Enter the two node values : ";
    cin >> d1 >> d2;

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    Node* P = searchNode(root, d1);
    Node* Q = searchNode(root, d2);
    
    Node* AnsNode = LCAinBST(root, P, Q);

    cout << "Lowest Common Anchestor of " << P->data << " & " << Q->data <<" is : ";
    cout << AnsNode->data << endl;

    return 0;
}

// 14 12 28 8 4 10 9 11 19 32 18 17 22 21 24 39 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# tempCodeRunnerFile.cpp


```cpp




```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Two_Sum_In_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

void inOrder(Node* root, vector<int>& ans) {
    if(root == NULL) {
        return;
    }

    inOrder(root->left, ans);
    ans.push_back(root->data);
    inOrder(root->right, ans);
}

bool checkTwoSum(Node* root, int target) {
    if(root == NULL) {
        return false;
    }

    vector<int> arr;
    inOrder(root, arr);

    int i=0, j=arr.size()-1;
    while(i <= j) {
        if(arr[i] + arr[j] == target) {
            return true;
        }

        if(arr[i] + arr[j] > target) {
            j--;
        } else {
            i++;
        }
    }

    return false;
}

int main() {
    Node* root = NULL;
    int target;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << "Enter the target value : ";
    cin >> target;

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    bool isSum = checkTwoSum(root, target);
    
    if(isSum) {
        cout << "Sum pair is present in BST!" << endl;
    } else {
        cout << "Sum pair is not present in BST!" << endl;
    }

    return 0;
}

// 14 12 28 8 4 10 9 11 19 32 18 17 22 21 24 39 -1


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Flatten_BST_To_Sorted_List.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

void inOrder(Node* root, vector<Node*>& ans) {
    if(root == NULL) {
        return;
    }

    inOrder(root->left, ans);
    ans.push_back(root);
    inOrder(root->right, ans);
}


void flattenBST(Node* &root) {
    if(root == NULL) {
        return;
    }

    vector<Node*> arr;
    inOrder(root, arr);

    for(int i=0; i<arr.size()-1; i++) {
        arr[i]->left = NULL;
        arr[i]->right = arr[i+1];
    }

    arr[arr.size()-1]->left = NULL;
    arr[arr.size()-1]->right = NULL;

    root = arr[0];
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    flattenBST(root);

    Node* temp = root;
    cout << "Flatten BST : ";
    while(temp != NULL) {
        cout << temp->data << " ";
        temp = temp->right;
    }

    return 0;
}

// 14 12 28 8 4 10 9 11 19 32 18 17 22 21 24 39 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Normal_BST_To_Balanced_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

void inOrder(Node* root, vector<int>& ans) {
    if(root == NULL) {
        return;
    }

    inOrder(root->left, ans);
    ans.push_back(root->data);
    inOrder(root->right, ans);
}

Node* balanceBST(vector<int>& arr, int start, int end) {
    if(end-start < 0) {
        return NULL;
    }

    int mid = start + (end-start)/2;
    Node* temp = new Node(arr[mid]);

    temp->left = balanceBST(arr, start, mid-1);
    temp->right = balanceBST(arr, mid+1, end);

    return temp;
}

Node* NormalToBalance(Node* &root) {
    if(root == NULL) {
        return NULL;
    }

    vector<int> arr;
    inOrder(root, arr);

    Node* newBST = balanceBST(arr, 0, arr.size()-1);

    return newBST;
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create BST : ";
    takeinput(root);

    cout << endl << "Level Order Traversal of Normal BST : " << endl;
    levelOrderTraversal(root);

    Node* newRoot = NormalToBalance(root);

    cout << endl << "Level Order Traversal of Balanced BST : " << endl;
    levelOrderTraversal(newRoot);

    return 0;
}

// 10 8 12 5 15 2 18 -1
// 5 3 6 4 2 7 8 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Preorder_To_BST.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

// void inOrder(Node* root, vector<int>& ans) {
//     if(root == NULL) {
//         return;
//     }

//     inOrder(root->left, ans);
//     ans.push_back(root->data);
//     inOrder(root->right, ans);
// }

// Node* balanceBST(vector<int>& arr, int start, int end) {
//     if(end-start < 0) {
//         return NULL;
//     }

//     int mid = start + (end-start)/2;
//     Node* temp = new Node(arr[mid]);

//     temp->left = balanceBST(arr, start, mid-1);
//     temp->right = balanceBST(arr, mid+1, end);

//     return temp;
// }

Node* createPreorder(vector<int> &inorder, int &index, int min, int max) {
    if(index >= inorder.size()) {
        return NULL;
    }

    int data = inorder[index];

    if(data < min || data > max) {
        return NULL;
    }

    Node* temp = new Node(data);
    index++;

    temp->left = createPreorder(inorder, index, min, data);
    temp->right = createPreorder(inorder, index, data, max);

    return temp;
}

int main() {
    Node* root = NULL;
    vector<int> preorder;
    int index = 0;

    cout << "Enter elements of preorder traversal (-1 to stop) : ";
    int temp = -1;
    do {
        cin >> temp;
        preorder.push_back(temp);
    } while(temp != -1);

    root = createPreorder(preorder, index, INT_MIN, INT_MAX);

    cout << endl << "Level Order Traversal : " << endl;
    levelOrderTraversal(root);

    return 0;
}

// 20 10 5 15 13 35 30 42 -1
// 5 3 6 4 2 7 8 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Merge2BST_Inorder.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

void inOrder(Node* root, vector<int>& ans) {
    if(root == NULL) {
        return;
    }

    inOrder(root->left, ans);
    ans.push_back(root->data);
    inOrder(root->right, ans);
}

vector<int> mergeArrays(vector<int> arr1, vector<int> arr2) {
    if(arr1.size() == 0 || arr2.size() == 0) {
        return (arr1.size()) ? arr1 : arr2;
    }

    int i=0, j=0;
    vector<int> solution;

    while(i<arr1.size() && j<arr2.size()) {
        if(arr1[i] < arr2[j]) {
            solution.push_back(arr1[i++]);
        } else {
            solution.push_back(arr2[j++]);
        }
    }
    
    while(i<arr1.size()) {
        solution.push_back(arr1[i++]);
    }
    
    while(j<arr2.size()) {
        solution.push_back(arr2[j++]);
    }

    return solution;
}

Node* createBST(vector<int> &arr, int start, int end) {
    if(start > end) {
        return NULL;
    }

    int mid = start + (end-start)/2;
    Node* temp = new Node(arr[mid]);

    temp->left = createBST(arr, start, mid-1);
    temp->right = createBST(arr, mid+1, end);

    return temp;
}

Node* MergeBST(Node* root1, Node* root2) {
    vector<int> arr1;
    vector<int> arr2;

    inOrder(root1, arr1);
    inOrder(root2, arr2);

    vector<int> resultArray = mergeArrays(arr1, arr2);
    Node* answer = createBST(resultArray, 0, resultArray.size()-1);

    cout << endl << "Level Order Traversal of merged BST (infunc) : " << endl;
    levelOrderTraversal(answer);
    return answer;
}

int main() {
    Node* root1 = NULL;
    Node* root2 = NULL;
    int target;

    cout << "Enter data to create BST 1 : ";
    takeinput(root1);
    
    cout << "Enter data to create BST 2 : ";
    takeinput(root2);

    cout << endl << "Level Order Traversal of BST 1 : " << endl;
    levelOrderTraversal(root1);
    
    cout << endl << "Level Order Traversal of BST 2 : " << endl;
    levelOrderTraversal(root2);
    
    Node* result = MergeBST(root1, root2);

    cout << endl << "Level Order Traversal of merged BST : " << endl;
    levelOrderTraversal(result);
    
    return 0;
}

// 50 40 60 70 -1
// 55 45 35 65 47 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Merge2BST_LinkedList.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

void flattenBST(Node* root, Node* &head) {
    if(root == NULL) {
        return;
    }

    flattenBST(root->right, head);
    root->right = head;
    
    if(head != NULL) {
        head->left = root;
    }

    head = root;
    flattenBST(root->left, head);
}

Node* mergeLinkedhead(Node* head1, Node* head2) {
    Node* head = NULL;
    Node* tail = NULL;

    cout << "\nBEFORE FIRST WHILE\n";
    while(head1 != NULL && head2 != NULL) {
        if(head1->data < head2->data) {
            if(head == NULL) {
                head = tail = head1;
                head1 = head1->right;
            } else {
                tail->right = head1;
                head1->left = tail;
                tail = head1;
                head1 = head1->right;
            }
        } else {
            if(head == NULL) {
                head = tail = head2;
                head2 = head2->right;
            } else {
                tail->right = head2;
                head2->left = tail;
                tail = head2;
                head2 = head2->right;
            }
        }
    }

    cout << "\nAFTER FIRST WHILE\n";
    while(head1 != NULL) {
        tail->right = head1;
        head1->left = tail;
        tail = head1;
        head1 = head1->right;
    }

    while(head2 != NULL) {
        tail->right = head2;
        head2->left = tail;
        tail = head2;
        head2 = head2->right;
    }

    return head;
}

int countNodes(Node* head) {
    int cnt = 0;
    Node* temp = head;
    while(temp != NULL) {
        cnt++;
        temp = temp->right;
    }
    return cnt;
}

Node* LL_2_BST(Node* head, int n) {
    if(n <= 0 || head == NULL) {
        return NULL;
    }

    int temp = n/2;
    Node* root = head;
    while(temp--) {
        root = root->right;
    }

    root->left = LL_2_BST(head, n/2);
    root->right = LL_2_BST(root->right, n-n/2-1);
    return root;

    // Node* left = LL_2_BST(head, n/2);

    // Node* root = head;
    // root->left = left;
    // head = head->right;
    // root->right = LL_2_BST(head, n-n/2-1);

    // return root;
}

Node* MergeBST(Node* root1, Node* root2) {
    // Step 1 : Convert BST into DLL
    Node* head1 = NULL;
    Node* head2 = NULL;

    flattenBST(root1, head1);
    flattenBST(root2, head2);

    head1->left = NULL;
    head2->left = NULL;

    // Merge Sorted Linked List
    Node* list = mergeLinkedhead(head1, head2);

    // Convert List into BST
    Node* result = LL_2_BST(list, countNodes(list));

    return result;
}

int main() {
    Node* root1 = NULL;
    Node* root2 = NULL;
    int target;

    cout << "Enter data to create BST 1 : ";
    takeinput(root1);
    
    cout << "Enter data to create BST 2 : ";
    takeinput(root2);

    cout << endl << "Level Order Traversal of BST 1 : " << endl;
    levelOrderTraversal(root1);
    
    cout << endl << "Level Order Traversal of BST 2 : " << endl;
    levelOrderTraversal(root2);
    
    Node* result = MergeBST(root1, root2);

    cout << endl << "Level Order Traversal of merged BST : " << endl;
    levelOrderTraversal(result);
    
    return 0;
}

// 50 40 60 70 -1
// 55 45 35 65 47 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Max_BST_In_Binary_Tree.cpp


```cpp

#include <bits/stdc++.h>
#include "BST.h"
using namespace std;

class Info {
    public:
        int maxi;
        int mini;
        bool isBST;
        int size;

        Info() {
            this->maxi = INT_MIN;
            this->mini = INT_MAX;
            this->isBST = true;
            this->size = 0;
        }

        Info(int min, int max, bool isBST, int size) {
            this->maxi = max;
            this->mini = min;
            this->isBST = isBST;
            this->size = size;
        }
};

Info* MaxBST(Node* root, int &answer) {
    if(root == NULL) {
        Info* temp = new Info();
        return temp;
    }

    Info* left = MaxBST(root->left, answer);
    Info* right = MaxBST(root->right, answer);

    Info* currNode = new Info();

    currNode->size = left->size + right->size + 1;
    currNode->maxi = max(root->data, right->maxi);
    currNode->mini = min(root->data, left->mini);

    if(left->isBST && right->isBST && (root->data > left->maxi) && (root->data < right->mini)) {
        currNode->isBST = true;
    } else {
        currNode->isBST = false;
    }

    if(currNode->isBST) {
        answer = max(answer, currNode->size);
    }

    return currNode;
}

int main() {
    Node* root = NULL;

    cout << "Enter data to create a tree : ";
    root = buildBinaryTree(root);
    
    int answer = INT_MIN;
    Info* solve = MaxBST(root, answer);

    cout << endl << "Max BST : " << answer;
    
    return 0;
}

// 50 40 60 70 -1
// 55 45 35 65 47 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Heap_Introduction.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Heap {
    public:
        int arr[100];
        int size;

        Heap() {
            arr[0] = -1;
            size = 0;
        }

        void insert(int val) {
            int index = ++size;
            arr[index] = val;

            while(index > 1) {
                int parent = index/2;

                if(arr[parent] < arr[index]) {
                    swap(arr[parent], arr[index]);
                    index = parent;
                } else {
                    return;
                }
            }   
        }

        // void deleteHeap() {
        //     if(size == 0) {
        //         cout << "Heap is empty!" << endl;
        //         return;
        //     }

        //     arr[1] = arr[size];
        //     size--;

        //     int i = 1;
        //     while(i < size) {
        //         int leftChild = 2*i;
        //         int rightChild = (2*i) + 1;

        //         if(leftChild < size && arr[i] < arr[leftChild]) {
        //             swap(arr[i], arr[leftChild]);
        //             i = leftChild;
        //         } else if(rightChild < size && arr[i] < arr[rightChild]) {
        //             swap(arr[i], arr[rightChild]);
        //             i = rightChild;
        //         } else {
        //             return;
        //         }
        //     }
        // }

        void deleteHeap() {
            if(size == 0) {
                cout << "Heap is empty!" << endl;
                return;
            }

            arr[1] = arr[size];
            size--;

            int i = 1;
            while(i < size) {
                int leftChild = 2*i;
                int rightChild = (2*i) + 1;
                int largest = i;

                if(leftChild <= size && arr[largest] < arr[leftChild]) {
                    largest = leftChild;
                }
                
                if(rightChild <= size && arr[largest] < arr[rightChild]) {
                    largest = rightChild;
                }

                if(largest == i) {
                    return;
                } else {
                    swap(arr[i], arr[largest]);
                    i = largest;
                }
            }
        }

        void print() {
            cout << "Max Heap : ";
            for(int i=1; i<=size; i++) {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
};

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2*i;
    int right = 2*i + 1;

    if(left <= n && arr[largest] < arr[left]) {
        largest = left;
    }
            
    if(right <= n && arr[largest] < arr[right]) {
        largest = right;
    }

    if(largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

int main() {
    Heap h;
    
    h.insert(50);
    h.insert(40);
    h.insert(60);
    h.insert(30);
    h.insert(55);
    h.insert(70);
    h.insert(20);

    h.print();

    h.deleteHeap();
    h.print();

    int arr[6] = {-1, 54, 53, 55, 52, 50};
    int n = 5;
    for(int i = n/2; i>0; i--) {
        heapify(arr, n, i);
    }

    cout << "Heapified array : ";
    for(int i=1; i<=n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Build_Min_Heap.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

/*
    0 based indexing
    left - 2*i + 1;
    right - 2*i + 2;    
*/

void heapify(vector<int>& arr, int n, int i) {
    int smallest = i;
    int left = 2*i + 1;
    int right = 2*i + 2;

    

    if(left < n && arr[smallest] > arr[left]) {
        smallest = left;
    }
            
    if(right < n && arr[smallest] > arr[right]) {
        smallest = right;
    }

    if(smallest != i) {
        swap(arr[i], arr[smallest]);
        heapify(arr, n, smallest);
    }
}

vector<int> buildMinHeap(vector<int>& arr) {
    int n = arr.size();

    for(int i=(n/2)-1; i>=0; i--) {
        heapify(arr, n, i);
    }

    return arr;
}

int  main() {
    vector<int> arr = {90, 30, 20, 120, 50, 60, 40, 150};

    // Heapifing array
    cout << "Before building Min Heap : ";
    for(int i=0; i<arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    arr = buildMinHeap(arr);
    
    cout << "After building Min Heap : ";
    for(int i=0; i<arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Heap_Sort.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2*i;
    int right = 2*i + 1;

    if(left <= n && arr[largest] < arr[left]) {
        largest = left;
    }
            
    if(right <= n && arr[largest] < arr[right]) {
        largest = right;
    }

    if(largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int size) {
    while(size > 1) {
        swap(arr[1], arr[size]);

        size--;
        
        heapify(arr, size, 1);
    }
}

int main() {
    int arr[6] = {-1, 54, 53, 55, 50, 52};
    int size = 5;
    
    // Heap creation
    for(int i = size/2; i>0; i--) {
        heapify(arr, size, i);
    }
    
    cout << "UnSorted array : ";
    for(int i=1; i<=size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    // Calling heap sort
    heapSort(arr, size);

    cout << "Sorted array (Heap Sort) : ";
    for(int i=1; i<=size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Max_Heap_By_Priority_Queue.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;


int main() {
    priority_queue<int> maxHeap;

    maxHeap.push(52);
    maxHeap.push(50);
    maxHeap.push(54);
    maxHeap.push(40);
    maxHeap.push(35);
    maxHeap.push(65);

    cout << "Top element : " << maxHeap.top() << endl;

    maxHeap.pop();
    cout << "Top element : " << maxHeap.top() << endl;

    maxHeap.pop();
    maxHeap.pop();
    cout << "Top element : " << maxHeap.top() << endl;

    if(maxHeap.empty()) {
        cout << "Max Heap is empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Min_Heap_By_Priority_Queue.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;


int main() {
    priority_queue<int, vector<int>, greater<int> > minHeap;

    minHeap.push(52);
    minHeap.push(50);
    minHeap.push(54);
    minHeap.push(40);
    minHeap.push(35);
    minHeap.push(65);

    cout << "Top element : " << minHeap.top() << endl;

    minHeap.pop();
    cout << "Top element : " << minHeap.top() << endl;

    minHeap.pop();
    minHeap.pop();
    cout << "Top element : " << minHeap.top() << endl;

    if(minHeap.empty()) {
        cout << "Min Heap is empty!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Kth_Smallest_Element.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int KthSmallest(vector<int> arr, int K) {
    priority_queue<int> Heap;

    for(int i=0; i<K; i++) {
        Heap.push(arr[i]);
    }

    for(int i=K; i<arr.size(); i++) {
        if(arr[i] < Heap.top()) {
            Heap.pop();
            Heap.push(arr[i]);
        }
    }

    return Heap.top();
}

int main() {
    vector<int> arr;

    cout << "Enter the elements of array (-1 to stop) : ";
    int temp;
    cin >> temp;
    while(temp != -1) {
        arr.push_back(temp);
        cin >> temp;
    }

    int K;
    cout << "Enter the value of K : ";
    cin >> K;

    int answer = KthSmallest(arr, K);

    cout << "Kth smallest elements : " << answer<< endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Kth_Largest_Element.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int KthLargest(vector<int> arr, int K) {
    priority_queue<int, vector<int>, greater<int> > Heap;

    for(int i=0; i<K; i++) {
        Heap.push(arr[i]);
    }

    for(int i=K; i<arr.size(); i++) {
        if(arr[i] > Heap.top()) {
            Heap.pop();
            Heap.push(arr[i]);
        }
    }

    return Heap.top();
}

int main() {
    vector<int> arr;

    cout << "Enter the elements of array (-1 to stop) : ";
    int temp;
    cin >> temp;
    while(temp != -1) {
        arr.push_back(temp);
        cin >> temp;
    }

    int K;
    cout << "Enter the value of K : ";
    cin >> K;

    int answer = KthLargest(arr, K);

    cout << "Kth largest elements : " << answer<< endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Is_Binary_Tree_Heap.cpp


```cpp

#include <bits/stdc++.h>
#include "Tree.h"

using namespace std;

int countNodes(Node* root) {
    if(root == NULL) {
        return 0;
    }

    int left = countNodes(root->left);
    int right = countNodes(root->right);

    return left + right + 1;
}

bool isCBT(Node* root, int index, int cnt) {
    if(root == NULL) {
        return true;
    }

    if(index > cnt) {
        return false;
    }

    bool left = isCBT(root->left, 2*index + 1, cnt);
    bool right = isCBT(root->right, 2*index + 2, cnt);

    return left && right;
}

bool isMaxOrder(Node* root) {
    if(root == NULL) {
        return true;
    }

    if(root->left == NULL && root->right == NULL) {
        return true;
    }

    if(root->right == NULL) {
        return (root->data) > (root->left->data);
    }

    bool left = isMaxOrder(root->left);
    bool right = isMaxOrder(root->right);
    bool curr = (root->data > root->left->data) && (root->data > root->right->data);

    return left && right && curr;
}

bool isMinOrder(Node* root) {
    if(root == NULL) {
        return true;
    }

    if(root->left == NULL && root->right == NULL) {
        return true;
    }

    if(root->right == NULL) {
        return (root->data) < (root->left->data);
    }

    bool left = isMinOrder(root->left);
    bool right = isMinOrder(root->right);
    bool curr = (root->data < root->left->data) && (root->data < root->right->data);

    return left && right && curr;
}

bool checkMaxHeap(Node* root) {
    return isCBT(root, 0, countNodes(root)) && isMaxOrder(root);
}

bool checkMinHeap(Node* root) {
    return isCBT(root, 0, countNodes(root)) && isMaxOrder(root);
}

int main() {
    Node* root = NULL;

    root = buildTree(root);

    int isMaxHeapOrder = checkMaxHeap(root);
    int isMinHeapOrder = checkMinHeap(root);

    if(isMaxHeapOrder){
        cout << "Given Binary Tree is a Max Heap!" << endl;
    } else if(isMinHeapOrder) {
        cout << "Given Binary Tree is a Min Heap!" << endl;
    } else {
        cout << "Given Binary Tree is not a Heap!" << endl;
    }

    return 0;
}

/*
    40 20 10 -1 -1 15 -1 -1 25 -1 -1
    35 24 15 6 -1 -1 -1 11 -1 -1 29 -1 -1
    12 44 -1 -1 -1
    42 45 12 -1 -1 9 -1 -1 39 6 -1 -1 12 -1 -1
    13 14 16 -1 -1 17 -1 -1 15 -1 19 -1 -1
    20 25 27 -1 -1 29 -1 -1 -1
    40 42 49 -1 -1 -1 47 -1 -1
    34 77 140 -1 -1 90 -1 -1 97 100 -1 -1 120 -1 -1
    92 -1 -1
    42 40 35 -1 -1 -1 -1    
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Merge_2_MaxHeaps.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void heapify(vector<int> &arr, int index, int size) {
    int largest = index;
    int left = 2*index + 1;
    int right = 2*index + 2;

    if(left < size && arr[largest] < arr[left]) {
        largest = left;
    }

    if(right < size && arr[largest] < arr[right]) {
        largest = right;
    }

    if(largest != index) {
        swap(arr[index], arr[largest]);
        heapify(arr, largest, size);
    }
}

vector<int> mergeHeaps(vector<int> arr1, vector<int> arr2) {
    for(auto i : arr2) {
        arr1.push_back(i);
    }

    for(int i = arr1.size()/2 - 1; i >= 0; i--) {
        heapify(arr1, i, arr1.size());
    }

    return arr1;
}

int main() {
    vector<int> arr1, arr2;

    cout << "Enter the elements of first array (-1 to stop) : ";
    int temp;
    cin >> temp;
    while(temp != -1) {
        arr1.push_back(temp);
        cin >> temp;
    }

    cout << "Enter the elements of second array (-1 to stop) : ";
    cin >> temp;
    while(temp != -1) {
        arr2.push_back(temp);
        cin >> temp;
    }

    vector<int> result = mergeHeaps(arr1, arr2);

    cout << "Merged heap : ";
    for(int i=0; i<result.size(); i++) {
        cout << result[i] << " ";
    }

    return 0;
}

/*
    42 37 35 25 29 21 -1 93 34 65 11 -1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 5_Minimum_Cost_Of_Ropes.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int minimumCost(vector<int> arr) {
    priority_queue<int, vector<int>, greater<int> > minHeap;
    int cost = 0;

    for(auto i : arr) {
        minHeap.push(i);
    }

    while(minHeap.size() > 1) {
        int a = minHeap.top();
        minHeap.pop();

        int b = minHeap.top();
        minHeap.pop();

        int sum = a + b;
        cost += sum;
        minHeap.push(sum);
    }

    return cost;
}

int main() {
    vector<int> arr;

    cout << "Enter the elements of array (-1 to stop) : ";
    int temp;
    cin >> temp;
    while(temp != -1) {
        arr.push_back(temp);
        cin >> temp;
    }

    int cost = minimumCost(arr);

    cout << "Minimum cost to join all ropes = " << cost << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 6_BST_To_Min_Heap.cpp


```cpp

#include <bits/stdc++.h>
#include "Tree.h"

using namespace std;

void inorder(Node* root, vector<int> &arr) {
    if(root == NULL) {
        return;
    }

    inorder(root->left, arr);
    arr.push_back(root->data);
    inorder(root->right, arr);
}

void fillPreorder(Node* root, int &index, vector<int> arr) {
    if(root == NULL) {
        return;
    }

    if(index < arr.size()) {
        root->data = arr[index++];
    }

    fillPreorder(root->left, index, arr);
    fillPreorder(root->right, index, arr);
}

void BST_Heap(Node* root) {
    vector<int> arr;
    inorder(root, arr);
    int i = 0;
    fillPreorder(root, i, arr);
}

int main() {
    Node* root = NULL;    
    takeinput(root);

    cout << "Before converion into haep, BST : " << endl;
    levelOrderTraversal(root);

    BST_Heap(root);

    cout << "After converion into haep, BST : " << endl;
    levelOrderTraversal(root);

    return 0;
}

// 4 2 6 1 3 5 7 -1

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Kth_Largest_Sum_Of_Subarrays.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

// int KthLargestSumOfSubarrays(vector<int> arr, int K) {
//     vector<int> sumStore;
//     int size = arr.size();

//     for(int i=0; i<size; i++) {
//         int temp = 0;
//         for(int j=i; j<size; j++) {
//             temp += arr[j];
//             sumStore.push_back(temp);
//         }
//     }

//     sort(sumStore.begin(), sumStore.end());
//     return sumStore[sumStore.size() - K];
// }

int KthLargestSumOfSubarrays(vector<int> arr, int K) {
    priority_queue<int, vector<int>, greater<int> > sumStore;
    int size = arr.size();

    for(int i=0; i<size; i++) {
        int temp = 0;
        for(int j=i; j<size; j++) {
            temp += arr[j];
            
            if(sumStore.size() < K) {
                sumStore.push(temp);
            } else {
                if(temp > sumStore.top()) {
                    sumStore.pop();
                    sumStore.push(temp);
                }
            }
        }
    }

    return sumStore.top();
}

int main() {
    vector<int> arr;

    cout << "Enter the elements of array (-1 to stop) : ";
    int temp;
    cin >> temp;
    do {
        arr.push_back(temp);
        cin >> temp;
    } while(temp != -1);

    int K;
    cout << "Enter the value of K : ";
    cin >> K;

    int largestSum = KthLargestSumOfSubarrays(arr, K);

    cout << "The kth largest sum of subarrays : " << largestSum;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Merge_K_Sorted_Arrays.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
        int data;
        int row, col;

        Node(int data, int row, int col) {
            this->data = data;
            this->row = row;
            this->col = col;
        }
};

class compare {
    public:
        bool operator () (Node* a, Node* b) {
            return a->data > b->data;
        }
};

vector<int> mergeSortedArrays(vector<vector<int> > kArrays, int K) {
    priority_queue<Node*, vector<Node*>, compare> minHeap;

    // Step 1 : Insert all first elements in minHeap
    for(int row=0; row<K; row++) {
        Node* temp = new Node(kArrays[row][0], row, 0);
        minHeap.push(temp);
    }

    vector<int> ans;

    // Step 2 : Comparing each node and moving further in the array
    while(minHeap.size() > 0) {
        Node* temp = minHeap.top();

        ans.push_back(temp->data);
        minHeap.pop();

        int row = temp->row;
        int col = temp->col;

        if(col+1 < kArrays[row].size()) {
            Node* next = new Node(kArrays[row][col+1], row, col+1);
            minHeap.push(next);
        }
    }

    return ans;
}

int main() {
    vector< vector<int> > kArrays;
    int K;

    cout << "Enter the value of K : ";
    cin >> K;

    for(int i=0; i<K; i++) {
        vector<int> curr;

        cout << "Enter the elements of array (-1 to stop) : ";
        int temp;
        cin >> temp;
        do {
            curr.push_back(temp);
            cin >> temp;
        } while(temp != -1);

        kArrays.push_back(curr);
    }
    
    vector<int> mergedArray = mergeSortedArrays(kArrays, K);

    cout << "Merged array : ";
    for(auto i : mergedArray) {
        cout << i << " ";
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Merge_K_Sorted_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class List {
    public:
        int data;
        List* next;

        List(int data) {
            this->data = data;
            this->next = NULL;
        }
};

void insert(List* &head, List* &tail, int val) {
    List* temp = new List(val);
    if(head == NULL) {
        head = tail = temp;
    } else {
        tail->next = temp;
        tail = temp;
    }
}

class compare {
    public:
        bool operator () (List* a, List* b) {
            return a->data > b->data;
        }
};

List* mergeSortedLists(vector<List* > kLists) {
    priority_queue<List*, vector<List*>, compare> minHeap;
    int K = kLists.size();

    // Empty list
    if(K == 0) {
        return NULL;
    }

    // Step 1 : Creating a Min Heap
    for(int i=0; i<K; i++) {
        if(kLists[i] != NULL) {
            minHeap.push(kLists[i]);
        }
    }

    List* head = NULL;
    List* tail = NULL;

    // Step 2 : Comparing next nodes
    while(minHeap.size() > 0) {
        List* top = minHeap.top();
        minHeap.pop();

        if(top->next != NULL) {
            minHeap.push(top->next);
        }

        if(head == NULL) {
            head = tail = top;
        } else {
            tail->next = top;
            tail = top;
        }
    }

    return head;
}

int main() {
    vector<List*> kLists;
    int K;

    cout << "Enter the value of K : ";
    cin >> K;

    for(int i=0; i<K; i++) {
        List* head = NULL;
        List* tail = NULL;
        
        cout << "Enter the values of list (-1 to stop) : ";
        int val;
        cin >> val;
        do {
            insert(head, tail, val);
            cin >> val;
        } while(val != -1);

        kLists.push_back(head);
    }

    List* head = mergeSortedLists(kLists);

    List* temp = head;
    cout << "Merged List : ";
    while(temp != NULL) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Smallest_Range_In_K_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Node {
    public:
        int data;
        int row, col;

        Node(int data, int row, int col) {
            this->data = data;
            this->row = row;
            this->col = col;
        }
};

class compare {
    public:
        bool operator () (Node* a, Node* b) {
            return a->data > b->data;
        }
};

int smallestRange(vector<vector<int> > kArrays, int K, int N) {
    priority_queue<Node*, vector<Node*>, compare> minHeap;
    int mini = INT_MAX, maxi = INT_MIN;


    // Step 1 : Creating a Min Heap for starting element of each list and tracking mini/maxi value of each list
    for(int row=0; row<K; row++) {
        int element = kArrays[row][0];
        mini = min(mini, element);
        maxi = max(maxi, element);
        minHeap.push(new Node(element, row, 0));
    }

    int start = mini, end = maxi;

    // Step 2 : process ranges
    while(!minHeap.empty()) {

        // fetching minimum element
        Node* temp = minHeap.top();
        minHeap.pop();

        mini = temp->data;

        // range or answer updation
        if(maxi - mini < end - start) {
            start = mini;
            end = maxi;
        }

        // checking whether next element exists or not
        if(temp->col < N) {
            maxi = max(maxi, kArrays[temp->row][temp->col + 1]);
            minHeap.push(new Node(kArrays[temp->row][temp->col + 1], temp->row, temp->col + 1));
        } else {
            break;
        }
    }

    return (end - start) + 1;
}

int main() {
    vector< vector<int> > kArrays;
    int K, N;

    cout << "Enter the value of K : ";
    cin >> K;

    cout << "Enter the size of each array : ";
    cin >> N;

    for(int i=0; i<K; i++) {
        vector<int> curr(N);

        cout << "Enter the elements of array : ";
        for(int j=0; j<N; j++) {
            cin >> curr[j];
        }

        kArrays.push_back(curr);
    }
    
    int range = smallestRange(kArrays, K, N);

    cout << "Smallest range in the given sorted lists : " << range << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Median_In_A_Stream.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int signum(int a, int b) {
    return (a==b) ? 0 : (a>b ? 1 : -1);
}

void callMedian(int element, priority_queue<int> &maxHeap, priority_queue<int, vector<int>, greater<int> > &minHeap, int &median) {

    switch(signum(maxHeap.size(), minHeap.size())) {

        case 0 :
            if(element > median) {
                minHeap.push(element);
                median = minHeap.top();
            } else {
                maxHeap.push(element);
                median = maxHeap.top();
            }
            break;

        case 1 : 
            if(element > median) {
                minHeap.push(element);
            } else {
                minHeap.push(maxHeap.top());
                maxHeap.pop();
                maxHeap.push(element);
            }
            median = (minHeap.top() + maxHeap.top()) / 2;
            break;
            
        case -1 :
            if(element > median) {
                maxHeap.push(minHeap.top());
                minHeap.pop();
                minHeap.push(element);
            } else {
                maxHeap.push(element);
            }
            median = (minHeap.top() + maxHeap.top()) / 2;
            break;

    }

}

vector<int> findMedian(vector<int>& arr, int N) {
    vector<int> ans;
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int> > minHeap;
    int median = 0;

    for(int i=0; i<N; i++) {
        callMedian(arr[i], maxHeap, minHeap, median);
        ans.push_back(median);
    }

    return ans;
}

int main() {
    int N;

    cout << "Enter the size of the array : ";
    cin >> N;
    vector<int> arr(N);

    cout << "Enter the elements of array : ";
    for(int i=0; i<N; i++) {
        cin >> arr[i];
    }

    vector<int> ans = findMedian(arr, N);

    cout << "Median : " << ans[ans.size()-1] << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Unordered_Map.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;    

int main() {
    // Creation
    map<string, int> M;

    // Insertion

    // 1
    pair<string, int> pair1 = make_pair("white", 2);
    M.insert(pair1);

    // 2
    pair<string, int> pair2("black", 3);
    M.insert(pair2);

    // 3
    M["red"] = 4;

    // Printing
    cout << "Before updation : white = " << M["white"] << endl;

    // Updation
    M["white"] = 10;    
    cout << "After updation : white = " << M.at("white") << endl;

    // cout << M.at("orange") << endl;
    cout << M["orange"] << endl;

    // Size
    cout << "Size : " << M.size() << endl;

    // Check presence
    cout << M.count("yellow") << endl;
    cout << M.count("white") << endl;

    // Removal
    M.erase("white");
    cout << "Size : " << M.size() << endl;

    // Traversal
    for(auto i : M) {
        cout << i.first << " & " << i.second << endl;
    }

    // Iterator
    /*
    unordered_map<string, int> :: iterator it = M.begin();
    while(it != M.end()) {
        cout << it.first << " , " << it.second << endl;
        it++;
    }
    */
    
    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Maximum_Frequency_Number.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int maximumFrequency(vector<int> arr, int n) {
    unordered_map<int, int> M;

    int maxi = INT_MIN;

    for(int i=0; i<n; i++) {
        M[arr[i]]++;
        maxi = max(maxi, M[arr[i]]);
    }

    for(int i=0; i<n; i++) {
        if(M[arr[i]] == maxi) {
            return arr[i];
        }
    }
}

int main() {
    vector<int> arr;

    cout << "Enter the elements of arr (-1 to stop) : ";
    int data;
    cin >> data;
    while(data != -1) {
        arr.push_back(data);
        cin >> data;
    }

    int ans = maximumFrequency(arr, arr.size());

    cout << "Elemnet with maximum frequency : " << ans << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Trie_Intro.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class TrieNode {
    public:
        char data;
        TrieNode* children[26];
        bool isTerminal;

        TrieNode(char ch) {
            this->data = ch;
            this->isTerminal = false;

            for(int i=0; i<26; i++) {
                this->children[i] = NULL;
            }
        }
};

class Trie {
    public :
        TrieNode* root;

        Trie() {
            root = new TrieNode('\0');
        }

        void insertUtil(TrieNode* &root, string word) {
            if(word.length() == 0) {
                root->isTerminal = true;
                return;
            }

            // Assumption : Word will be in CAPS
            int index = word[0] - 'A';
            TrieNode* child;

            if(root->children[index] != NULL) {
                // Character Present
                child = root->children[index];
            } else {
                // Character Absent
                child = new TrieNode(word[0]);
                root->children[index] = child;
            }

            // Recursion
            insertUtil(child, word.substr(1));
        }

        void insertNode(string word) {
            insertUtil(root, word);
        }

        bool searchUtil(TrieNode* root, string word) {
            // Base case
            if(word.length() == 0) {
                return root->isTerminal;
            }

            // Finding index through mapping
            int index = word[0] - 'A';
            TrieNode* child;

            if(root->children[index] != NULL) {
                // Present
                child = root->children[index];
            } else {
                // Absent
                return false;
            }

            return searchUtil(child, word.substr(1));
        }

        bool search(string word) {
            return searchUtil(root, word);
        }

        bool removeUtil(TrieNode* root, string word) {
            // Base case
            if(word.length() == 0) {
                if(root->isTerminal) {
                    root->isTerminal = false;
                    return true;
                } else {
                    return false;
                }
            }

            // Finding index through mapping
            int index = word[0] - 'A';
            TrieNode* child;

            if(root->children[index] != NULL) {
                // Present
                child = root->children[index];
            } else {
                // Absent
                return false;
            }

            return removeUtil(child, word.substr(1));
        }

        bool remove(string word) {
            return removeUtil(root, word);
        }

        bool eraseUtil(TrieNode* root, string word) {
            // Base case
            if(word.length() == 0) {
                if(root->isTerminal) {
                    root->isTerminal = false;
                    delete root;
                    return true;
                } else {
                    return false;
                }
            }

            // Finding index through mapping
            int index = word[0] - 'A';
            TrieNode* child;

            if(root->children[index] != NULL) {
                // Present
                child = root->children[index];
            } else {
                // Absent
                return false;
            }

            bool ans = eraseUtil(child, word.substr(1));
            delete child;
            return ans;
        }

        bool erase(string word) {
            return eraseUtil(root, word);
        }
};

int main() {

    Trie* T = new Trie();

    T->insertNode("AKASH");

    bool present = T->search("AKASH");

    if(present) {
        cout << "Word is Present!" << endl;
    } else {
        cout << "Word is Absent!" << endl;
    }

    T->erase("AKASH");
    present = T->search("AKASH");

    if(present) {
        cout << "Word is Present!" << endl;
    } else {
        cout << "Word is Absent!" << endl;
    }

    cout << T->root->children[0]->data << endl;
    T->insertNode("AKASH");
    present = T->search("AKASH");

    if(present) {
        cout << "Word is Present!" << endl;
    } else {
        cout << "Word is Absent!" << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Longest_Common_Prefix_By_Comparisons.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

string longestCommonPrefix(vector<string> str) {
    string ans = "";
    for(int i=0; i<str[0].length(); i++) {
        char curr = str[0].at(i);

        // For comparison of current character with remaining string;
        for(int j=1; j<str.size(); j++) {
            if(str[j].at(i) != curr) {
                return ans;
            }
        }

        ans += curr;
    }

    return ans;
}

int main() {
    vector<string> str;

    cout << "Enter the strings (-1 to stop) : ";
    while(1) {
        string temp;
        cin >> temp;
        
        if(temp == "-1") {
            break;
        }

        str.push_back(temp);
    }

    string ans = longestCommonPrefix(str);

    cout << "Longest common prefix : " << ans << endl;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Longest_Common_Prefix_By_Tries.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class TrieNode {
    public:
        char data;
        TrieNode* children[26];
        bool isTerminal;
        int childCount;

        TrieNode(char data) {
            this->data = data;
            this->isTerminal = false;
            this->childCount = 0;

            for(int i=0; i<26; i++) {
                this->children[i] = NULL;
            }
        }
};

class Trie {
    public:
        TrieNode* root;

        Trie() {
            root = new TrieNode('\0');
        }

        void insertUtil(TrieNode* root, string word) {
            if(word.length() == 0) {
                root->isTerminal = true;
                return;
            }

            // Assuming the string is in lowercase
            int index = word[0] - 'a';
            TrieNode* child;

            if(root->children[index] == NULL) { 
                child = new TrieNode(word[0]);
                root->childCount++;
                root->children[index] = child;
            } else {
                child = root->children[index];
            }

            insertUtil(child, word.substr(1));
        }

        void insertNode(string word) {
            insertUtil(root, word);
        }
};

string longestCommonPrefix(vector<string> str) {
    string ans = "";
    Trie* t = new Trie();

    // insert all strings in trie;
    for(int i=0; i<str.size(); i++) {
        t->insertNode(str[i]);
    }

    TrieNode* temp = t->root;

    for(int i=0; i<str[0].length(); i++) {
        if(temp->childCount == 1) {
            ans.push_back(str[0][i]);

            int index = str[0][i] - 'a';
            temp = temp->children[index];
        } else {
            break;
        }

        if(temp->isTerminal) {
            break;
        }
    }

    return ans;
}

int main() {
    vector<string> str;

    cout << "Enter the strings (-1 to stop) : ";
    while(1) {
        string temp;
        cin >> temp;
        
        if(temp == "-1") {
            break;
        }

        str.push_back(temp);
    }

    string ans = longestCommonPrefix(str);

    cout << "Longest common prefix : " << ans << endl;

    return 0; 
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Phone_Directory.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class TrieNode {
    public:
        char data;
        TrieNode* children[26];
        bool isTerminal;

        TrieNode(char ch) {
            data = ch;
            isTerminal = false;

            for(int i=0; i<26; i++) {
                children[i] = NULL;
            }
        }
};

class Trie {
    public:
        TrieNode* root;

        Trie() {
            root = new TrieNode('\0');
        }

        void insertUtil(TrieNode* &root, string word) {
            if(word.length() == 0) {
                root->isTerminal = true;
                return;
            }

            TrieNode* child;
            int index = word[0] - 'a';

            if(root->children[index] == NULL) {
                child = new TrieNode(word[0]);
                root->children[index] = child;
            } else {
                child = root->children[index];
            }

            insertUtil(child, word.substr(1));
        }

        void insertNode(string word) {
            insertUtil(root, word);
        }
};

void printSuggetions(TrieNode* curr, vector<string> &temp, string prefix) {
    // Terminal Node - Suggestion Found
    if(curr->isTerminal) {
        temp.push_back(prefix);
    }

    for(char ch = 'a'; ch <= 'z'; ch++) {
        TrieNode* next = curr->children[ch - 'a'];

        if(next != NULL) {
            prefix.push_back(ch);
            printSuggetions(next, temp, prefix);
            prefix.pop_back();
        }
    }
}

vector< vector<string> > getSuggestions(TrieNode* root, string query) {
    vector< vector<string> > answer;
    TrieNode* prev = root;
    string prefix = "";

    for(int i=0; i<query.length(); i++) {
        char lastChar = query[i];
        prefix.push_back(lastChar);

        // Check for last character
        TrieNode* curr = prev->children[lastChar - 'a'];

        // Not found
        if(curr == NULL) {
            break;
        }

        // Found
        vector<string> temp;
        printSuggetions(curr, temp, prefix);
        answer.push_back(temp);
        temp.clear();
        prev = curr;
    }

    return answer;
}

vector< vector<string> > phoneDirectory(vector<string> contactList, string query) {
    // Creation of trie
    Trie* T = new Trie();

    // Insert all strings in trie
    for(int i=0; i<contactList.size(); i++) {
        T->insertNode(contactList[i]);
    }

    // Return function
    return getSuggestions(T->root, query);
}

int main() {
    vector<string> contactList;
    string query;
    vector< vector<string> > suggestions;

    string temp;
    cout << "Enter the strings (-1 to stop) : ";
    cin >> temp;
    while(temp != "-1") {
        contactList.push_back(temp);
        cin >> temp;
    }

    cout << "Enter the query string : ";
    cin >> query;

    suggestions = phoneDirectory(contactList, query);

    for(vector<string> x : suggestions) {
        for(string y : x) {
            cout << y << " ";
        }
        cout << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Rat_In_A_Maze.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isSafe(vector< vector<int> > maze, vector< vector<int> > visited, int n, int newX, int newY) {
    return ((newX >= 0) && (newX < n) && (newY >= 0) && (newY < n) && (maze[newX][newY] == 1) && (visited[newX][newY] == 0));
}

void paths(vector<string> &answer, vector< vector<int> > &maze, vector< vector<int> > &visited, string path, int x, int y, int n) {
    if(x == n-1 && y == n-1) {
        answer.push_back(path);
        return;
    }

    int newX, newY;

    // Down Movement - 'D'
    newX = x+1;
    newY = y;
    if(isSafe(maze, visited, n, newX, newY)) {
        visited[newX][newY] = 1;
        path.push_back('D');
        paths(answer, maze, visited, path, newX, newY, n);
        visited[newX][newY] = 0;
        path.pop_back();
    }

    // Left Movement - 'L'
    newX = x;
    newY = y-1;
    if(isSafe(maze, visited, n, newX, newY)) {
        visited[newX][newY] = 1;
        paths(answer, maze, visited, path+'L', newX, newY, n);
        visited[newX][newY] = 0;
    }

    // Right Movement - 'R'
    newX = x;
    newY = y+1;
    if(isSafe(maze, visited, n, newX, newY)) {
        visited[newX][newY] = 1;
        paths(answer, maze, visited, path+'R', newX, newY, n);
        visited[newX][newY] = 0;
    }

    // Up Movement - 'U'
    newX = x-1;
    newY = y;
    if(isSafe(maze, visited, n, newX, newY)) {
        visited[newX][newY] = 1;
        paths(answer, maze, visited, path+'U', newX, newY, n);
        visited[newX][newY] = 0;
    }
}

vector<string> searchMaze(vector< vector<int> > &arr, int n) {
    vector< vector<int> > visited(n, vector<int> (n,0));
    vector<string> answer;

    if(arr[0][0] != 0) {
        paths(answer, arr, visited, "", 0, 0, n);
    }

    return answer;
}

int main() {
    vector< vector<int> > maze;
    int n = 4;

    cout << "Enter the maze : " << endl;
    for(int i=0; i<n; i++) {
        vector<int> temp(n);
        for(int j=0; j<n; j++) {
            cin >> temp[j];
        }
        maze.push_back(temp);
    }

    vector<string> path = searchMaze(maze, n);

    cout << "All possible paths : ";
    for(string s : path) {
        cout << s << " ";
    }

    return 0;
}

/*
1 0 0 0
1 1 0 0
1 1 0 0
0 1 1 1
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_N_Queens.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void addSolution(vector< vector<int> > board, vector< vector<int> > &sol) {
    vector<int> temp;
    for(vector<int> x : board) {
        for(int y : x) {
            temp.push_back(y);
        }
    }
    sol.push_back(temp);
}

bool isSafe(int row, int col, vector< vector<int> > board, int n) {
    // Checking for same row
    for(int j=col; j>=0; j--) {
        if(board[row][j] == 1) {
            return false;
        }
    }

    // Checking for left upper diagonal
    for(int i=row, j=col; i>=0 && j>=0; i--, j--) {
        if(board[i][j] == 1) {
            return false;
        }
    }
    
    // Checking for left lower diagonal
    for(int i=row, j=col; i<n && j>=0; i++, j--) {
        if(board[i][j] == 1) {
            return false;
        }
    }

    return true;
}

void solve(int col, vector< vector<int> > &solution, vector< vector<int> > &board, int n) {
    // Base Case
    if(col == n) {
        addSolution(board, solution);
        return;
    }

    for(int row = 0; row < n; row++) {
        if(isSafe(row, col, board, n)) {
            board[row][col] = 1;
            solve(col+1, solution, board, n);

            // Backtracking
            board[row][col] = 0;
        }
    }
}

vector< vector<int> > nQueens(int n) {
    vector< vector<int> > solution;
    vector< vector<int> > board(n, vector<int> (n,0));

    solve(0, solution, board, n);
    return solution;
}

int main() {
    int n;
    cout << "Enter the value of n : ";
    cin >> n;

    vector< vector<int> > solution = nQueens(n);
    int i = 0;

    for(vector<int> x : solution) {
        cout << endl << "Possible Configuration [" << ++i << "] : ";
        for(int y : x) {
            cout << y << " ";
        }
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_N_Queens_HashMap.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

map<int, bool> rowCheck;
map<int, bool> upperCheck;
map<int, bool> lowerCheck;

void addSolution(vector< vector<int> > board, vector< vector<int> > &sol) {
    vector<int> temp;
    for(vector<int> x : board) {
        for(int y : x) {
            temp.push_back(y);
        }
    }
    sol.push_back(temp);
}

bool isSafe(int row, int col, int n) {
    return !(rowCheck[row] == true || lowerCheck[row+col] == true || upperCheck[n+row-col] == true);
}

void solve(int col, vector< vector<int> > &solution, vector< vector<int> > &board, int n) {
    // Base Case
    if(col == n) {
        addSolution(board, solution);
        return;
    }

    for(int row = 0; row < n; row++) {
        if(isSafe(row, col, n)) {
            // Setting Queen
            board[row][col] = 1;

            // Mapping Queen
            rowCheck[row] = true;
            lowerCheck[row+col] = true;
            upperCheck[n+row-col] = true;

            // Recursive Call
            solve(col+1, solution, board, n);

            // Backtracking
            board[row][col] = 0;
            rowCheck[row] = false;
            lowerCheck[row+col] = false;
            upperCheck[n+row-col] = false;
        }
    }
}

vector< vector<int> > nQueens(int n) {
    vector< vector<int> > solution;
    vector< vector<int> > board(n, vector<int> (n,0));

    solve(0, solution, board, n);
    return solution;
}

int main() {
    int n;
    cout << "Enter the value of n : ";
    cin >> n;

    vector< vector<int> > solution = nQueens(n);
    int i = 0;

    for(vector<int> x : solution) {
        cout << endl << "Possible Configuration [" << ++i << "] : ";
        for(int y : x) {
            cout << y << " ";
        }
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Valid_Suduko.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isSafe(int row, int col, vector< vector<int> > suduko, int val) {
    for(int i=0; i<9; i++) {
        // Row check
        if(suduko[row][i] == val) {
            return false;
        }

        // Column Check
        if(suduko[i][col] == val) {
            return false;
        }

        // 3x3 Matrix Check
        if(suduko[3*(row/3) + i/3][3*(col/3) + i%3] == val) {
            return false;
        }
    }

    return true;
}

bool solve(vector< vector<int> > &suduko) {
    for(int row=0; row<9; row++) {
        for(int col=0; col<9; col++) {
            
            // Empty Cell
            if(suduko[row][col] == 0) {

                for(int val=1; val<=9; val++) {
                    if(isSafe(row, col, suduko, val)) {
                        suduko[row][col] = val;

                        bool nextSol = solve(suduko);
                        if(nextSol) {
                            return true;
                        } else {
                            suduko[row][col] = 0;
                        }

                    }
                }

                return false;
            }

        }
    }

    return true;
}

void validSuduko(vector< vector<int> > &suduko) {
    solve(suduko);
}

int main() {
    vector< vector<int> > suduko(9, vector<int> (9,0));

    cout << "Enter the suduko : " << endl;
    for(int i=0; i<9; i++) {
        for(int j=0; j<9; j++) {
            cin >> suduko[i][j];
        }
    }

    validSuduko(suduko);

    cout << "Solved Suduko : " << endl;
    for(int i=0; i<9; i++) {
        for(int j=0; j<9; j++) {
            cout << suduko[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}

/*
3 0 6 5 0 8 4 0 0
5 2 0 0 0 0 0 0 0
0 8 7 0 0 0 0 3 1
0 0 3 0 1 0 0 8 0
9 0 0 8 6 3 0 0 5
0 5 0 0 9 0 6 0 0
1 3 0 0 0 0 2 5 0
0 0 0 0 0 0 0 7 4
0 0 5 2 0 6 3 0 0
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Adjacency_List.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Graph {
    public:
        unordered_map<int, list<int> > adj;

        void addEdge(int u, int v, bool direction) {
            // direction = false -> undirected graph
            // direction = true -> directed graph

            // create an edge from u to v
            adj[u].push_back(v);

            if(direction == false) {
                adj[v].push_back(u);
            }
        }

        void printAdjList(){
            for(auto i : adj) {
                cout << i.first << " -> ";

                for(auto j : i.second) {
                    cout << j << " ";
                }

                cout << endl;
            }
        }
};

int main() {

    int n, m;

    cout << "Enter the number of nodes : ";
    cin >> n;

    cout << "Enter the number of edges : ";
    cin >> m;


    Graph G;

    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        G.addEdge(u, v, 0);
    }

    // Printing graph
    G.printAdjList();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Adjacency_List_General.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

template <typename T>

class Graph {
    public:
        unordered_map<T, list<T> > adj;

        void addEdge(T u, T v, bool direction) {
            // direction = false -> undirected graph
            // direction = true -> directed graph

            // create an edge from u to v
            adj[u].push_back(v);

            if(direction == false) {
                adj[v].push_back(u);
            }
        }

        void printAdjList(){
            for(auto i : adj) {
                cout << i.first << " -> ";

                for(auto j : i.second) {
                    cout << j << " ";
                }

                cout << endl;
            }
        }
};

int main() {

    int n, m;

    cout << "Enter the number of nodes : ";
    cin >> n;

    cout << "Enter the number of edges : ";
    cin >> m;


    Graph<int> G;

    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        G.addEdge(u, v, 0);
    }

    // Printing graph
    G.printAdjList();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 3_Adjacency_Matrix.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Graph {
    public:
        vector< vector<int> > adjMat;

        Graph(int nodeCount) {
            adjMat = vector < vector<int> > (nodeCount, vector<int> (nodeCount, 0));
        }

        void addEdge(int u, int v, bool direction) {
            // direction = false -> undirected graph
            // direction = true -> directed graph

            // create an edge from u to v
            adjMat[u][v] = 1;

            if(direction == false) {
                adjMat[v][u] = 1;
            }
        }

        void printAdjMatrix(){
            for(int i=0; i<adjMat.size(); i++) {
                cout << i << " -> ";

                for(int j=0; j<adjMat.size(); j++) {
                    cout << adjMat[i][j] << " ";
                }

                cout << endl;
            }
        }
};

int main() {

    int n, m;

    cout << "Enter the number of nodes : ";
    cin >> n;

    cout << "Enter the number of edges : ";
    cin >> m;

    Graph G(n);

    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        G.addEdge(u, v, 0);
    }

    // Printing graph
    G.printAdjMatrix();

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 4_Create_Graph_And_Print_It.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector< vector<int> > printAdjacency(int n, int m, vector< vector<int> > &edges) {
    vector< vector<int> > solution(n);

    for(int i=0; i<n; i++) {
        solution[i].push_back(i);
    }

    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        
        solution[u].push_back(v);
        solution[v].push_back(u);
    }

    return solution;
}

int main() {
    int n, m;

    cout << "Enter the number of nodes : ";
    cin >> n;

    cout << "Enter the number of edges : ";
    cin >> m;

    vector< vector<int> > edges(m, {0,0});

    for(int i=0; i<m; i++) {
        cin >> edges[i][0];
        cin >> edges[i][1];
    }

    vector< vector<int> > solution = printAdjacency(n, m, edges);

    for(auto i : solution) {
        for(auto j : i) {
            cout << j << " ";
        }
        cout << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_BFS_Traversal.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void traversal(unordered_map<int, list<int> > &adjList, unordered_map<int, bool> &visited, vector<int> &answer, int node) {
    queue<int> Q;
    Q.push(node);
    visited[node] = 1;

    while(!Q.empty()) {
        int frontVal = Q.front();
        Q.pop();
        visited[frontVal] = true;
        answer.push_back(frontVal);

        for(auto i : adjList[frontVal]) {
            if(!visited[i]) {
                Q.push(i);
            }
        }
    }
}

vector<int> BFS(int vertex, vector< pair<int, int> > edges) {
    unordered_map<int, list<int> > adjList;
    vector<int> answer;
    unordered_map<int, bool> visited;
    
    // Creating Adjacency List
    for(int i=0; i<edges.size( ); i++) {
        int u = edges[i].first;
        int v = edges[i].second;

        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    // Traversing all components of a graph
    for(int i=0; i<vertex; i++) {
        if(!visited[i]) {
            traversal(adjList, visited, answer, i);
        }
    }

    return answer;
}

int main() {
    int n, m;

    cout << "Enter the number of nodes : ";
    cin >> n;

    cout << "Enter the number of edges : ";
    cin >> m;

    vector< pair<int,int> > edges(m, {0,0});

    for(int i=0; i<m; i++) {
        cin >> edges[0].first;
        cin >> edges[0].second;
    }

    vector<int> solution = BFS(n, edges);

    cout << "BFS Traversal : ";
    for(auto i : solution) {
        cout << i << " ";
    }
    cout << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_DFS_Traversal.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void traversal(unordered_map<int, list<int> > &adjList, unordered_map<int, bool> &visited, vector<int> &component, int node) {
    component.push_back(node);
    visited[node] = 1;

    for(auto i : adjList[node]) {
        if(!visited[i]) {
            traversal(adjList, visited, component, i);
        }
    }

}

vector< vector<int> > DFS(int V, int E, vector< vector<int> > &edges) {
    unordered_map<int, list<int> > adjList;
    vector< vector<int> > answer;
    unordered_map<int, bool> visited;
    
    // Creating Adjacency List
    for(int i=0; i<edges.size( ); i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    // Traversing all components of a graph
    for(int i=0; i<V; i++) {
        if(!visited[i]) {
            vector<int> component;
            traversal(adjList, visited, component, i);
            answer.push_back(component);
        }
    }

    return answer;
}

int main() {
    int n, m;

    cout << "Enter the number of nodes : ";
    cin >> n;

    cout << "Enter the number of edges : ";
    cin >> m;

    vector< vector<int> > edges(m, {0,0});

    for(int i=0; i<m; i++) {
        cin >> edges[i][0];
        cin >> edges[i][1];
    }

    vector< vector<int> > solution = DFS(n, m, edges);

    cout << "DFS Traversal : ";
    for(auto i : solution) {
        for(auto j : i) {
            cout << j << " ";
        }
        cout << endl;
    }

    /*
    for(int i=0; i<solution.size(); i++) {
        for(int j=0; j<solution.size(); j++) {
            cout << solution[i][j] << " ";
        }
        cout << endl;
    }
    */

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Cycle_Detection_In_Undirected_Graph_Using_BFS.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isCyclicBFS(unordered_map<int, list<int> > &adjList, unordered_map<int, bool> &visited, int Node) {
    unordered_map<int, int> parent;
    parent[Node] = -1;
    visited[Node] = true;

    queue<int> Q;
    Q.push(Node);

    while(!Q.empty()) {
        int FrontVal = Q.front();
        Q.pop();

        for(int i : adjList[FrontVal]) {
            if(visited[i] == true && parent[FrontVal] != i) {
                return true;
            }

            if(visited[i] == false) {
                visited[i] = true;
                parent[i] = FrontVal;
                Q.push(i);
            }
        }
    }

    return false;
}

string cycleDetection(vector<vector<int> > &edges, int n, int m) {
    unordered_map<int, list<int> > adjList;
    unordered_map<int, bool> visited;

    // Creating Adjacency List
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    for(int i=1; i<=n; i++) {
        if(visited[i] == false) {
            bool ans = isCyclicBFS(adjList, visited, i);
            
            if(ans) {
                return "YES";
            }
        }
    }

    return "NO";
}

int main() {
    int n, m;
    vector<vector<int> > edges;

    cout << "Enter the total number of nodes : ";
    cin >> n;

    cout << "Enter total number of edges : ";
    cin >> m;

    cout << "Enter edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    string ans = cycleDetection(edges, n, m);

    cout << "Cycle Detection Result : " << ans << endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Cycle_Detection_In_Undirected_Graph_Using_DFS.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool isCyclicDFS(unordered_map<int, list<int> > &adjList, unordered_map<int, bool> &visited, int Node, int parent) {
    visited[Node] = true;

    for(auto i : adjList[Node]) {
        if(visited[i] == false) {
            bool isCycle = isCyclicDFS(adjList, visited, i, Node);

            if(isCycle) {
                return true;
            }
        } else if(i != parent) {
            return true;
        }
    }

    return false;
}

string cycleDetection(vector<vector<int> > &edges, int n, int m) {
    unordered_map<int, list<int> > adjList;
    unordered_map<int, bool> visited;

    // Creating Adjacency List
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    for(int i=1; i<=n; i++) {
        if(visited[i] == false) {
            bool ans = isCyclicDFS(adjList, visited, i, -1);
            
            if(ans) {
                return "YES";
            }
        }
    }

    return "NO";
}

int main() {
    int n, m;
    vector<vector<int> > edges;

    cout << "Enter the total number of nodes : ";
    cin >> n;

    cout << "Enter total number of edges : ";
    cin >> m;

    cout << "Enter edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    string ans = cycleDetection(edges, n, m);

    cout << "Cycle Detection Result : " << ans << endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Cycle_Detection_In_Directed_Graph.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

/*
int isCyclicDFS(unordered_map<int, list<int> > &adjList, vector<int> &visited, vector<int> &dfsVisited, int Node) {
    if(visited[Node] == 1 && dfsVisited[Node] == 1) {
        return Node;
    }

    visited[Node] = dfsVisited[Node] = 1;

    for(int x : adjList[Node]) {
        int ans = isCyclicDFS(adjList, visited, dfsVisited, x);

        if(ans != -1) {
            return ans;
        }
    }

    dfsVisited[Node] = 0;
    return -1;
}
*/

bool isCyclicDFS(unordered_map<int, list<int> > &adjList, vector<int> &visited, vector<int> &dfsVisited, int Node) {
    visited[Node] = dfsVisited[Node] = 1;

    for(int x : adjList[Node]) {
        if(visited[x] == 0) {
        bool ans = isCyclicDFS(adjList, visited, dfsVisited, x);

            if(ans) {
                return true;
            }
        } else if(dfsVisited[x] == 1) {
            return true;
        }
    }

    dfsVisited[Node] = 0;
    return false;
}

bool detectCyclicInDirectedGraph(int n, vector< pair<int,int> > &edges) {
    unordered_map<int, list<int> > adjList;
    for(int i=0; i<edges.size(); i++) {
        int u = edges[i].first;
        int v = edges[i].second;
        adjList[u].push_back(v);
    }

    vector<int> visited(n, 0);
    vector<int> dfsVisited(n, 0);

    for(int i=0; i<n; i++) {
        if(visited[i] == 0) {
            int ans = isCyclicDFS(adjList, visited, dfsVisited, i);

            if(ans) {
                return true;
            }
        }
    }

    return false;
}

int main() {
    vector< pair<int,int> > edges;
    int n, m;

    cout << "Enter number of nodes : ";
    cin >> n;

    cout << "Enter number of edges : ";
    cin >> m;

    cout << "Enter edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    bool answer = detectCyclicInDirectedGraph(n, edges);

    if(answer) {
        cout << "Cycle is Present" << endl;
    } else {
        cout << "Cycle is Not Present" << endl;
    }

    return 0;
}

// 8 9 0 1 1 2 2 6 2 7 7 6 1 3 3 4 4 5 5 3 - YES
// 8 9 0 1 1 2 2 6 2 7 7 6 1 3 3 4 4 5 3 5 - NO

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Topological_Sort_Using_DFS.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void solveDFS(unordered_map<int, list<int> > &adjList, stack<int> &st, vector<bool> &visited, int node) {
    visited[node] = true;

    for(auto x : adjList[node]) {
        if(!visited[x]) {
            solveDFS(adjList, st, visited, x);
        }
    }

    st.push(node);
}

vector<int> topologicalSort(vector< vector<int> > &edges, int v, int e) {
    unordered_map<int, list<int> > adjList;
    for(int i=0; i<e; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        adjList[u].push_back(v);
    }

    vector<int> solution;
    stack<int> st;
    vector<bool> visited(v,0);

    for(int i=0; i<v; i++) {
        if(!visited[i]) {
            solveDFS(adjList, st, visited, i);
        }
    }

    while(!st.empty()) {
        solution.push_back(st.top());
        st.pop();
    }

    return solution;
}

int main() {
    vector< vector<int> > edges;
    int n, m;

    cout << "Enter number of nodes : ";
    cin >> n;

    cout << "Enter number of edges : ";
    cin >> m;

    cout << "Enter edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    vector<int> topSort = topologicalSort(edges, n, m);

    cout << "Topological Sort : ";
    for(int x : topSort) {
        cout << x << " ";
    }

    return 0;
}

// 4 4 0 1 1 2 0 3 3 2
// 6 7 0 1 0 2 1 3 2 3 3 4 3 5 4 5

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Topological_Sort_Using_Kahns_Algorithm.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void solveDFS(vector<int> &solution, unordered_map<int, list<int> > &adjList, queue<int> &qu, vector<int> &indegree, vector<bool> &visited) {
    if(qu.empty()) {
        return;
    }

    int frontVal = qu.front();
    qu.pop();
    solution.push_back(frontVal);
    visited[frontVal] = 1;

    for(int x : adjList[frontVal]) {
        indegree[x]--;
        
        if(!visited[x] && indegree[x] == 0) {
            qu.push(x);
        }
    }

    solveDFS(solution, adjList, qu, indegree, visited);
}

vector<int> topologicalSort(vector< vector<int> > &edges, int v, int e) {
    unordered_map<int, list<int> > adjList;
    vector<int> indegree(v,0);
    queue<int> qu;
    vector<bool> visited(v,0);
    vector<int> solution;

    for(int i=0; i<e; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
        indegree[v]++;
    }

    for(int i=0; i<v; i++) {
        if(indegree[i] == 0) {
            qu.push(i);
        }
    }

    for(int i=0; i<v; i++) {
        if(!visited[i]) {
            solveDFS(solution, adjList, qu, indegree, visited);
        }
    }

    return solution;
}

int main() {
    vector< vector<int> > edges;
    int n, m;

    cout << "Enter number of nodes : ";
    cin >> n;

    cout << "Enter number of edges : ";
    cin >> m;

    cout << "Enter edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    vector<int> topSort = topologicalSort(edges, n, m);

    cout << "Topological Sort : ";
    for(int x : topSort) {
        cout << x << " ";
    }

    return 0;
}

// 4 4 0 1 1 2 0 3 3 2
// 6 7 0 1 0 2 1 3 2 3 3 4 3 5 4 5

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Detect_Cycle_In_A_Directed_Graph.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

bool detectCyclicInDirectedGraph(int n, vector< pair<int,int> > &edges) {
    unordered_map<int, list<int> > adjList;
    vector<int> indegree(n,0);
    queue<int> qu;
    int count = 0;

    for(int i=0; i<edges.size(); i++) {
        int u = edges[i].first;
        int v = edges[i].second;
        adjList[u].push_back(v);
        indegree[v]++;
    }

    for(int i=0; i<n; i++) {
        if(indegree[i] == 0) {
            qu.push(i);
        }
    }

    while(!qu.empty()) {
        count++;

        int frontVal = qu.front();
        qu.pop();

        for(int x : adjList[frontVal]) {
            indegree[x]--;

            if(indegree[x] == 0) {
                qu.push(x);
            }
        }
    }

    return (count == n) ? false: true;
}

int main() {
    vector< pair<int,int> > edges;
    int n, m;

    cout << "Enter number of nodes : ";
    cin >> n;

    cout << "Enter number of edges : ";
    cin >> m;

    cout << "Enter edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    bool answer = detectCyclicInDirectedGraph(n, edges);

    if(answer) {
        cout << "Cycle is Present" << endl;
    } else {
        cout << "Cycle is Not Present" << endl;
    }

    return 0;
}

// 8 9 0 1 1 2 2 6 2 7 7 6 1 3 3 4 4 5 5 3 - YES
// 8 9 0 1 1 2 2 6 2 7 7 6 1 3 3 4 4 5 3 5 - NO

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Shortest_Path_In_Undirected_Graph.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> shortestPath(vector< pair<int,int> > &edges, int n, int m, int src, int tar) {
    // Creating adj list
    unordered_map< int, list<int> > adjList;
    for(int i=0; i<n; i++) {
        int u = edges[i].first;
        int v = edges[i].second;

        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    vector<int> visited(n,0);
    vector<int> parent(n,0);
    queue<int> qu;

    qu.push(src);
    visited[src] = 1;
    parent[src] = -1;

    while(!qu.empty()) {
        int val = qu.front();
        qu.pop();

        for(int x : adjList[val]) {
            if(visited[x] == 0) {
                visited[x] = 1;
                parent[x] = val;
                qu.push(x);
            }
        }
    }

    vector<int> solution;
    while(tar != src) {
        solution.push_back(tar);
        tar = parent[tar];
    }
    solution.push_back(src);

    reverse(solution.begin(), solution.end());
    return solution;
}

int main() {
    vector< pair<int,int> > edges;
    int n, m, src, tar;

    cout << "Enter the number of nodes : ";
    cin >> n;
    
    cout << "Enter the number of edges : ";
    cin >> m;

    cout << "Enter the edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back(make_pair(u,v));
    }

    cout << "Enter the source and target : ";
    cin >> src >> tar;

    vector<int> answer = shortestPath(edges, n, m, src, tar);
    cout << "The shortest path : ";
    for(int x : answer) {
        cout << x << " ";
    }

    return 0;
}

// 8 9 0 1 0 2 0 3 1 4 2 7 3 5 5 6 6 7 4 7

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Shortest_Path_In_Directed_Acyclic_Graph.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void solveDFS(unordered_map< int, list<pair<int,int>> > &adjList, stack<int> &st, vector<int> & visited, int node) {
    visited[node] = 1;

    for(pair<int,int> neigh : adjList[node]) {
        if(visited[neigh.first] == 0) {
            solveDFS(adjList, st, visited, neigh.first);
        }
    }

    st.push(node);
}

stack<int> topoSort(unordered_map< int, list<pair<int,int>> > adjList, int n) {
    stack<int> st;
    vector<int> visited(n,0);

    for(auto x : adjList) {
        if(visited[x.first] == 0) {
            solveDFS(adjList, st, visited, x.first);
        }
    }

    return st;
}

vector<int> shortestPath(vector< vector<int> > &edges, int n, int m, int src) {
    // Creating adj list
    unordered_map< int, list<pair<int,int>> > adjList;
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        int w = edges[i][2];

        adjList[u].push_back({v,w});
    }

    stack<int> st = topoSort(adjList, n);
    stack<int> temp = st;
    while(!temp.empty()) {
        cout << temp.top() << " ";
        temp.pop();
    }
    cout << endl;

    // Initialising distance vector
    vector<int> distance(n,INT_MAX);
    distance[src] = 0;

    while(!st.empty()) {
        int node = st.top();
        st.pop();

        if(distance[node] != INT_MAX) {
            for(auto x : adjList[node]) {
                if(distance[node] + x.second < distance[x.first]) {
                    distance[x.first] = distance[node] + x.second;
                }
            }
        }
    }

    return distance;
}

int main() {
    vector<vector<int>> edges;
    int n, m, src;

    cout << "Enter the number of nodes : ";
    cin >> n;
    
    cout << "Enter the number of edges : ";
    cin >> m;

    cout << "Enter the edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
    }

    cout << "Enter the source : ";
    cin >> src;

    vector<int> answer = shortestPath(edges, n, m, src);
    cout << "The shortest path : ";
    for(int x : answer) {
        cout << x << " ";
    }

    return 0;
}

// 6 9 0 1 5 1 2 2 1 3 6 0 2 3 2 3 7 3 4 -1 2 4 4 4 5 -2 2 5 2

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Shortest_Path_In_DAG_Using_Graph_Class.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

class Graph {
    public:
        unordered_map<int, list<pair<int,int>> > AdjList;

        void addEdge(int u, int v, int weight) {
            AdjList[u].push_back(make_pair(v,weight));
        }

        void printEdge() {
            for(auto x : AdjList) {
                cout << x.first << " -> ";
                for(auto y : x.second) {
                    cout << y.first << "[" << y.second << "]  ";
                }
                cout << endl;
            }
        }

        void solveDFS(stack<int> &st, vector<int> &visited, int node) {
            visited[node] = 1;
            for(pair<int,int> neigh : AdjList[node]) {
                if(visited[neigh.first] == 0) {
                    solveDFS(st, visited, neigh.first);
                }
            }
            st.push(node);
        } 

        stack<int> topoSort() {
            stack<int> st;
            vector<int> visited(6,0);
            
            for(auto x : AdjList) {
                if(visited[x.first] == 0) {
                    solveDFS(st, visited, x.first);
                }
            }

            return st;
        }

        vector<int> shortestPath(int src) {
            vector<int> distance(6, INT_MAX);
            distance[src] = 0;
            stack<int> st = topoSort();

            while(!st.empty()) {
                int val = st.top();
                st.pop();

                if(distance[val] != INT_MAX) {
                    for(auto x : AdjList[val]) {
                        if(distance[val] + x.second < distance[x.first])
                            distance[x.first] = distance[val] + x.second;
                    }
                }
            }

            return distance;
        }
};

int main() {
    Graph G;

    G.addEdge(0, 1, 5);
    G.addEdge(1, 2, 2);
    G.addEdge(1, 3, 6);
    G.addEdge(0, 2, 3);
    G.addEdge(2, 3, 7);
    G.addEdge(3, 4, -1);
    G.addEdge(2, 4, 4);
    G.addEdge(4, 5, -2);
    G.addEdge(2, 5, 2);

    // G.printEdge();

    vector<int> shot = G.shortestPath(1);

    for(auto x : shot) {
        if(x == INT_MAX) {
            cout << "INF" << " ";
        } else {
            cout << x << " ";
        }
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Shortest_Path_Using_Dijkstras_Algorithm.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> shortestPath(vector< vector<int> > &edges, int n, int m, int src) {
    // Creating adj list
    unordered_map< int, list<pair<int,int>> > adjList;
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        int w = edges[i][2];

        adjList[u].push_back({v,w});
        adjList[v].push_back({u,w});
    }

    vector<int> distance(n,INT_MAX);
    set<pair<int,int>> st;

    distance[src] = 0;
    st.insert({0,src});

    while(!st.empty()) {
        // Fetching top pair
        pair<int,int> curr = *(st.begin());

        int nodeDistance = curr.first;
        int topNode = curr.second;

        // Removing top pair
        st.erase(st.begin());

        for(auto neigh : adjList[topNode]) {
            if(nodeDistance + neigh.second < distance[neigh.first]) {
                auto record = st.find({distance[neigh.first], neigh.first});

                // Erasing old record
                if(record != st.end()) {
                    st.erase(record);
                }

                // Upadting distance
                distance[neigh.first] = nodeDistance + neigh.second;
                
                // Inserting new pair in set
                st.insert({distance[neigh.first], neigh.first});
            }
        }
    }

    return distance;
}

int main() {
    vector<vector<int>> edges;
    int n, m, src;

    cout << "Enter the number of nodes : ";
    cin >> n;
    
    cout << "Enter the number of edges : ";
    cin >> m;

    cout << "Enter the edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
    }

    cout << "Enter the source : ";
    cin >> src;

    vector<int> answer = shortestPath(edges, n, m, src);
    cout << "The shortest path : ";
    for(int x : answer) {
        cout << x << " ";
    }

    return 0;
}

// 4 5 0 1 5 1 2 9 1 3 2 2 3 6 0 2 8
// 5 7 2 1 3 1 4 1 0 3 2 2 0 1 1 0 7 1 3 5 3 4 7

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Prims_MST.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector< pair<pair<int,int>, int> > calculatePrimsMST(vector< vector<int> > &edges, int n, int m) {
    // Creating adj list
    unordered_map< int, list<pair<int,int>> > adjList;
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        int w = edges[i][2];

        adjList[u].push_back({v,w});
        adjList[v].push_back({u,w});
    }

    // Initiaising the required data structures
    vector<int> key(n, INT_MAX);
    vector<bool> mst(n, false);
    vector<int> parent(n, -1);

    // Initialising src node
    key[0] = 0;
    
    for(int i=0; i<n; i++) {
        // Calculating minimum from key vector
        int u, mini = INT_MAX;
        for(int i=0; i<key.size(); i++) {
            if(key[i] < mini && mst[i] == false) {
                u = i;
                mini = key[i];
            }
        }

        mst[u] = true;

        for(pair<int,int> x : adjList[u]) {
            if(mst[x.first] == false && x.second < key[x.first]) {
                key[x.first] = x.second;
                parent[x.first] = u;
            }
        }
    }

    vector< pair<pair<int,int>, int> > answer;
    for(int i=1; i<n; i++) {
        answer.push_back({{parent[i], i}, key[i]});
    }

    return answer;
}

int main() {
    vector<vector<int>> edges;
    int n, m, src;

    cout << "Enter the number of nodes : ";
    cin >> n;
    
    cout << "Enter the number of edges : ";
    cin >> m;

    cout << "Enter the edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
    }

    vector< pair<pair<int,int>, int> >  answer = calculatePrimsMST(edges, n, m);

    for(pair<pair<int,int>, int> x : answer) {
        pair<int,int> a = x.first;
        int b = x.second;

        /*
            a.first -> u
            a.second -> v
            b -> weight
        */
        cout << a.first << "-" << a.second << " : " << b << endl;
    }

    return 0;
}

// 5 6 0 3 6 0 1 2 1 3 8 1 4 5 1 2 3 2 4 7

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Disjoint_Set.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector< pair<pair<int,int>, int> > calculatePrimsMST(vector< vector<int> > &edges, int n, int m) {}

int findParent(vector<int> &parent, int node) {
    // Reached topmost point of hierarchy
    if(parent[node] == node) {
        return node;
    }

    // Going upwards in hierarchy
    /*
        PATH COMPRESSION LOGIC :

        Assigning result to parent[node] to moving it up in
        the hierarchy to make it accessible easily from the top
    */
    return parent[node] = findParent(parent, parent[node]);
}

void unionSet(int u, int v, vector<int> &parent, vector<int> &rank) {
    u = findParent(parent, u);
    v = findParent(parent, v);

    if(rank[u] < rank[v]) {
        parent[u] = v;
    } else if(rank[v] < rank[u]) {
        parent[v] = u;
        rank[u]++;
    } else {
        parent[v] = u;
        rank[u]++;
    }
}

void disjoint(vector< vector<int> > &edges, int n, int m) {
    vector<int> parent(n);
    vector<int> rank(n);

    // Initialising parent & rank
    for(int i=0; i<n; i++) {
        parent[i] = i;
        rank[i] = 0;
    }
}

int main() {
    vector<vector<int>> edges;
    int n, m, src;

    cout << "Enter the number of nodes : ";
    cin >> n;
    
    cout << "Enter the number of edges : ";
    cin >> m;

    cout << "Enter the edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
    }

    vector< pair<pair<int,int>, int> >  answer = calculatePrimsMST(edges, n, m);

    for(pair<pair<int,int>, int> x : answer) {
        pair<int,int> a = x.first;
        int b = x.second;

        /*
            a.first -> u
            a.second -> v
            b -> weight
        */
        cout << a.first << "-" << a.second << " : " << b << endl;
    }

    return 0;
}

// 5 6 0 3 6 0 1 2 1 3 8 1 4 5 1 2 3 2 4 7

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Kruskals_MST.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

// Writing own compare method to sort vector according to their 2nd index
bool compare(vector<int> &a, vector<int> &b) {
    return a[2] < b[2];
}

int findParent(vector<int> &parent, int node) {
    // Reached topmost point of hierarchy
    if(parent[node] == node) {
        return node;
    }

    // Going upwards in hierarchy
    /*
        PATH COMPRESSION LOGIC :

        Assigning result to parent[node] to moving it up in
        the hierarchy to make it accessible easily from the top
    */
    return parent[node] = findParent(parent, parent[node]);
}

void unionSet(int u, int v, vector<int> &parent, vector<int> &rank) {
    u = findParent(parent, u);
    v = findParent(parent, v);

    if(rank[u] < rank[v]) {
        parent[u] = v;
    } else if(rank[v] < rank[u]) {
        parent[v] = u;
        rank[u]++;
    } else {
        parent[v] = u;
        rank[u]++;
    }
}

int calculateKruskalsMST(vector< vector<int> > &edges, int n) {
    vector<int> parent(n);
    vector<int> rank(n);

    // Initialising parent & rank
    for(int i=0; i<n; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    // Sorting vector according to their weight
    sort(edges.begin(), edges.end(), compare);
    
    // Answer variable used to sum up the weights of nodes added in MST
    int minWeight = 0;

    for(int i=0; i<edges.size(); i++) {
        int u = findParent(parent, edges[i][0]);
        int v = findParent(parent, edges[i][1]);

        if(u != v) {
            unionSet(u, v, parent, rank);
            minWeight += edges[i][2];
        }
    }

    return minWeight;
}

int main() {
    vector<vector<int>> edges;
    int n, m, src;

    cout << "Enter the number of nodes : ";
    cin >> n;
    
    cout << "Enter the number of edges : ";
    cin >> m;

    cout << "Enter the edges : " << endl;
    for(int i=0; i<m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
    }

    int minWeight = calculateKruskalsMST(edges, n);

    cout << "Weight of Kruskal's MST : " << minWeight << endl;

    return 0;
}

// 5 6 0 3 6 0 1 2 1 3 8 1 4 5 1 2 3 2 4 7

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Bridges_In_Graph.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void dfs(int node, int parent, int &timer, vector<int> &disc,
    vector<int> &low, vector<vector<int>> &result,
    unordered_map<int, list<int>> &adjList, vector<bool> &visited) {

    visited[node] = true;
    disc[node] = low[node] = timer++;

    for(auto neigh : adjList[node]) {
        if(neigh == parent) continue;

        if(visited[neigh] == false) {
            dfs(neigh, node, timer, disc, low, result, adjList, visited);
            low[node] = min(low[node], low[neigh]);

            // Check bridge edge
            if(low[neigh] > disc[node]) {
                result.push_back({node, neigh});
            }
        } else {
            // Back edge found
            low[node] = min(low[node], disc[neigh]);
        }
    }
}

vector<vector<int>> findBridges(vector<vector<int>> &edges, int n, int m) {
    // Create adjList
    unordered_map<int, list<int>> adjList;
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
        adjList[v].push_back(u); 
    }

    int timer = 0;
    vector<int> disc(n, -1);
    vector<int> low(n, -1);
    int parent = -1;
    vector<bool> visited(n, false);
    vector<vector<int>> result;

    // DFS
    for(int i=0; i<n; i++) {
        if(!visited[i]) {
            dfs(i, parent, timer, disc, low, result, adjList, visited);
        }
    }

    return result;
}

int main() {
    vector<vector<int>> edges;
    int n, m;

    cout << "Enter the value of n : ";
    cin >> n;

    cout << "Enter the value of m : ";
    cin >> m;

    cout << "Enter the edges :" << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    vector<vector<int>> answer = findBridges(edges, n, m);

    cout << "Bridge Edges : ";
    for(int i=0; i<answer.size(); i++) {
        cout << "[" << answer[i][0] << "," << answer[i][1] << "] ";
    }
    cout << endl;

    return 0;
}


/*
    5 6 0 1 0 3 1 3 1 2 2 3 3 4
    5 5 0 1 0 3 0 2 1 2 3 4
    6 7 0 1 0 2 1 2 2 3 3 4 3 5 4 5
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Articulation_Point_In_Graph.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void dfs(int node, int parent, int &timer, vector<int> &disc,
    vector<int> &low, vector<int> &result, unordered_map<int, list<int>> &adjList,
    vector<bool> &visited) {

    visited[node] = true;
    disc[node] = low[node] = timer++;
    int child = 0;

    for(auto neigh : adjList[node]) {
        if(neigh == parent) continue;

        if(visited[neigh] == false) {
            dfs(neigh, node, timer, disc, low, result, adjList, visited);
            low[node] = min(low[node], low[neigh]);

            // Check articulation point / cut vertex
            if(low[neigh] >= disc[node] && parent != -1) {
                result.push_back(node);
            }
            child++;
        } else {
            // Back edge found
            low[node] = min(low[node], disc[neigh]);
        }
    }

    // Checking for starting node
    if(parent == -1 && child > 1) {
        result.push_back(node);
    }
}

vector<int> cutVertex(vector<vector<int>> &edges, int n, int m) {
    // Create adjList
    unordered_map<int, list<int>> adjList;
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
        adjList[v].push_back(u); 
    }

    int timer = 0;
    int parent = -1;

    vector<int> disc(n, -1);
    vector<int> low(n, -1);
    vector<bool> visited(n, false);
    vector<int> result;

    // DFS
    for(int i=0; i<n; i++) {
        if(!visited[i]) {
            dfs(i, parent, timer, disc, low, result, adjList, visited);
        }
    }

    return result;
}

int main() {
    vector<vector<int>> edges;
    int n, m;

    cout << "Enter the value of n : ";
    cin >> n;

    cout << "Enter the value of m : ";
    cin >> m;

    cout << "Enter the edges :" << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    vector<int> answer = cutVertex(edges, n, m);
    sort(answer.begin(), answer.end());

    cout << "Articulation Points : ";
    for(int i=0; i<answer.size(); i++) {
        cout << answer[i] << " ";
    }
    cout << endl;

    return 0;
}


/*
    5 6 0 1 0 3 1 3 1 2 2 3 3 4
    5 5 0 1 0 3 0 2 1 2 3 4
    6 7 0 1 0 2 1 2 2 3 3 4 3 5 4 5
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Kosaraju_Algorithm.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

void topoSort(int node, vector<bool> &visited, stack<int> &st,
    unordered_map<int, list<int>> &adjList) {

    visited[node] = true;

    for(int neigh : adjList[node]) {
        if(visited[neigh] == false) {
            topoSort(neigh, visited, st, adjList);
        }
    }

    st.push(node);
}

void revDFS(int node, vector<bool> &visited, unordered_map<int, list<int>> &transpose) {
    visited[node] = true;
    
    for(int neigh : transpose[node]) {
        if(visited[neigh] == false) {
            revDFS(neigh, visited, transpose);
        }
    }
}

int stronglyConnectedComponents(vector<vector<int>> &edges, int n, int m) {
    // Create adjList
    unordered_map<int, list<int>> adjList;
    for(int i=0; i<m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        adjList[u].push_back(v);
    }

    // Topoplogical Sort
    stack<int> st;
    vector<bool> visited(n, false);
    
    for(int i=0; i<n; i++) {
        if(visited[i] == false) {
            topoSort(i, visited, st, adjList);
        }
    }

    // Transpose Graph
    unordered_map<int, list<int>> transpose;
    for(int i=0; i<n; i++) {
        visited[i] = false;
        for(int neigh : adjList[i]) {
            transpose[neigh].push_back(i);
        }
    }

    // DFS call on topological sort
    int count = 0;
    while(!st.empty()) {
        int top = st.top();
        st.pop();

        if(visited[top] == false) {
            count++;
            revDFS(top, visited, transpose);
        }
    }

    return count;
}

int main() {
    vector<vector<int>> edges;
    int n, m;

    cout << "Enter the value of n : ";
    cin >> n;

    cout << "Enter the value of m : ";
    cin >> m;

    cout << "Enter the edges :" << endl;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u,v});
    }

    int answer = stronglyConnectedComponents(edges, n, m);

    cout << "Total Strongly Connected Components : " << answer << endl;

    return 0;
}


/*
    5 5 1 0 0 2 2 1 2 3 3 4
    5 6 0 1 1 4 1 2 4 0 2 3 3 2
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Bellmon_Ford_Algorithm.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> shortestPath(vector<vector<int>> &edges, int n, int m, int src) {
    vector<int> distance(n, INT_MAX);
    distance[src] = 0;

    for(int i=0; i<n-1; i++) {
        
        for(int j=0; j<m; j++) {
            int u = edges[j][0];
            int v = edges[j][1];
            int w = edges[j][2];

            if(distance[u] + w < distance[v]) {
                distance[v] = distance[u] + w;
            }
        }

    }

    for(int j=0; j<m; j++) {
        int u = edges[j][0];
        int v = edges[j][1];
        int w = edges[j][2];

        if(distance[u] + w < distance[v]) {
            return vector<int> (n, INT_MAX);
        }
    }

    return distance;
}

int main() {
    vector<vector<int>> edges;
    int n, m, src;

    cout << "Enter the value of n : ";
    cin >> n;

    cout << "Enter the value of m : ";
    cin >> m;

    cout << "Enter the edges :" << endl;
    for(int i=0; i<m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
    }

    cout << "Enter the source node : ";
    cin >> src;

    vector<int> answer = shortestPath(edges, n, m, src);

    cout << "Shortest path from " << src << " : ";
    for(int x : answer) {
        if(x == INT_MAX) {
            cout << "INF ";
        } else {
            cout << x << " ";
        }
    }
    cout << endl;

    return 0;
}


/*
    3 3 0 1 2 1 2 -1 0 2 2
*/

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Fibonacci_Series.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int fibRec(int n) {
    if(n <= 1) return n;
    return fibRec(n-1) + fibRec(n-2);
}

/*
    Top-down approach (Recursion + Memoisation)
    TC : O(N)
    SC : O(N) + O(N) : O(N)
*/
int fibDP(int n, vector<int> &dp) {
    if(n <= 1) {
        return n;
    }

    if(dp[n] != -1) {
        return dp[n];
    }

    dp[n] = fibDP(n-1, dp) + fibDP(n-2, dp);
    return dp[n];
}

/*
    Bottom-up approach (Tabulation)
    TC : O(N)
    SC : O(N)
*/
int fibDP(int n) {
    vector<int> dp(n+1, -1);
    dp[0] = 0;
    dp[1] = 1;

    for(int i=2; i<=n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}

/*
    Space optimisation approach
    TC : O(N)
    SC : O(1)
*/
int fibDP2(int n) {
    if(n <= 1) return n;

    int prev1 = 1;
    int prev2 = 0;

    for(int i=2; i<=n; i++) {
        int curr = prev1 + prev2;
        
        prev2 = prev1;
        prev1 = curr;
    }

    return prev1;
}

int main() {
    int n;
    cout << "Enter n : ";
    cin >> n;

    // int ans = fibRec(n);
    
    vector<int> dp(n+1, -1);
    int ans = fibDP(n, dp);
    
    cout << "Nth fibonacci number : " << ans << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Climbing_Stairs.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int totalWaysRec(int n) {
    if(n<=0) return 0;
    if(n<=2) return n;
    return totalWaysRec(n-1) + totalWaysRec(n-2);
}

int totalWaysRec2(int n, int i) {
    if(i==n) return 1;
    if(i>n) return 0;
    return totalWaysRec2(n, i+1) + totalWaysRec2(n, i+2);
}

/*
    Recursion + Memoization
*/
int totalWaysDP(int n, vector<int> &dp) {
    if(n<=0) return 0;
    if(n<=2) return n;
    
    if(dp[n] != 0) return dp[n];

    dp[n] = totalWaysDP(n-1, dp) + totalWaysDP(n-2, dp);
    return dp[n];
}

/*
    Tabulation
*/
int totalWaysDP(int n) {
    vector<int> dp(n+1, 0);
    dp[0] = dp[1] = 1;
    
    for(int i=2; i<=n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}

/*
    Space optimisation
*/
int totalWaysDP2(int n) {
    int prev1 = 1;
    int prev2 = 1;

    for(int i=2; i<=n; i++) {
        int curr = prev1 + prev2;

        prev2 = prev1;
        prev1 = curr;
    }

    return prev1;
}

int main() {
    // int n;
    // cout << "Enter n : ";
    // cin >> n;

    // int ans = totalWaysRec(n);

    // vector<int> dp(n+1, 0);
    // int ans = totalWaysDP(n, dp);

    // cout << "Total ways to climb " << n << " stairs : " << ans << endl;

    vector<int> input = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 37};
    for(int i=0; i<input.size(); i++) {
        vector<int> dp(input[i]+1, 0);

        cout << "For " << input[i] << " : ";
        cout << totalWaysRec(input[i]) << " ";
        cout << totalWaysRec2(input[i], 0) << " ";
        cout << totalWaysDP(input[i], dp) << " ";
        cout << totalWaysDP(input[i]) << " ";
        cout << totalWaysDP2(input[i]) << endl;
    }

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 2_Min_Cost_Climbing_Stairs.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

/*
    Recursion
*/
int minCost(vector<int> &stairs, int i) {
    if(i < 0) {
        return 0;
    }

    if(i <= 1) {
        return stairs[i];
    }
    
    int ans = min(minCost(stairs, i-1) , minCost(stairs, i-2));
    return stairs[i] + ans;
}

/*
    Recursion + Memoization
*/
int minCost(vector<int> &stairs, int i, vector<int> &dp) {
    if(i < 0) {
        return 0;
    }

    if(i <= 1) {
        return stairs[i];
    }
    
    // int one, two;

    // if(dp[i-1] != 0) one = dp[i-1];
    // else one = minCost(stairs, i-1, dp);
    
    // if(dp[i-2] != 0) two = dp[i-2];
    // else two = minCost(stairs, i-2, dp);


    // dp[i] = stairs[i] + min(one,two);

    if(dp[i] != 0) return dp[i];

    dp[i] = stairs[i] + min(minCost(stairs, i-1, dp), minCost(stairs, i-2, dp));

    return dp[i];
}

/*
    Tabulation
*/
int minCost(vector<int> &stairs) {
    int n = stairs.size();
    vector<int> dp(n, 0);
    dp[0] = stairs[0];
    dp[1] = stairs[1];

    for(int i=2; i<n; i++) {
        int prevCost = min(dp[i-1], dp[i-2]);
        dp[i] = stairs[i] + prevCost;
    }
    
    return min(dp[n-1], dp[n-2]);
}

/*
    Space optimisation
*/
int minCost2(vector<int> &stairs) {
    int n = stairs.size();
    int prev0 = stairs[0];
    int prev1 = stairs[1];

    for(int i=2; i<n; i++) {
        int curr = stairs[i] + min(prev0, prev1);

        prev0 = prev1;
        prev1 = curr;
    }
    
    return min(prev0, prev1);
}

int main() {
    int n;
    cout << "Enter the count of stairs : ";
    cin >> n;

    vector<int> stairs(n,0);
    cout << "Enter the cost of stairs : ";
    for(int i=0; i<n; i++) cin >> stairs[i];

    // int ans = min(minCost(stairs, n-1) , minCost(stairs, n-2));


    // vector<int> dp(n,0);
    // dp[0] = stairs[0];
    // dp[1] = stairs[1];
    // int ans = min(minCost(stairs, n-1, dp), minCost(stairs, n-2, dp));
    
    int ans = minCost2(stairs);
    cout << "Minimum cost: " << ans << endl;

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Minimum_Elements.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

/*
    Recursion
*/
int minElementsRec(vector<int> &coins, int target) {
    if(target == 0) return 0;
    if(target < 0) return INT_MAX;

    int mini = INT_MAX;

    for(int i=0; i<coins.size(); i++) {
        int ans = minElementsRec(coins, target-coins[i]);

        if(ans != INT_MAX) {
            mini = min(mini, ans+1);
        }
    }

    return mini;
}  

/*
    Recursion + Memoisation
*/
int minElementsDP(vector<int> &dp, vector<int> &coins, int target) {
    if(target == 0) return 0;
    if(target < 0) return INT_MAX;

    if(dp[target] != -1) return dp[target];

    int mini = INT_MAX;
    for(int i=0; i<coins.size(); i++) {
        int ans = minElementsDP(dp, coins, target-coins[i]);

        if(ans != INT_MAX) {
            mini = min(mini, ans+1);
        }
    }
    
    dp[target] = mini;
    return mini;
}

/*
    Tabulation
*/
int minElementsTab(vector<int> &coins, int target) {
    vector<int> dp(target+1, INT_MAX);
    dp[0] = 0;

    for(int i=1; i<=target; i++) {

        for(int c=0; c<coins.size(); c++) {

            if(i-coins[c] >= 0 && dp[i-coins[c]] != INT_MAX) {
                dp[i] = min(dp[i], dp[i-coins[c]] + 1);
            }

        }
    }

    return dp[target];
}

int main() {
    vector<int> coins;
    int target;

    cout << "Enter the coins array (-1 to stop) : ";
    int temp;
    cin >> temp;
    while(temp != -1) {
        coins.push_back(temp);
        cin >> temp;
    }

    cout << "Enter the target : ";
    cin >> target;
    
    vector<int> dp(target+1, -1);
    
    int minCoin = minElementsTab(coins, target);
    if(minCoin != INT_MAX) {
        cout << "Required minimum coins : " << minCoin << endl;
    } else {
        cout << "Required minimum coins : " << -1 << endl;
    }
    

    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Max_Non_Adjacent_Sum.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int maxSumRec(vector<int> &nums, int index, int sum) {
    if(index >= nums.size()) return sum;

    int inc = maxSumRec(nums, index+2, sum+nums[index]);
    int exc = maxSumRec(nums, index+1, sum);

    return max(inc, exc);
}

int maxSumMem(vector<int> &dp, vector<int> &nums, int index, int sum) {
    if(index >= nums.size()) return sum;
    if(dp[index] != -1) return max(sum, dp[index]);

    int inc = maxSumMem(dp, nums, index+2, sum+nums[index]);
    int exc = maxSumMem(dp, nums, index+1, sum);

    dp[index] = max(inc, exc);
    return dp[index];
}

int maxSumTab(vector<int> &nums) {
    vector<int> dp(nums.size(), -1);
    dp[0] = nums[0];
    dp[1] = nums[1];

    for(int i=2; i<nums.size(); i++) {
        int inc = dp[i-2] + nums[i];
        int exc = dp[i-1];

        dp[i] = max(inc, exc);
    }

    return dp[nums.size() - 1];
}

int maxSumSpc(vector<int> &nums) {
    int prev0 = 0;
    int prev1 = nums[0];

    for(int i=1; i<nums.size(); i++) {
        int inc = prev0 + nums[i];
        int exc = prev1;

        int curr = max(inc, exc);

        prev0 = prev1;
        prev1 = curr;
    }

    return prev1;
}

int main() {
    vector<int> nums;
    cout << "Enter the array (-1 to stop) : ";
    int i;
    cin >> i;
    while(i != -1) {
        nums.push_back(i);
        cin >> i;
    }

    // int ans = maxSumRec(nums, 0, 0);

    // vector<int> dp(nums.size(), -1);
    // int ans = maxSumMem(dp, nums, 0, 0);

    // int ans = maxSumTab(nums);

    int ans = maxSumSpc(nums);

    cout << "Maximum sum of non-adjacent elements : " << ans << endl;
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_House_Robber_Problem.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int maxMoneyRec(vector<int> &houses, int index, int n, int sum) {
    if(index >= n) return sum;

    int inc = maxMoneyRec(houses, index+2, n, sum+houses[index]);
    int exc = maxMoneyRec(houses, index+1, n, sum);

    return max(inc, exc);
}

int maxMoneyMem(vector<int> &dp, vector<int> &houses, int index, int n, int sum) {
    if(index >= n) return sum;
    if(dp[index] != -1) return max(sum, dp[index]);

    int inc = maxMoneyMem(dp, houses, index+2, n, sum+houses[index]);
    int exc = maxMoneyMem(dp, houses, index+1, n, sum);

    dp[index] = max(inc, exc);
    return dp[index];
}

int maxMoneyTab(vector<int> &houses, int index, int n, int sum) {
    vector<int> dp(houses.size(), -1);

    dp[0] = 0;
    dp[1] = houses[index];

    for(int i=index+1; i<n; i++) {
        int inc = dp[i-2] + houses[i];
        int exc = dp[i-1];

        dp[i] = max(inc, exc);
    }

    return max(dp[n-1], dp[n-2]);
}

int maxMoneySpc(vector<int> &houses, int index, int n) {
    int prev0 = 0;
    int prev1 = houses[index];

    for(int i=index+1; i<n; i++) {
        int inc = prev0 + houses[i];
        int exc = prev1;

        int curr = max(inc, exc);

        prev0 = prev1;
        prev1 = curr;
    }

    return max(prev0, prev1);
}

int main() {
    vector<int> houses;
    cout << "Enter the money of houses (-1 to stop) : ";
    int i;
    cin >> i;
    while(i != -1) {
        houses.push_back(i);
        cin >> i;
    }

    int money1 = maxMoneyRec(houses, 0, houses.size()-1, 0);
    int money2 = maxMoneyRec(houses, 1, houses.size(), 0);

    cout << "Maximum money that can be robbed : " << max(money1, money2) << endl;

    return 0;
}


```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



# 1_Cut_Rod_Into_Segments.cpp


```cpp

#include <bits/stdc++.h>
using namespace std;

int cutSegmentsRec(int n, int x, int y, int z) {
    if(n == 0) {return 0;}
    if(n < 0) {return INT_MIN;}

    int cutx = cutSegmentsRec(n-x, x, y, z) + 1;
    int cuty = cutSegmentsRec(n-y, x, y, z) + 1;
    int cutz = cutSegmentsRec(n-z, x, y, z) + 1;

    return max(cutx, max(cuty, cutz));
}

int cutSegmentsMem(vector<int> &dp, int n, int x, int y, int z) {
    if(n == 0) {return 0;}
    if(n < 0) {return INT_MIN;}

    if(dp[n] != -1) {return dp[n];}

    int cutx = cutSegmentsMem(dp, n-x, x, y, z) + 1;
    int cuty = cutSegmentsMem(dp, n-y, x, y, z) + 1;
    int cutz = cutSegmentsMem(dp, n-z, x, y, z) + 1;

    dp[n] = max(cutx, max(cuty, cutz));
    return dp[n];
}

int cutSegmentsTab(int n, int x, int y, int z) {
    vector<int> dp(n+1, INT_MIN);
    dp[0] = 0;

    for(int i=1; i<=n; i++) {
        if(i-x >= 0) dp[i] = max(dp[i], dp[i-x] + 1);
        if(i-y >= 0) dp[i] = max(dp[i], dp[i-y] + 1);
        if(i-z >= 0) dp[i] = max(dp[i], dp[i-z] + 1);
    }

    return dp[n] < 0 ? 0 : dp[n];
}

int cutSegmentsTab(int n, int x, int y, int z) {
    vector<int> dp(n+1, INT_MIN);
    dp[0] = 0;

    for(int i=1; i<=n; i++) {
        if(i-x >= 0) dp[i] = max(dp[i], dp[i-x] + 1);
        if(i-y >= 0) dp[i] = max(dp[i], dp[i-y] + 1);
        if(i-z >= 0) dp[i] = max(dp[i], dp[i-z] + 1);
    }

    return dp[n] < 0 ? 0 : dp[n];
}

int main() {
    int n, x, y, z;
    cout << "Enter the value of n : ";
    cin >> n;

    cout << "Enter the value of x, y and z : ";
    cin >> x >> y >> z;
    
    cout << "Max cuts : " << cutSegmentsRec(n, x, y, z) << endl;

    vector<int> dp(n+1, -1);
    cout << "Max cuts : " << cutSegmentsMem(dp, n, x, y, z) << endl;
   
    return 0;
}

```

****************************************************************************************************
****************************************************************************************************
****************************************************************************************************



